* heat_map_train.py *:
@@@
import pathlib

BASE_DIR = pathlib.Path(__file__).parent

# torch & related imports
import numpy as np
import torch


# You can train graph neural networks here (actually you can edit the whole file).
# Save them in str(BASE_DIR / "pretrained") directory and use them in `heat_map_inference.py`.
# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).

# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).
# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.

# Possible GNN step (just in case, implement if you like): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.


if __name__ == "__main__":
    print("Sample output to log")
@@@

* heat_map_inference.py *:
@@@
import os
import sys
import pathlib
import argparse
import numpy as np

BASE_DIR = pathlib.Path(__file__).parent
sys.path.append(str(BASE_DIR))

# other imports
from heat_map_train import *


def calc_heat_map(cities: np.ndarray) -> np.ndarray:
    cities_number = cities.shape[0]

    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / "pretrained")
    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).

    return np.zeros((cities_number, cities_number), dtype=float)


if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--out", required=True, help="Path to .npy to write the heat map.")
    args = p.parse_args()

    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)
    first_stdin_line = sys.stdin.readline().strip()
    cities_number = int(first_stdin_line)
    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)

    # calculating heat map
    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)
    print("Sample output to log")

    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)
    tmp_path = args.out + ".tmp"

    with open(tmp_path, "wb") as output_temp_file:
        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto “.npy” added
        output_temp_file.flush()
        os.fsync(output_temp_file.fileno())
    
    os.replace(tmp_path, args.out)
@@@

* include/utils.hpp *:
@@@
#pragma once

// standart imports
#include <queue>
#include <cmath>
#include <numeric>
#include <algorithm>

// other imports
#include "context.hpp"


constexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood–Halton–Hammersley (BHH) constant


long long int64_sqrt(long long value) {
    if (value < 0) return null;  // invalid for negatives
    if (value < 2) return value;

    constexpr long long MAX_SQRT_LL = 3037000499LL;

    long long left = 1;
    long long right = std::min<long long>(value, MAX_SQRT_LL);
    long long floor_root = 1;

    while (left <= right) {
        long long candidate = left + (right - left) / 2;

        if (candidate <= value / candidate) {
            floor_root = candidate;
            left = candidate + 1;
        } else {
            right = candidate - 1;
        }
    }
    return floor_root;
}

double smooth_relu(double x) {
    if (x < 0) { return pow(e, x); }
    return x + 1.0;
}


double calc_distance_double(Context& context, int i, int j) {
    if (i == j) { return inf_double; }
    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);
    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);
    return sqrt(diff_x * diff_x + diff_y * diff_y);
}

int calc_distance_int32(Context& context, int i, int j) {
    if (i == j) { return inf_int32; }
    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);
    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);
    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));
}

long long calc_distance_int64(Context& context, int i, int j) {
    if (i == j) { return inf_int64; }
    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];
    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];
    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);
}


double get_distance_double(const Config& config, Context& context, int i, int j) {
    return context.distance_double[i * config.cities_number + j];
}

int get_distance_int32(const Config& config, Context& context, int i, int j) {
    return context.distance_int32[i * config.cities_number + j];
}

long long get_distance_int64(const Config& config, Context& context, int i, int j) {
    return context.distance_int64[i * config.cities_number + j];
}


double calc_total_distance_double(const Config& config, Context& context) {
    double total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_double(config, context, i, context.path[i].next);
    }

    return total_distance;
}

int calc_total_distance_int32(const Config& config, Context& context) {
    int total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_int32(config, context, i, context.path[i].next);
    }

    return total_distance;
}

long long calc_total_distance_int64(const Config& config, Context& context) {
    long long total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_int64(config, context, i, context.path[i].next);
    }

    return total_distance;
}


void calc_and_save_total_distance(const Config& config, Context& context) {
    if (config.distance_type == DistanceType::Double) {
        context.path_distance_double = calc_total_distance_double(config, context);
    }
    if (config.distance_type == DistanceType::Int32) {
        context.path_distance_int32 = calc_total_distance_int32(config, context);
    }
    if (config.distance_type == DistanceType::Int64) {
        context.path_distance_int64 = calc_total_distance_int64(config, context);
    }
}


void update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {
    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);
    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);

    context.weight[i * config.cities_number + j] += weight_delta;
    context.weight[j * config.cities_number + i] += weight_delta;

    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);
    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);
}


void identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {
	for (int i = 0; i < config.cities_number; ++i) {
        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota

        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {
            if (i == u) { return false; }
            if (i == v) { return true; }
            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);
        });
		
		for (int j = 0; j < config.candidates_number; ++j) {
			context.candidates[i * config.candidates_number + j] = context.buffer[j];
	    }
	}
}


int get_random_int_by_module(int mod) {
	return rand() % mod;
}


bool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {
    return (i == j || context.path[i].next == j || context.path[j].next == i);
}


void reverse_sub_path(Context& context, int i, int j) {
    int current_city = i;

    while (true) {
        std::swap(context.path[current_city].prev, context.path[current_city].next);

        if (current_city == j) { return; }

        current_city = context.path[current_city].prev;
    }
}


double expected_optimal_tsp_length_2d(long long n, double width, double height) {
    if (n <= 1 || width <= 0.0 || height <= 0.0) {
        return 0.0;
    }

    double area = width * height;
    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);
    return expected_length;
}
@@@

* include/context.hpp *:
@@@
#pragma once

// standart imports
#include <string>
#include <vector>
#include <limits>
#include <iostream>


// global variables declaration
constexpr int null = -1;
constexpr double e = 2.718281;
constexpr double inf_double = std::numeric_limits<double>::infinity();
constexpr int inf_int32 = std::numeric_limits<int>::max();
constexpr long long inf_int64 = std::numeric_limits<long long>::max();


enum class CandidatesSource { KNN, HeatMap };
enum class DistanceType { Int32, Int64, Double };


struct Config {
    int cities_number;
    std::string input_path;
    std::string output_path;
    bool use_heat_map_as_initial_weights;
    CandidatesSource candidates_source;
    int candidates_number;
    int max_k_opt_depth;
    bool random_k_opt_depth_after_first_iteration;
    double min_potential_to_consider;
    double exploration_coefficient;
    double weight_delta_coefficient;
    bool use_sensitivity_decrease;
    double sensitivity_temperature;
    int max_k_opt_simulations_without_improve_to_stop;
    int restarts_number;
    DistanceType distance_type;
    double magnify_rate;

    Config(const json& config) {
        cities_number = config["cities_number"];
        input_path = config["input_path"];
        output_path = config["output_path"];
        use_heat_map_as_initial_weights = config["use_heat_map_as_initial_weights"];

        if (config["candidates_source"].get<std::string>() == "knn") {
            candidates_source = CandidatesSource::KNN;
        } else if (config["candidates_source"].get<std::string>() == "heat_map") {
            candidates_source = CandidatesSource::HeatMap;
        } else {
            throw std::invalid_argument("Unknown candidates source: '" + config["candidates_source"].get<std::string>() + "'.");
        }

        candidates_number = config["candidates_number"];
        max_k_opt_depth = config["max_k_opt_depth"];
        random_k_opt_depth_after_first_iteration = config["random_k_opt_depth_after_first_iteration"];
        min_potential_to_consider = config["min_potential_to_consider"];
        exploration_coefficient = config["exploration_coefficient"];
        weight_delta_coefficient = config["weight_delta_coefficient"];
        use_sensitivity_decrease = config["use_sensitivity_decrease"];
        sensitivity_temperature = config["sensitivity_temperature"];
        max_k_opt_simulations_without_improve_to_stop = config["max_k_opt_simulations_without_improve_to_stop"];
        restarts_number = config["restarts_number"];

        if (config["distance_type"].get<std::string>() == "int32") {
            distance_type = DistanceType::Int32;
        } else if (config["distance_type"].get<std::string>() == "int64") {
            distance_type = DistanceType::Int64;
        } else if (config["distance_type"].get<std::string>() == "double") {
            distance_type = DistanceType::Double;
        } else {
            throw std::invalid_argument("Unknown distance type: '" + config["distance_type"].get<std::string>() + "'.");
        }

        magnify_rate = config["magnify_rate"];

        // warnings
        if (distance_type == DistanceType::Double) {
            if (cities_number > 1'000'000) {
                std::cout << "Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\n";
            }
        } else {
            if (magnify_rate < 10'000.0) {
                std::cout << "Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\n";
            }
            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {
                std::cout << "Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\n";
            }
            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {
                std::cout << "Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\n";
            }
        }
    }
};


struct City {
  int prev;
  int next;
};


struct Context {
    // coordinates
    double* coordinates_double_x = nullptr;
    double* coordinates_double_y = nullptr;

    int* coordinates_int32_x = nullptr;
    int* coordinates_int32_y = nullptr;

    long long* coordinates_int64_x = nullptr;
    long long* coordinates_int64_y = nullptr;

    // distances
    double* distance_double = nullptr;
    int* distance_int32 = nullptr;
    long long* distance_int64 = nullptr;

    // weights
    double* heat_map = nullptr;
    double* weight = nullptr;
    double* total_weight = nullptr;
    double* potential = nullptr;

    // candidates
    int* candidates = nullptr;

    // local k opt search
    int* pairs = nullptr;
    int* saved_pairs = nullptr;
    int saved_depth = 0;

    double current_best_delta_double = -inf_double;
    int current_best_delta_int32 = -inf_int32;
    long long current_best_delta_int64 = -inf_int64;

    long long* chosen_times = nullptr;
    long long total_simulations = 0;

    // path
    City* path = nullptr;
    double path_distance_double = inf_double;
    int path_distance_int32 = inf_int32;
    long long path_distance_int64 = inf_int64;

    City* best_path = nullptr;
    double best_path_distance_double = inf_double;
    int best_path_distance_int32 = inf_int32;
    long long best_path_distance_int64 = inf_int64;

    int* solution;
    std::vector<bool> is_city_selected;

    // other utils/tmp variables
    std::vector<int> buffer;

    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {
        coordinates_double_x = new double[config.cities_number];
        coordinates_double_y = new double[config.cities_number];

        if (config.distance_type == DistanceType::Int32) {
            coordinates_int32_x = new int[config.cities_number];
            coordinates_int32_y = new int[config.cities_number];
        }
        if (config.distance_type == DistanceType::Int64) {
            coordinates_int64_x = new long long[config.cities_number];
            coordinates_int64_y = new long long[config.cities_number];
        }

        distance_double = new double[config.cities_number * config.cities_number];
        if (config.distance_type == DistanceType::Int32) {
            distance_int32 = new int[config.cities_number * config.cities_number];
        }
        if (config.distance_type == DistanceType::Int64) {
            distance_int64 = new long long[config.cities_number * config.cities_number];
        }

        if (config.use_heat_map_as_initial_weights) {
            heat_map = new double[config.cities_number * config.cities_number];
        }
        weight = new double[config.cities_number * config.cities_number];
        total_weight = new double[config.cities_number];
        potential = new double[config.cities_number * config.cities_number];

        candidates = new int[config.cities_number * config.candidates_number];

        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option
        saved_pairs = new int[config.cities_number];

        chosen_times = new long long[config.cities_number * config.cities_number];
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            chosen_times[i] = 0;
        }

        path = new City[config.cities_number];
        best_path = new City[config.cities_number];
        solution = new int[config.cities_number];
    }

    ~Context() {
        delete[] coordinates_double_x;
        delete[] coordinates_double_y;

        if (coordinates_int32_x) { delete[] coordinates_int32_x; }
        if (coordinates_int32_y) { delete[] coordinates_int32_y; }

        if (coordinates_int64_x) { delete[] coordinates_int64_x; }
        if (coordinates_int64_y) { delete[] coordinates_int64_y; }

        delete[] distance_double;
        if (distance_int32) { delete[] distance_int32; }
        if (distance_int64) { delete[] distance_int64; }

        if (heat_map) { delete[] heat_map; }
        delete[] weight;
        delete[] total_weight;
        delete[] potential;

        delete[] candidates;

        delete[] pairs;
        delete[] saved_pairs;

        delete[] chosen_times;

        delete[] path;
        delete[] best_path;
        delete[] solution;
    }
};


void convert_solution_to_path(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        int current_city = context.solution[i];

        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];
        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];
    }
}

void convert_path_to_solution(const Config& config, Context& context) {
    int current_city = 0;

    for (int i = 0; i < config.cities_number; ++i) {
        context.solution[i] = current_city;

        current_city = context.path[current_city].next;
    }
}

void store_path_as_best(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        context.best_path[i].prev = context.path[i].prev;
        context.best_path[i].next = context.path[i].next;
    }

    if (config.distance_type == DistanceType::Double) {
        context.best_path_distance_double = context.path_distance_double;
    }
    if (config.distance_type == DistanceType::Int32) {
        context.best_path_distance_int32 = context.path_distance_int32;
    }
    if (config.distance_type == DistanceType::Int64) {
        context.best_path_distance_int64 = context.path_distance_int64;
    }
}

void restore_best_path(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        context.path[i].prev = context.best_path[i].prev;
        context.path[i].next = context.best_path[i].next;
    }
}
@@@

* include/random_solution.hpp *:
@@@
#pragma once


// * The following functions are used to randomly generate an initial solution.
// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.


int select_random_city(const Config& config, Context& context) {
	int random_start = get_random_int_by_module(config.cities_number);

	for (int i = 0; i < config.cities_number; ++i) {
		int city = (random_start + i) % config.cities_number;

		if (!context.is_city_selected[city]) {
			return city;
		}
	}

	return null;
}

void generate_random_solution(const Config& config, Context& context) {
	for (int i = 0; i < config.cities_number; ++i) {
		context.solution[i] = null;
		context.is_city_selected[i] = false;
	}

    for (int i = 0; i < config.cities_number; ++i) {
        int current_city = select_random_city(config, context);
        context.solution[i] = current_city;
        context.is_city_selected[current_city] = true;
    }
}
@@@

* include/local_2_opt_search.hpp *:
@@@
#pragma once


bool apply_2_opt_move(const Config& config, Context& context, int i, int j) {
    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }

    int i_next = context.path[i].next;
	int j_next = context.path[j].next;

    ++context.chosen_times[i * config.cities_number + j];
	++context.chosen_times[j * config.cities_number + i];
	++context.chosen_times[i_next * config.cities_number + j_next];
	++context.chosen_times[j_next * config.cities_number + i_next];

    ++context.total_simulations;

    // calculating delta
    bool apply_move = false;
    double weight_increase = 0.0;

    if (config.distance_type == DistanceType::Double) {
        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);
        if (delta > 0.0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, delta / context.path_distance_double) - 1);
            context.path_distance_double -= delta;
        }
    }
    if (config.distance_type == DistanceType::Int32) {
        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);
        if (delta > 0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int32) - 1);
            context.path_distance_int32 -= delta;
        }
    }
    if (config.distance_type == DistanceType::Int64) {
        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);
        if (delta > 0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int64) - 1);
            context.path_distance_int64 -= delta;
        }
    }

    if (apply_move) {
        // applying 2 opt move
        reverse_sub_path(context, i_next, j);

        context.path[i].next = j;
        context.path[i_next].next = j_next;
        context.path[j].prev = i;
        context.path[j_next].prev = i_next;

        // updating weights
        update_weight_undirected(config, context, i, j, weight_increase);
        update_weight_undirected(config, context, i_next, j_next, weight_increase);

        return true;
    }
    return false;
}


bool improve_by_2_opt_move(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
		for (int j = 0; j < config.candidates_number; ++j) {
			int candidate = context.candidates[i * config.candidates_number + j];

			if (apply_2_opt_move(config, context, i, candidate)) { return true; }
		}
	}
    return false;
}

int local_2_opt_search(const Config& config, Context& context) {
    int improved_times = 0;

    while (improve_by_2_opt_move(config, context)) { ++improved_times; };

    return improved_times;
}
@@@

* include/local_k_opt_search.hpp *:
@@@
#pragma once

// standart imports
#include <cmath>
#include <iostream>


void calc_potential_inplace(const Config& config, Context& context, int i, int j) {
    if (i == j) {
        context.potential[i * config.cities_number + j] = 0.0;
        return;
    }

    // calculating total weight
    double average_weight = context.total_weight[i] / (config.cities_number - 1);
    double weight = context.weight[i * config.cities_number + j];

    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value
}

int get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {
    int next_city = context.path[current_city].next;

	double total_potential = 0.0;
    int candidates_available = 0;

	for (int i = 0; i < config.candidates_number; ++i) {
        int candidate = context.candidates[current_city * config.candidates_number + i];

        calc_potential_inplace(config, context, current_city, candidate);
        double potential = context.potential[current_city * config.cities_number + candidate];

        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available

		total_potential += potential;
        ++candidates_available;
	}

    if (candidates_available == 0) { return null; }

    // choosing the random available candidate proportionally
    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;

	for (int i = 0; i < config.candidates_number; ++i) {
        int candidate = context.candidates[current_city * config.candidates_number + i];
        double potential = context.potential[current_city * config.cities_number + candidate];

        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available

        random_potential -= potential;
        if (random_potential <= 0) { return candidate; }
    }

	return null;
}


bool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {
    ++context.total_simulations;

    // first pair
    int next_to_start_city = context.path[start_city].next;

    context.pairs[0] = start_city;
    context.pairs[1] = next_to_start_city;
    int depth = 1;

    int copied_to_saved_pairs = 0;
    bool need_copy_to_saved_pairs = false;

    // breaking an edge of the first pair
    context.path[start_city].next = null;
    context.path[next_to_start_city].prev = null;

    // initializing gains
    double gain_double; double gain_double_with_closure = 0.0;
    int gain_int32; int gain_int32_with_closure = 0;
    long long gain_int64; long long gain_int64_with_closure = 0;

    if (config.distance_type == DistanceType::Double) {
        gain_double = get_distance_double(config, context, start_city, next_to_start_city);
    }
    if (config.distance_type == DistanceType::Int32) {
        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);
    }
    if (config.distance_type == DistanceType::Int64) {
        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);
    }

    bool apply_move = false;

    int current_city = next_to_start_city;

    for (int i = 1; i < max_k_opt_depth; ++i) {
        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);

        if (proposed_city == null) { return false; }  // no candidates, could not improve

        ++context.chosen_times[current_city * config.cities_number + proposed_city];
		++context.chosen_times[proposed_city * config.cities_number + current_city];

        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)

        context.pairs[2 * i] = proposed_city;
        context.pairs[2 * i + 1] = proposed_city_link;
        ++depth;

        // applying 2 opt move
        reverse_sub_path(context, current_city, proposed_city_link);

        context.path[current_city].next = proposed_city;
        context.path[proposed_city].prev = current_city;
        context.path[proposed_city_link].prev = null;

        // recalculating gains
        if (config.distance_type == DistanceType::Double) {
            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);
            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);

            if (gain_double_with_closure > 0.0) {
                apply_move = true;
                context.path_distance_double -= gain_double_with_closure;
            }
            if (context.current_best_delta_double < gain_double_with_closure) {
                need_copy_to_saved_pairs = true;
                context.current_best_delta_double = gain_double_with_closure;
            }
        }
        if (config.distance_type == DistanceType::Int32) {
            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);
            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);

            if (gain_int32_with_closure > 0) {
                apply_move = true;
                context.path_distance_int32 -= gain_int32_with_closure;
            }
            if (context.current_best_delta_int32 < gain_int32_with_closure) {
                need_copy_to_saved_pairs = true;
                context.current_best_delta_int32 = gain_int32_with_closure;
            }
        }
        if (config.distance_type == DistanceType::Int64) {
            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);
            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);

            if (gain_int64_with_closure > 0) {
                apply_move = true;
                context.path_distance_int64 -= gain_int64_with_closure;
            }
            if (context.current_best_delta_int64 < gain_int64_with_closure) {
                need_copy_to_saved_pairs = true;
                context.current_best_delta_int64 = gain_int64_with_closure;
            }
        }

        if (need_copy_to_saved_pairs) {  // for future weight updating
            for (int i = copied_to_saved_pairs; i < depth; ++i) {
                context.saved_pairs[2 * i] = context.pairs[2 * i];
                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];
            }

            copied_to_saved_pairs = depth;
            context.saved_depth = depth;

            need_copy_to_saved_pairs = false;
        }

        if (apply_move) { break; }

        current_city = proposed_city_link;
    }

    if (apply_move) {
        // concluding the path to cycle
        int end_city = context.pairs[2 * depth - 1];

        context.path[start_city].next = end_city;
        context.path[end_city].prev = start_city;

        return true;
    }
    return false;
}


bool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {
    context.current_best_delta_double = -inf_double;
    context.current_best_delta_int32 = -inf_int32;
    context.current_best_delta_int64 = -inf_int64;

    // saving current path length
    double saved_path_distance_double = context.path_distance_double;
    double saved_path_distance_int32 = context.path_distance_int32;
    double saved_path_distance_int64 = context.path_distance_int64;

    bool improved = false;

    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {
        // saving current path
        convert_path_to_solution(config, context);

        int start_city = get_random_int_by_module(config.cities_number);
        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {
            improved = true;
            break;
        }

        // restoring the path that was before the move
        convert_solution_to_path(config, context);
    }

    // updating weights from the best delta (it can be negative, if we've not improved)
    double weight_delta = 0.0;
    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {
        weight_delta = config.weight_delta_coefficient * (pow(e, context.current_best_delta_double / saved_path_distance_double) - 1);
    }
    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {
        weight_delta = config.weight_delta_coefficient * (pow(e, static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32) - 1);
    }
    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {
        weight_delta = config.weight_delta_coefficient * (pow(e, static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64) - 1);
    }

    for (int i = 0; i < context.saved_depth; ++i) {
        int current_city = context.saved_pairs[2 * i];
        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];

        double factor = 1.0;
        if (config.use_sensitivity_decrease && !improved) {
            // exponential decrease in sensitivity
            factor = pow(e, -i / config.sensitivity_temperature);
        }

        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);
    }

    return improved;
}

int local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  
    // calculating total weight (for mitigating precision based errors, that was found empirically)
    for (int i = 0; i < config.cities_number; ++i) {
        double total_weight = 0.0;

        for (int j = 0; j < config.cities_number; ++j) {
            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);
        }

        context.total_weight[i] = total_weight;
    }

    // running simulations and trying to improve
    int improved_times = 0;

    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };

    return improved_times;
}
@@@

* include/additional.hpp *:
@@@
#pragma once


// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.
@@@

* TSP.cpp *:
@@@
// standart imports
#include <string>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>

// json imports
#include "include/json.hpp"

using json = nlohmann::json;
using namespace std::chrono;

// other imports
#include "include/context.hpp"
#include "include/utils.hpp"
#include "include/random_solution.hpp"
#include "include/local_2_opt_search.hpp"
#include "include/local_k_opt_search.hpp"

// additional functions & methods
#include "include/additional.hpp"


// --- config parameters ---
//   `cities_number`: number of points on the 2D surface.
//   `input_path`: path to the file with cities coordinates and the edge heat map.
//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.
//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.
//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.
//   `candidates_number`: number of candidate cities for each city.
//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.
//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).
//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).
//   `exploration_coefficient`: hyperparameter for exploration.
//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.
//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.
//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.
//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.
//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).
//   `distance_type`: "int32", "int64" or "double".
//   `magnify_rate`: when `distance_type` is "int32" or "int64" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)


void read_input_data(const Config& config, Context& context) {
    std::ifstream input_file(config.input_path);

    int cities_number; input_file >> cities_number;

    // reading coordinates
    for (int i = 0; i < config.cities_number; ++i) {
        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];

        if (config.distance_type == DistanceType::Int32) {
            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);
            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);
        }
        if (config.distance_type == DistanceType::Int64) {
            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);
            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);
        }
    }

    // calculating distances
    for (int i = 0; i < config.cities_number; ++i) {
        for (int j = 0; j < config.cities_number; ++j) {
            context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);
            if (config.distance_type == DistanceType::Int32) {
                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);
            }
            if (config.distance_type == DistanceType::Int64) {
                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);
            }
        }
    }

    if (config.use_heat_map_as_initial_weights) {
        // reading heat map
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            input_file >> context.heat_map[i];
            context.weight[i] = context.heat_map[i];
        }
    } else {
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            context.weight[i] = 0.0;
        }
    }

    // initializing total weight
    for (int i = 0; i < config.cities_number; ++i) {
        double total_weight = 0.0;

        for (int j = 0; j < config.cities_number; ++j) {
            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);
        }

        context.total_weight[i] = total_weight;
    }

    // calculating candidates
    if (config.candidates_source == CandidatesSource::KNN) {
        identify_candidates_for_each_node(config, context, context.distance_double, false);
    } else if (config.candidates_source == CandidatesSource::HeatMap) {
        identify_candidates_for_each_node(config, context, context.heat_map, true);
    } else {
        throw std::invalid_argument("Unknown candidates source.");
    }
}


void solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution
    // initialization
    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;
    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;

    int max_k_opt_depth = config.max_k_opt_depth;

	for (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)
        if (i % 100 == 0) { std::cout << "# --------- Iteration: " << i << '\n'; }
        int improved_times = 0;

        // random solution
        start_time = high_resolution_clock::now();
        generate_random_solution(config, context);
        convert_solution_to_path(config, context);
        end_time = high_resolution_clock::now();

        calc_and_save_total_distance(config, context);
        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) { std::cout << std::setprecision(8) << "Phase #1 (random cycle). Total distance: " << context.path_distance_double << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; }

        // local 2opt search
        start_time = high_resolution_clock::now();
		improved_times = local_2_opt_search(config, context);
        end_time = high_resolution_clock::now();

        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) { std::cout << std::setprecision(8) << "Phase #2 (local 2'opt search). Total distance: " << context.path_distance_double << ", Improved times: " << improved_times << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; }

        // local k opt search
        start_time = high_resolution_clock::now();
		improved_times = local_k_opt_search(config, context, max_k_opt_depth);
        end_time = high_resolution_clock::now();

        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) { std::cout << std::setprecision(8) << "Phase #3 (local k'opt search). Total distance: " << context.path_distance_double << ", Improved times: " << improved_times << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n"; }

        // changing the best path
        if (
            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||
            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||
            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)
        ) {
            store_path_as_best(config, context);  // also updates best path distance
        }

        if (config.random_k_opt_depth_after_first_iteration) {
            // random MCTS depth change
            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);
        }

        if (i % 100 == 0) { std::cout << '\n'; }
	}

    // final convertation (context.best_path to context.solution)
    restore_best_path(config, context);
    convert_path_to_solution(config, context);

    end_total_time = high_resolution_clock::now();
    std::cout << "Total elapsed time: " << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << " sec\n\n";
}


int main(int argc, char** argv) {
    // reading configuration
    std::cout << "Reading configuration...\n";
    if (argc != 2) {
        std::cerr << "Usage: The first and only argument should be the path to the config file.";
        return 1;
    }
    
    std::ifstream config_file(argv[1]);
    json config_raw; config_file >> config_raw;
    Config config(config_raw);

    std::cout << "Number of cities: " << config.cities_number << "\n\n";

    // initialization & memory allocation
    Context context(config);

    // reading input data
    std::cout << "Reading input data...\n";
    read_input_data(config, context);

    // solving
    std::cout << "Solving...\n";
    solve(config, context);

    // printing the solution
    std::ofstream output_file(config.output_path);

    std::cout << "Final solution:\n";
    for (int i = 0; i < config.cities_number; ++i) {
        std::cout << context.solution[i] << ' ';
        output_file << context.solution[i] << ' ';
    }
    std::cout << "\n\nFinal solution score: " << calc_total_distance_double(config, context) << '\n';

    return 0;
}
@@@

* config.json *:
@@@
{
    "cities_number": 1000,
    "input_path": "/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt",
    "output_path": "/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt",
    "use_heat_map_as_initial_weights": false,
    "candidates_source": "knn",
    "candidates_number": 10,
    "max_k_opt_depth": 89,
    "random_k_opt_depth_after_first_iteration": true,
    "min_potential_to_consider": 1.0,
    "exploration_coefficient": 0.0,
    "weight_delta_coefficient": 10.0,
    "use_sensitivity_decrease": false,
    "sensitivity_temperature": 1.0,
    "max_k_opt_simulations_without_improve_to_stop": 100,
    "restarts_number": 200,
    "distance_type": "int64",
    "magnify_rate": 1000000
}
@@@

* changes_description.txt *:
@@@
Default workflow from the paper "UTSP" implementing 2'opt and k'opt searches.
No further changes.
@@@