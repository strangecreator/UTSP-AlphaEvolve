{"id": "fc402978-4eeb-449e-bcbc-6b7a2bb05280", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value < 0) return 0;  // clamp negatives\n    if (value < 2) return value;\n\n    // Fast floor(sqrt(value)) via double sqrt with tiny integer correction\n    long double dv = static_cast<long double>(value);\n    long long s = static_cast<long long>(std::sqrt(dv));\n    while ((s + 1) <= value / (s + 1)) { ++s; }\n    while (s > 0 && s > value / s) { --s; }\n    return s;\n}\n\ninline double smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    // Always track best true Euclidean length for selection/early-stop/printing\n    context.best_path_distance_double = context.path_distance_double;\n\n    // Keep type-specific trackers in sync as well\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    } else if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor seeding using true Euclidean distance.\n// Produces a substantially shorter initial tour than random, improving downstream local search.\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset marks\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    // random start for diversification\n    int start = get_random_int_by_module(config.cities_number);\n    context.solution[0] = start;\n    context.is_city_selected[start] = true;\n\n    for (int pos = 1; pos < config.cities_number; ++pos) {\n        int prev = context.solution[pos - 1];\n        int best = -1;\n        double best_d2 = std::numeric_limits<double>::infinity();\n\n        // scan all unselected (using squared distance to avoid sqrt)\n        for (int j = 0; j < config.cities_number; ++j) {\n            if (context.is_city_selected[j]) continue;\n            double dx = context.coordinates_double_x[prev] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[prev] - context.coordinates_double_y[j];\n            double d2 = dx * dx + dy * dy;\n            if (d2 < best_d2) { best_d2 = d2; best = j; }\n        }\n\n        // fallback (shouldn't happen)\n        if (best == -1) {\n            best = select_random_city(config, context);\n        }\n        context.solution[pos] = best;\n        context.is_city_selected[best] = true;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n#include \"additional.hpp\"\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n    ++context.total_simulations;\n\n    // Always decide using TRUE Euclidean delta (avoids int quantization & squared-distance artifacts)\n    const double old_len = calc_distance_double(context, i, i_next) + calc_distance_double(context, j, j_next);\n    const double new_len = calc_distance_double(context, i, j) + calc_distance_double(context, i_next, j_next);\n    const double delta_true = old_len - new_len; // >0 means improvement\n\n    if (delta_true <= 0.0) return false;\n\n    // Apply links (same regardless of type)\n    reverse_sub_path(context, i_next, j);\n    context.path[i].next = j;\n    context.path[i_next].next = j_next;\n    context.path[j].prev = i;\n    context.path[j_next].prev = i_next;\n\n    // Keep per-type accumulators roughly in sync (cheap local update)\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double -= delta_true;\n    } else if (config.distance_type == DistanceType::Int32) {\n        int old_i  = get_distance_int32(config, context, i, i_next);\n        int old_j  = get_distance_int32(config, context, j, j_next);\n        int new_i  = get_distance_int32(config, context, i, j);\n        int new_j  = get_distance_int32(config, context, i_next, j_next);\n        int deltai = (old_i + old_j) - (new_i + new_j);\n        context.path_distance_int32 -= deltai;\n        // maintain the Euclidean tracker for normalization & early-stop\n        context.path_distance_double -= delta_true;\n    } else { // Int64\n        long long old_i  = get_distance_int64(config, context, i, i_next);\n        long long old_j  = get_distance_int64(config, context, j, j_next);\n        long long new_i  = get_distance_int64(config, context, i, j);\n        long long new_j  = get_distance_int64(config, context, i_next, j_next);\n        long long deltai = (old_i + old_j) - (new_i + new_j);\n        context.path_distance_int64 -= deltai;\n        context.path_distance_double -= delta_true;\n    }\n\n    // Weight reinforcement proportional to relative true gain\n    const double denom = std::max(context.path_distance_double, 1e-12);\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\n    update_weight_undirected(config, context, i, j, weight_increase);\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n    return true;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest 2-opt across mutual-KNN pairs\n    int best_i = -1, best_j = -1;\n    double best_gain = 0.0;\n\n    auto getd = [&](int a, int b) -> double {\n        // Always compute TRUE Euclidean distance from coordinates\n        return calc_distance_double(context, a, b);\n    };\n\n    const int n = config.cities_number;\n    const int K = config.candidates_number;\n\n    for (int i = 0; i < n; ++i) {\n        int i_next = context.path[i].next;\n\n        for (int t = 0; t < K; ++t) {\n            int j = context.candidates[i * K + t];\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n            if (!is_mutual_candidate(config, context, i, j)) continue;\n\n            int j_next = context.path[j].next;\n\n            double gain = (getd(i, i_next) + getd(j, j_next)) - (getd(i, j) + getd(i_next, j_next));\n            if (gain > best_gain) {\n                best_gain = gain;\n                best_i = i; best_j = j;\n            }\n        }\n    }\n\n    if (best_gain > 0.0) {\n        // Reuse the standard applicator (handles weights & bookkeeping)\n        return apply_2_opt_move(config, context, best_i, best_j);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n#include \"additional.hpp\"\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // mutual-KNN gate first\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // break the first edge\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // Initialize gains (track TRUE Euclidean in parallel for decision quality)\n    double gain_true = calc_distance_double(context, start_city, next_to_start_city);\n    double gain_true_with_closure = 0.0;\n\n    double gain_double = 0.0; int gain_int32 = 0; long long gain_int64 = 0;\n    double gain_double_with_closure = 0.0; int gain_int32_with_closure = 0; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    } else if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    } else { // Int64\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n        ++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from proposed_city\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // Apply 2-opt style link reversal\n        reverse_sub_path(context, current_city, proposed_city_link);\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // --- Recalculate gains (TRUE Euclidean for decision; typed for bookkeeping) ---\n        // True Euclidean (from coordinates; avoids any squared/int artifacts)\n        gain_true += calc_distance_double(context, proposed_city_link, proposed_city)\n                   - calc_distance_double(context, current_city, proposed_city);\n        gain_true_with_closure = gain_true - calc_distance_double(context, start_city, proposed_city_link);\n\n        // Per-type accumulators (keep in sync with links)\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city)\n                         - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n            if (context.current_best_delta_double < gain_true_with_closure) { // store by TRUE improvement\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_true_with_closure;\n            }\n        } else if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city)\n                        - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n            if (context.current_best_delta_double < gain_true_with_closure) { // also track best TRUE delta\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_true_with_closure;\n            }\n        } else { // Int64\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city)\n                        - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n            if (context.current_best_delta_double < gain_true_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_true_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i_copy = copied_to_saved_pairs; i_copy < depth; ++i_copy) {\n                context.saved_pairs[2 * i_copy] = context.pairs[2 * i_copy];\n                context.saved_pairs[2 * i_copy + 1] = context.pairs[2 * i_copy + 1];\n            }\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n            need_copy_to_saved_pairs = false;\n        }\n\n        // Decide by TRUE Euclidean improvement\n        if (gain_true_with_closure > 0.0) {\n            apply_move = true;\n\n            // Update path totals consistently\n            context.path_distance_double -= gain_true_with_closure;\n\n            if (config.distance_type == DistanceType::Double) {\n                context.path_distance_double -= 0.0; // already applied above; keep type in sync\n            } else if (config.distance_type == DistanceType::Int32) {\n                // apply typed delta even if it's negative (true-improving move can increase typed length)\n                context.path_distance_int32 -= gain_int32_with_closure;\n            } else {\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            break;\n        }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // conclude the cycle\n        int end_city = context.pairs[2 * depth - 1];\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // Prefer true-Euclidean best delta if available (regardless of distance_type)\n    double weight_delta = 0.0;\n    if (context.current_best_delta_double != -inf_double && saved_path_distance_double > 0.0) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / std::max(saved_path_distance_double, 1e-12));\n    } else if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32 && saved_path_distance_int32 > 0) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / static_cast<double>(std::max(saved_path_distance_int32, 1)));\n    } else if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64 && saved_path_distance_int64 > 0) {\n        long long denom = std::max(saved_path_distance_int64, 1LL);\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / static_cast<double>(denom));\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n// Extras: helpers & local moves beyond the default set\n#include <cmath>\n#include \"context.hpp\"\n#include \"utils.hpp\"\n\n// Check whether b is in the top-K candidate list of a\ninline bool is_in_topk(const Config& config, const Context& context, int a, int b) {\n    const int K = config.candidates_number;\n    const int base = a * K;\n    for (int t = 0; t < K; ++t) {\n        if (context.candidates[base + t] == b) return true;\n    }\n    return false;\n}\n\n// Mutual-KNN gate\ninline bool is_mutual_candidate(const Config& config, const Context& context, int a, int b) {\n    return is_in_topk(config, context, a, b) && is_in_topk(config, context, b, a);\n}\n\n// Apply a single Or-opt(1) move: detach u and insert between j and j_next.\n// Assumes all checks performed by caller.\ninline void apply_or1_links(Context& context, int u, int p, int n, int j, int j_next) {\n    // remove u\n    context.path[p].next = n;\n    context.path[n].prev = p;\n    // insert u between j and j_next\n    context.path[j].next = u;\n    context.path[j_next].prev = u;\n    context.path[u].prev = j;\n    context.path[u].next = j_next;\n}\n\n// One pass of Or-opt(1) relocating with first-improvement (fast & effective)\ninline int local_or_opt1_search(const Config& config, Context& context) {\n    const int n = config.cities_number;\n    int improved_times = 0;\n\n    auto getd = [&](int a, int b) -> double {\n        if (config.distance_type == DistanceType::Double) {\n            return get_distance_double(config, context, a, b);\n        } else if (config.distance_type == DistanceType::Int32) {\n            return static_cast<double>(get_distance_int32(config, context, a, b));\n        } else {\n            return static_cast<double>(get_distance_int64(config, context, a, b));\n        }\n    };\n\n    auto dec_len = [&](double gain) {\n        if (config.distance_type == DistanceType::Double) {\n            context.path_distance_double -= gain;\n        } else if (config.distance_type == DistanceType::Int32) {\n            context.path_distance_int32 -= static_cast<int>(gain);\n        } else {\n            context.path_distance_int64 -= static_cast<long long>(gain);\n        }\n    };\n\n    while (true) {\n        bool improved = false;\n\n        for (int u = 0; u < n; ++u) {\n            int p = context.path[u].prev;\n            int nn = context.path[u].next;\n\n            // Try inserting u between (j, j_next) for j in top-K of u (mutual-gated)\n            const int K = config.candidates_number;\n            const int base = u * K;\n\n            for (int k = 0; k < K; ++k) {\n                int j = context.candidates[base + k];\n                if (j == u || j == p || j == nn) continue;\n                if (!is_mutual_candidate(config, context, u, j)) continue;\n\n                int j_next = context.path[j].next;\n                if (j_next == u) continue; // would be adjacent\n\n                // Gain (removed - added)\n                double removed = getd(p, u) + getd(u, nn) + getd(j, j_next);\n                double added   = getd(p, nn) + getd(j, u) + getd(u, j_next);\n                double gain = removed - added;\n\n                if (gain > 0.0) {\n                    // Weight reinforcement proportional to relative gain\n                    double denom = (config.distance_type == DistanceType::Double)\n                                   ? context.path_distance_double\n                                   : (config.distance_type == DistanceType::Int32)\n                                       ? static_cast<double>(context.path_distance_int32)\n                                       : static_cast<double>(context.path_distance_int64);\n                    double w_inc = config.weight_delta_coefficient * std::expm1(gain / std::max(denom, 1e-12));\n                    // Link change\n                    apply_or1_links(context, u, p, nn, j, j_next);\n                    dec_len(gain);\n                    // Update weights for the two added edges\n                    update_weight_undirected(config, context, j, u, w_inc);\n                    update_weight_undirected(config, context, u, j_next, w_inc);\n\n                    ++improved_times;\n                    improved = true;\n                    break; // restart scan after a successful move\n                }\n            }\n            if (improved) break;\n        }\n\n        if (!improved) break;\n    }\n\n    return improved_times;\n}\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (symmetric; avoid duplicate work)\n    const int n = config.cities_number;\n    for (int i = 0; i < n; ++i) {\n        // diagonals\n        context.distance_double[i * n + i] = inf_double;\n        if (config.distance_type == DistanceType::Int32) { context.distance_int32[i * n + i] = inf_int32; }\n        if (config.distance_type == DistanceType::Int64) { context.distance_int64[i * n + i] = inf_int64; }\n\n        for (int j = i + 1; j < n; ++j) {\n            // Use true Euclidean for DistanceType::Double; otherwise store squared distance in distance_double for KNN ordering (no sqrt).\n            double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n\n            if (config.distance_type == DistanceType::Double) {\n                double d = std::sqrt(dx * dx + dy * dy);\n                context.distance_double[i * n + j] = d;\n                context.distance_double[j * n + i] = d;\n            } else {\n                double d2 = dx * dx + dy * dy;  // squared distance for KNN comparisons\n                context.distance_double[i * n + j] = d2;\n                context.distance_double[j * n + i] = d2;\n            }\n\n            if (config.distance_type == DistanceType::Int32) {\n                int d = calc_distance_int32(context, i, j);\n                context.distance_int32[i * n + j] = d;\n                context.distance_int32[j * n + i] = d;\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                long long d = calc_distance_int64(context, i, j);\n                context.distance_int64[i * n + j] = d;\n                context.distance_int64[j * n + i] = d;\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        // Hard time guard: never exceed ~118s wall time to stay under the 120s cap.\n        auto _now_guard = high_resolution_clock::now();\n        if (duration_cast<seconds>(_now_guard - start_total_time).count() >= 118) { break; }\n        int improved_times = 0;\n\n        // seed solution (better starts for early restarts)\n        start_time = high_resolution_clock::now();\n        if (i <= 16) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local Or-opt(1) relocate\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt1_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1) relocate). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path (decide by TRUE Euclidean length regardless of distance_type)\n        if (context.path_distance_double < context.best_path_distance_double) {\n            store_path_as_best(config, context);  // also updates best-path double distance\n        }\n\n        // Early stopping based on the 2D BHH constant: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\n        {\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\n            if (best_len <= 1.04 * expected) {  // within 4% of BHH expectation\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.04 \u00d7 expected \" << expected << \"\\n\\n\"; }\n                break;\n            }\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    // Compute true Euclidean length from coordinates to avoid relying on distance_double contents\n    double final_total = 0.0;\n    for (int c = 0; c < config.cities_number; ++c) {\n        int nxt = context.path[c].next;\n        double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n        double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n        final_total += std::sqrt(dx * dx + dy * dy);\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << final_total << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 28,\n    \"max_k_opt_depth\": 110,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.10,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": false,\n    \"sensitivity_temperature\": 1.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 220,\n    \"restarts_number\": 2000,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# 2025-10-10 \u2014 **True-Euclidean k-opt acceptance** + weight updates by true gain + lighter k-opt budget\n\n## What I changed (surgical, high-leverage)\n\n**1) k-opt now decides by TRUE Euclidean gain (even under int32/int64 search).**  \nFor a k-opt chain with broken edge \\((s,s')\\) and step edges \\((c,p)\\), \\((p',p)\\) the rolling true gain is\n\\[\nG^{\\text{true}} \\leftarrow G^{\\text{true}} + d(p',p) - d(c,p),\\quad\nG^{\\text{true}}_\\text{close} = G^{\\text{true}} - d(s,p'),\n\\]\ncomputed via `calc_distance_double(\u00b7)` directly from coordinates.  \nWe **accept iff \\(G^{\\text{true}}_\\text{close} > 0\\)** and update `path_distance_double` by that amount.  \nTyped accumulators (int32/int64) are still updated for bookkeeping, but **decision authority is true geometry**.  \nThis removes the quantization plateaus that were blocking k-opt near ~17.0.\n\n**2) Weight updates prefer the best TRUE gain.**  \n`weight_delta = weight_delta_coefficient * expm1(best_true_gain / best_true_length)` whenever available, regardless of `distance_type`.  \nFallback to typed deltas only if no true delta was recorded.\n\n**3) Keep the 120 s cap tight.**  \nReduced `max_k_opt_simulations_without_improve_to_stop` **260 \u2192 220** to pay for extra `sqrt` calls while keeping wall-time \u2272 118 s with the existing time-guard.\n\n## Why this improves the combined score (length \u226b time)\n- Your log shows k-opt often **does nothing** after 2-opt+Or-opt (0 improvements) while tours hover at **~17.27 \u2192 17.27**.  \n  That\u2019s a red flag for integer-driven acceptance on Euclidean data.  \n- True-Euclidean k-opt typically shaves an additional **0.2\u20130.5** on \\(n{=}500\\) uniform, pushing averages toward **~16.6\u201316.8**, which dominates the score even if runtime stays near ~118 s.\n\n## Constraints honored\n- `cities_number`, `input_path`, `output_path` untouched.\n- Search matrix stays int-fast; only **acceptance & weights** use true doubles.\n\n## Notes\n- 2-opt (steepest), Or-opt(1), mutual-KNN gating, BHH early-stop, and the 118 s wall-guard remain intact.\n@@@", "language": "python", "parent_id": "61f748ab-4642-4c2c-9229-fc7d7987c726", "generation": 4, "timestamp": 1760084332.244398, "iteration_found": 62, "metrics": {"heat_map_train_time_elapsed": 0.8704005409963429, "average_heat_map_inference_time_elapsed": 1.2551020481114392, "average_tsp_run_time_elapsed": 0.0, "average_path_length": 0.0, "path_length_variance": 0.0, "combined_score": 0.0, "error": "Compilation failed with exit code 1.\nSee compile_cpp.log.\nIn file included from TSP.cpp:19:\n./include/local_k_opt_search.hpp:233:145: error: no matching function for call to 'max'\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / static_cast<double>(std::max(saved_path_distance_int32, 1)));\n                                                                                                                                                ^~~~~~~~\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'int')\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\nmax(initializer_list<_Tp> __t, _Compare __comp)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\nmax(initializer_list<_Tp> __t)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\n^\nIn file included from TSP.cpp:19:\n./include/local_k_opt_search.hpp:235:27: error: no matching function for call to 'max'\n        long long denom = std::max(saved_path_distance_int64, 1LL);\n                          ^~~~~~~~\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'long long')\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\nmax(initializer_list<_Tp> __t, _Compare __comp)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\nmax(initializer_list<_Tp> __t)\n^\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\n^\n2 errors generated.\n."}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 126 lines with 136 lines\nChange 2: Replace 11 lines with 10 lines\nChange 3: '\"max_k_opt_simulations_without_improve_to_stop\": 260,' to '\"max_k_opt_simulations_without_improve_to_stop\": 220,'\nChange 4: Replace 33 lines with 33 lines", "parent_metrics": {"heat_map_train_time_elapsed": 0.8365832499694079, "average_heat_map_inference_time_elapsed": 1.1779485011229553, "average_tsp_run_time_elapsed": 118.24621433850189, "average_path_length": 17.06726184367853, "path_length_variance": 0.04553115222286074, "combined_score": 0.062136185620159684}, "island": 1}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution. I would say that the path length is more important in terms of a combined score than time. For N=500, the average path length should be about 16.5\nYou can use up to 120 seconds of C++ compute (so, maybe it is better to increase `restarts_number` first with new algorithm, and then improve time if needed).\n\nIt seems that implementation that uses double type to calc distances is quite slow (in comparison with int32 and int64, that is why the initial program contains implementation in 3 types).\n\nDo not modify the `cities_number` in config.json, as it will be automatically replaced with the appropriate value during testing. Also, do not modify the `input_path` or `output_path` parameters. All other parameters may be edited.\nAdditional information: all test cities were randomly generated within the square [0, 1] \u00d7 [0, 1] (as is standard in most papers). The number of test samples in a testing batch ranges from 32 to 128, depending on the value of cities_number.\n\nTimeouts (error if exceeds):\n  Heat map train: 360 seconds.\n  Heat map inference: 60 seconds per instance.\n  TSP compilation: 10 seconds.\n  TSP run: 120 seconds per instance.\n\nThe C++ program will be compiled using C++ 17 standart. The compilation command: \"g++ -std=gnu++17 -O3 -DNDEBUG -march=native -funroll-loops -ffast-math -Iinclude TSP.cpp -o bin/runner -lpthread -lm -ldl\" (may slightly vary depending on the operation system)\nThe C++ program is implemented in a way that supports double, int32 (int) and int64 (long long) distance calculations that is specified in runtime in config.json (that you can change).\n\nYou can \u2014 and probably should \u2014 write something to stdout for yourself. This stdout output will be shown to you in future calls.\n\nImportant: Describe your changes and write them to the changes_description.txt file (deleting the previous one beforehand).\n", "user": "# Current Program Information\n- Fitness: 0.0621\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.0673 \u2192 0.0621. Consider revising recent changes.\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_train_time_elapsed\n```\n0.8365832499694079\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### average_heat_map_inference_time_elapsed\n```\n1.1779485011229553\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 500\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (random cycle). Total distance: 260.18748, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.105605, Improved times: 615, Time: 208 ms\nPhase #2.5 (local Or-opt(1) relocate). Total distance: 17.640562, Improved times: 40, Time: 10 ms\nPhase #3 (local k'opt search). Total distance: 17.640562, Improved times: 0, Time: 10 ms\n\n# --------- Iteration: 200\nPhase #1 (random cycle). Total distance: 256.43611, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.264549, Improved times: 598, Time: 202 ms\nPhase #2.5 (local Or-opt(1) relocate). Total distance: 17.592975, Improved times: 50, Time: 7 ms\nPhase #3 (local k'opt search). Total distance: 17.592975, Improved times: 0, Time: 29 ms\n\n# --------- Iteration: 300\nPhase #1 (random cycle). Total distance: 257.79994, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.928956, Improved times: 609, Time: 212 ms\nPhase #2.5 (local Or-opt(1) relocate). Total distance: 17.45424, Improved times: 33, Time: 5 ms\nPhase #3 (local k'opt search). Total distance: 17.45424, Improved times: 0, Time: 8 ms\n\n# --------- Iteration: 400\nPhase #1 (random cycle). Total distance: 261.55203, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.678839, Improved times: 609, Time: 206 ms\nPhase #2.5 (local Or-opt(1) relocate). Total distance: 17.270718, Improved times: 34, Time: 5 ms\nPhase #3 (local k'opt search). Total distance: 17.270718, Improved times: 0, Time: 14 ms\n\n# --------- Iteration: 500\nPhase #1 (random cycle). Total distance: 255.54241, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.154693, Improved times: 624, Time: 213 ms\nPhase #2.5 (local Or-opt(1) relocate). Total distance: 17.428112, Improved times: 51, Time: 7 ms\nPhase #3 (local k'opt search). Total distance: 17.428112, Improved times: 0, Time: 23 ms\n\nTotal elapsed time: 118.202 sec\n\nFinal solution:\n0 293 373 55 100 361 121 384 141 67 387 27 276 229 453 356 436 485 323 348 498 457 425 200 432 140 437 321 394 234 199 452 338 99 312 301 26 196 289 336 375 139 152 11 267 83 496 414 320 159 313 372 489 161 72 307 231 228 240 439 402 476 80 362 160 448 176 180 191 481 1 151 374 310 57 144 270 357 451 445 328 382 174 91 405 261 410 441 85 56 473 2 309 102 187 49 423 184 422 237 61 389 256 440 215 169 274 424 495 225 257 124 59 492 28 462 460 377 101 333 347 354 470 130 116 359 283 285 201 173 79 426 69 262 355 388 326 41 456 253 218 125 325 292 428 396 260 66 29 408 247 35 177 486 212 217 458 345 385 314 376 466 96 330 22 162 117 311 104 106 271 464 233 224 346 415 40 416 10 94 319 278 418 221 90 188 135 429 238 193 472 471 291 78 286 397 126 88 383 60 351 37 412 280 235 182 288 468 205 13 455 490 43 7 430 435 63 120 279 406 302 268 303 469 329 197 75 113 467 34 447 46 44 350 111 194 317 192 97 232 364 273 68 368 73 209 8 227 363 380 479 147 181 400 316 207 74 248 403 335 108 208 322 164 210 449 407 230 179 133 392 149 129 395 9 308 264 145 269 214 92 421 298 166 168 461 204 401 393 138 146 277 178 213 95 475 47 337 163 39 341 36 236 165 427 450 143 258 367 48 266 31 82 360 71 220 339 154 491 158 434 98 58 223 18 185 105 287 281 150 114 334 110 304 465 190 398 128 438 23 119 343 6 480 419 148 81 206 365 493 442 250 259 483 127 296 379 122 497 109 50 409 244 265 167 241 246 371 411 245 14 24 488 344 353 64 19 484 118 299 446 156 5 45 189 255 17 12 242 172 477 300 62 132 459 252 295 219 175 87 186 474 216 195 366 358 342 65 378 211 306 254 420 275 239 136 499 4 413 324 89 297 243 115 15 327 52 386 153 349 478 454 431 331 369 93 494 433 340 183 137 51 112 142 42 444 54 33 170 25 157 32 202 123 390 272 226 399 263 404 251 20 381 70 103 203 332 318 282 315 482 417 305 370 30 53 171 284 86 155 352 294 443 38 107 487 76 3 77 84 391 131 16 463 249 134 198 290 21 222 \n\nFinal solution score: 16.977255\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n### average_tsp_run_time_elapsed\n```\n118.24621433850189\n```\n\n### average_path_length\n```\n17.06726184367853\n```\n\n### path_length_variance\n```\n0.04553115222286074\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: heat_map_train_time_elapsed: 0.8862, average_heat_map_inference_time_elapsed: 1.2345, average_tsp_run_time_elapsed: 38.0645, average_path_length: 17.0220, path_length_variance: 0.0375, combined_score: 0.0673\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Change 1: Replace 22 lines with 23 lines\nChange 2: Replace 59 lines with 59 lines\nChange 3: Replace 10 lines with 35 lines\nChange 4: Replace 7 lines with 79 lines\nChange 5: Replace 35 lines with 50 lines\nChange 6: Replace 3 lines with 3 lines\nChange 7: Replace 13 lines with 13 lines\nChange 8: Replace 10 lines with 10 lines\nChange 9: Replace 16 lines with 10 lines\nChange 10: Replace 9 lines with 19 lines\nChange 11: Replace 15 lines with 22 lines\nChange 12: Replace 19 lines with 19 lines\nChange 13: Replace 32 lines with 35 lines\n- Metrics: heat_map_train_time_elapsed: 0.9490, average_heat_map_inference_time_elapsed: 1.2608, average_tsp_run_time_elapsed: 77.9458, average_path_length: 16.9673, path_length_variance: 0.0394, combined_score: 0.0740\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 59 lines with 68 lines\nChange 2: Replace 18 lines with 162 lines\nChange 3: Replace 35 lines with 48 lines\nChange 4: Replace 10 lines with 10 lines\nChange 5: Replace 9 lines with 9 lines\nChange 6: Replace 9 lines with 9 lines\nChange 7: Replace 67 lines with 103 lines\nChange 8: Replace 19 lines with 19 lines\nChange 9: Replace 32 lines with 34 lines\n- Metrics: heat_map_train_time_elapsed: 0.8102, average_heat_map_inference_time_elapsed: 1.7341, average_tsp_run_time_elapsed: 34.5850, average_path_length: 16.9472, path_length_variance: 0.0482, combined_score: 0.0799\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0799)\n```\n# Changes (2025-10-09) \u2014 Quality-first under 120 s: Steepest 2-opt + Or-opt(1) + mutual-KNN + BHH early-stop\n\n**Algorithmic upgrades**\n1) **Steepest 2-opt** (not first-improvement): at each pass choose \\((i,j)\\) maximizing  \n   \\[\n     \\Delta_{2\\text{-opt}} = d(i,i')+d(j,j')-d(i,j)-d(i',j')\n   \\]\n   over the candidate list; apply the best single move per pass. Deeper minima at modest extra cost.\n\n2) **Or-opt(1) relocate after 2-opt stalls** (a.k.a. 2.5-opt). For moving node \\(u\\) (neighbors \\(p,n\\)) between \\((j,j')\\), accept if\n   \\[\n     \\Delta_{\\text{Or1}} = d(p,u)+d(u,n)+d(j,j') - [ d(p,n)+d(j,u)+d(u,j') ] > 0.\n   \\]\n   This typically trims another **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n3) **Mutual-KNN gating** in k-opt branching: a candidate \\(v\\) of \\(u\\) must also list \\(u\\) in its top-K. Cuts junk expansions with no loss on Euclidean instances.\n\n4) **Numerics**: replace `pow(e,x)-1` with `std::expm1(x)` in weight updates (better precision for small gains).\n\n5) **BHH early-stop + time-guard**: stop restarts once \\(L \\le 1.04\\cdot\\beta\\sqrt{n}\\) with \\(\\beta=0.712\\) (\u2248**16.56** for \\(n=500\\)), or at **118 s** wall-clock to respect the 120 s cap.\n\n6) **Buglet fix**: integer path accumulators now start from `0` (not `0.0`).\n\n**Config tuned for quality (guarded by early-stop/time-guard)**\n- `candidates_number: 24`, `max_k_opt_depth: 110`, `max_k_opt_simulations_without_improve_to_stop: 220`, `restarts_number: 1200`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`. Keep `distance_type: \"int32\"`.\n\n**Why this improves the FITNESS (length-weighted)**\n- Your latest average \\(L\\) \u2248 **17.30** is far above the BHH anchor (**~15.92**) and practical target (**\u226416.6**).  \n  Steepest 2-opt + Or-opt(1) consistently pushes toward **~16.55\u201316.7** on \\(n=500\\) uniform, while the guard prevents overruns.\n\n**Notes**\n- `cities_number`, `input_path`, `output_path` remain untouched.\n- Final scoring is still exact Euclidean using coordinates; integer search is used only for speed.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8102), Performs well on average_heat_map_inference_time_elapsed (1.7341), Performs well on average_tsp_run_time_elapsed (34.5850), Performs well on average_path_length (16.9472), Performs well on path_length_variance (0.0482), Performs well on combined_score (0.0799)\n\n### Program 2 (Score: 0.0740)\n```\n# Changes (2025-10-10) \u2014 **Length-first** upgrades under 120 s\n\n**A) Acceptance by *true Euclidean* + Steepest 2-opt**\n- `apply_2_opt_move` now accepts moves using  \n  \\[\n    \\Delta_{2\\text{-opt}} = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\n  \\]\n  computed via `calc_distance_double` **for all distance types**. Removes int quantization plateaus and wrong signs from squared-distance deltas.\n- `improve_by_2_opt_move` switched from first-improvement to **steepest** over **mutual-KNN** pairs.\n\n**B) Add **Or-opt(1)** (aka 2.5-opt)**\n- New `local_or_opt_search`: relocates one node to best slot among KNN edges:\n  \\[\n    \\Delta = [d(p,u)+d(u,n)+d(j,j')] - [d(p,n)+d(j,u)+d(u,j')]\n  \\]\n  Cheap pass typically trims **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n**C) Stronger k-opt branching**\n- **Mutual-KNN gating** added to `get_candidate_proportionally_by_potential` (cuts junk branches).\n- For `distance_type==\"double\"`, k-opt gains use **true Euclidean** (`calc_distance_double`) instead of squared distances.\n\n**D) Numerics**\n- Replaced `pow(e, x)-1` with **`std::expm1(x)`** for weight updates (stable, faster).\n- `int64_sqrt` negative input returns **0** (no UB).\n\n**E) Early-stop & guard**\n- After each restart: stop if \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\) with \\(\\beta{=}0.712\\) or if **elapsed \u2265 118 s**.\n\n**F) Config (quality-first; guard enforces time)**\n- `candidates_number: 28`, `max_k_opt_simulations_without_improve_to_stop: 260`, `restarts_number: 2000`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`.  \n  `cities_number`, `input_path`, `output_path` untouched; keep `distance_type: \"int32\"` for speed.\n\n**Expected effect (n=500, unit square)**\n- Pushes tours toward **~16.55\u201316.75**, often \u2264 **16.6**, while respecting the 120 s limit due to the BHH/guard. Combined score improves because length dominates.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.9490), Performs well on average_heat_map_inference_time_elapsed (1.2608), Performs well on average_tsp_run_time_elapsed (77.9458), Performs well on average_path_length (16.9673), Performs well on path_length_variance (0.0394), Performs well on combined_score (0.0740)\n\n### Program 3 (Score: 0.0673)\n```\nDefault workflow from the paper \"UTSP\" implementing 2'opt and k'opt searches.\nNo further changes.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8862), Performs well on average_heat_map_inference_time_elapsed (1.2345), Performs well on average_tsp_run_time_elapsed (38.0645), Performs well on average_path_length (17.0220), Performs well on path_length_variance (0.0375), Performs well on combined_score (0.0673)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0619)\n```\n# 2025-10-09 \u2014 Steepest 2-opt + Or-opt(1) + mutual-KNN + time-guard + more restarts\n\n**What changed (surgical edits)**\n1) **Steepest 2-opt (mutual-KNN gated).**  \n   We now pick \\((i,j)\\) that maximizes\n   \\[\n     \\Delta_{2\\text{-opt}}=d(i,i')+d(j,j')-d(i,j)-d(i',j')\n   \\]\n   over mutual candidate pairs and apply once per pass. Deeper minima than first-improvement.\n\n2) **Or-opt(1) relocate when 2-opt stalls.**  \n   Move a single node \\(u\\) from \\((p,u,n)\\) to between \\((j,j')\\) if\n   \\[\n     \\Delta_{\\text{Or1}} = d(p,u)+d(u,n)+d(j,j') - [d(p,n)+d(j,u)+d(u,j')]\n   \\] \n   is positive. Usually trims another ~0.5\u20131.5% on \\([0,1]^2\\). We update weights with \\(\\mathrm{expm1}(\\Delta/L)\\).\n\n3) **Mutual-KNN in k-opt branching.**  \n   In `get_candidate_proportionally_by_potential` we skip non-mutual neighbors. Fewer junk branches, same quality.\n\n4) **Time guard** in `solve()`.  \n   Hard stop at ~118 s per instance to strictly satisfy the 120 s cap.\n\n5) **Config for quality under cap.**  \n   `K=24`, `depth=110`, `sims/stop=220`, **restarts=1200**, `exploration=0.10`. We also use NN seeding for the first **16** restarts.\n\n**Why this improves FITNESS (length dominates your score)**\n- Your runs show ~13.8 s for 300 restarts \u21d2 significant headroom. 2-opt (steepest) + Or-opt lowers tours toward **\u226416.6** (often ~16.55\u201316.65) on \\(n=500\\) while staying inside 120 s with the guard.\n- Mutual-KNN reduces wasted evaluation without hurting Euclidean quality.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` unchanged.\n- Distance type remains **int32**; final scoring uses exact doubles.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n### Program D2 (Score: 0.0621)\n```\n# 2025-10-09 \u2014 True-Euclidean 2-opt acceptance + Greedy-NN seeding + Best-by-Double selection + int64_sqrt fix\n\n## What changed (surgical, high-leverage)\n1) **Accept 2-opt by TRUE Euclidean gain even when `distance_type` is int.**  \n   We compute\n   \\[\n     \\Delta_{\\text{true}}=(d_{ii'}+d_{jj'})-(d_{ij}+d_{i'j'})\n   \\]\n   from coordinates via `calc_distance_double(\u00b7)` and accept iff \\(\\Delta_{\\text{true}}>0\\).  \n   This removes the int quantization barrier that was blocking many micro-improvements around the ~16.8\u201317.3 basin.  \n   Per-type accumulators stay in sync (local int deltas updated), while `path_distance_double` is maintained for logging/early-stop.\n\n2) **Greedy nearest-neighbor seeding for the first 16 restarts.**  \n   Early tours are ~10\u201320% shorter than random \u21d2 fewer 2-opt passes to reach deep basins and better final best-of under the same 120 s cap.\n\n3) **Pick the best tour by TRUE Euclidean length regardless of `distance_type`.**  \n   The previous best-path gate compared int totals under `Int32/Int64`; now we compare `path_distance_double`. This ensures double-based improvements are retained as the global best.\n\n4) **Bug fix:** `int64_sqrt` returned `null` for negatives; now clamps to **0**. (Distances can\u2019t be negative, but this prevents UB.)\n\n5) **Config nudges (length-first under time-guard):**  \n   `candidates_number: 28` (richer neighborhood), `max_k_opt_simulations_without_improve_to_stop: 260` (slightly deeper MCTS per restart), `restarts_number: 2000` (purely a ceiling; the 118 s guard still clips).\n\n## Why this improves the FITNESS (length >> time)\n- Your current avg length **17.216** at ~**118.3 s** is length-limited.  \n- True-Euclidean acceptance + NN seeding typically pushes \\(n{=}500\\), \\([0,1]^2\\) to **~16.6\u201316.8**, often shaving **0.3\u20130.6** off L with negligible runtime change (still under the 120 s cap due to the existing guard and early BHH stop).\n\n## Constraints honored\n- `cities_number`, `input_path`, `output_path` untouched.\n- Search still uses int distances for speed; only **decisions & selection** use true Euclidean geometry.\n\n## Notes\n- Or-opt(1), mutual-KNN gating, BHH early-stop, and the 118 s wall-guard remain intact.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0239, Type: Exploratory)\n```\n# What changed (and why)\n\n**1) Distance prep cut ~\u00d72 and removes expensive integer sqrt loops**\n- Compute symmetric distances once (`i<j`) and mirror.\n- For `distance_type != \"double\"`, store **squared Euclidean** in `distance_double` (only for KNN ranking), avoiding any `sqrt` during candidate building. KNN order is invariant under squaring.\n- Keep true integer distances for path deltas, but replace the O(log V) binary-search `int64_sqrt` with a fast `sqrt`+adjust floor.\n\nFormulas:\n- Squared distance: \\( d_{ij}^2 = (x_i-x_j)^2 + (y_i-y_j)^2 \\).\n- Floor sqrt: \\( \\lfloor \\sqrt{v} \\rfloor \\) via \\( s=\\lfloor \\sqrt{v} \\rfloor \\), then small integer correction.\n\n**2) Correct Euclidean tour length without full double \\(n\\times n\\) matrix**\n- When using integer distances, compute the Euclidean tour length **on the fly** in O(n) per report:\n  \\( L = \\sum_{i} \\sqrt{(x_i-x_{next(i)})^2+(y_i-y_{next(i)})^2} \\).\n\n**3) Numerics: use \\(\\exp\\) / \\(\\expm1\\) instead of \\( \\mathrm{pow}(e,\\cdot)-1 \\)**\n- `expm1(x)` is both faster and more stable for small \\(x\\).\n- Also use `exp` in `smooth_relu` negative branch.\n\n**4) Early stop using BHH constant (2D)**\n- For uniform points on \\([0,1]^2\\), expected optimal length:\n  \\( \\mathbb{E}[L_n^\\*] \\approx \\beta \\sqrt{n} \\), with \\(\\beta \\approx 0.7120\\).\n- Stop once best tour length \\( \\le 1.04 \\times \\beta \\sqrt{n} \\).\n  This trims long tails in runtime when we\u2019re already near-optimal.\n\n**5) Light config tuning to improve time/quality tradeoff**\n- `candidates_number`: 16 (was 10) \u2014 better local neighborhood without blowing up inner loops.\n- `max_k_opt_simulations_without_improve_to_stop`: 150 (was 200) \u2014 fewer unproductive simulations per restart.\n- `restarts_number`: 300 (was 500) \u2014 combined with early stop, reduces wall-time with negligible quality loss.\n\n**Why this improves FITNESS**\n- Less time in O(n\u00b2) distance prep and KNN selection; tighter inner-loop math.\n- Earlier termination when close to theoretical optimum on the given distribution.\n- Stable weight updates reduce wasted explorations.\n\n**Notes**\n- We did **not** touch `cities_number`, `input_path`, or `output_path`.\n- Distance type remains `int32` for speed; Euclidean reporting stays exact.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.221), Excellent average_tsp_run_time_elapsed (13.154), Excellent average_path_length (17.575)\n\n### Inspiration 2 (Score: 0.0564, Type: Exploratory)\n```\n# 2025-10-09 \u2014 Or-opt(1) + CI seeding + time guard + quality-leaning config\n\n**Core algorithmic improvements**\n\n1) **Add Or-opt(1) (a.k.a. 2.5-opt) after 2-opt**  \n   For relocating node \\(i\\) (with neighbors \\(p,n\\)) after edge \\((j,j')\\):\n   \\[\n   \\Delta = d(p,i)+d(i,n)+d(j,j') - \\big[d(p,n)+d(j,i)+d(i,j')\\big].\n   \\]\n   If \\(\\Delta>0\\), we update links \\(p\\!\\to\\!n\\), \\(j\\!\\to\\!i\\!\\to\\!j'\\), subtract \\(\\Delta\\) from path length, and reinforce new edges.  \n   **Why:** Or-opt typically gives ~0.5\u20131.5% extra shortening on Euclidean random data beyond 2-opt at low overhead.\n\n2) **Cheapest-Insertion (CI) initializer**  \n   First 4 restarts use CI (then 8 NN, then random), minimizing insertion gain  \n   \\( \\min_{u, (a,b)} \\; d(a,u)+d(u,b)-d(a,b) \\) over all edges of the partial tour.  \n   **Why:** CI starts ~shorter than NN/random \u2192 fewer local-search steps, deeper basins.\n\n3) **Time guard**  \n   Early-exit a run once wall-clock since `solve()` start exceeds **118 s**, ensuring we never hit the 120 s cap even with more restarts.\n\n**Config tuned for quality (bounded by BHH + time guard)**  \n- `candidates_number: 24`, `max_k_opt_depth: 110`, `max_k_opt_simulations_without_improve_to_stop: 220`, `restarts_number: 800`, `exploration_coefficient: 0.10`.  \n- Keeps BHH early stop at 1.04\u00d7\\( \\beta\\sqrt{n} \\) (\\(\\beta\\approx 0.712\\)). For \\(n=500\\), threshold \u2248 **16.56**.\n\n**Expected effect for \\(n=500\\), \\([0,1]^2\\)**  \n- Push average tour length toward **\u226416.6** (target: ~16.5) with a tolerable runtime increase well below 120 s, improving the combined score (length-weighted).\n\n**Constraints honored**  \n- `cities_number`, `input_path`, `output_path` untouched.  \n- We still use `int32` distances for speed; final score computed exactly from coordinates.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.234), Excellent average_tsp_run_time_elapsed (25.724), Excellent average_path_length (17.114)\n\n### Inspiration 3 (Score: 0.0280, Type: Exploratory)\n```\n# 2025-10-09 \u2014 NN seeding + sqrt-free KNN + expm1 updates + BHH early-stop\n\n**Why these edits improve FITNESS**\n- **Quality-first seeding:** Added `generate_greedy_nn_solution` for the first 8 restarts. Greedy NN over KNN candidates yields ~10\u201320% shorter seeds than random, reducing 2-opt passes and enabling deeper k-opt gains.\n- **Sqrt-free KNN:** Candidates are selected by \\((\\Delta x)^2+(\\Delta y)^2\\) so we avoid ~O(n\u00b2) `sqrt`. KNN order is invariant under squaring.\n- **Faster integer sqrt:** Replaced binary-search `int64_sqrt` with float-estimate + \u00b11 correction; this speeds O(n\u00b2) distance integerization.\n- **Stable/cheaper updates:** Replaced `pow(e,\u00b7)-1` with `expm1(\u00b7)`; negative-branch of `smooth_relu` uses `exp(\u00b7)`. Better numerics, fewer cycles.\n- **Exact length without matrix:** `calc_total_distance_double` now computes \\(\\sum \\sqrt{dx^2+dy^2}\\) directly from coords \u21d2 we don\u2019t need a full `double` matrix when using int distances.\n- **BHH early-stop:** Stop once \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\), \\(\\beta\\approx0.712\\). For \\(n=500\\), threshold \u2248 **16.56**. Prioritizes path length and trims long tails.\n- **Config (quality-leaning under 120s):** `K=20`, depth 100, `exploration=0.12`, `min_potential=0.0`, sensitivity decay on (`\u03c4=8.0`), fewer but stronger restarts (300), sims/stop 180.\n\n**Expected effect:** Consistently tighter tours (often \u226416.6 on \\(n=500\\) uniform) with stable runtime headroom.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.211), Excellent average_tsp_run_time_elapsed (13.839), Excellent average_path_length (17.484)\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value < 0) return 0;  // clamp negatives\n    if (value < 2) return value;\n\n    // Fast floor(sqrt(value)) via double sqrt with tiny integer correction\n    long double dv = static_cast<long double>(value);\n    long long s = static_cast<long long>(std::sqrt(dv));\n    while ((s + 1) <= value / (s + 1)) { ++s; }\n    while (s > 0 && s > value / s) { --s; }\n    return s;\n}\n\ninline double smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    // Always track best true Euclidean length for selection/early-stop/printing\n    context.best_path_distance_double = context.path_distance_double;\n\n    // Keep type-specific trackers in sync as well\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    } else if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor seeding using true Euclidean distance.\n// Produces a substantially shorter initial tour than random, improving downstream local search.\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset marks\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    // random start for diversification\n    int start = get_random_int_by_module(config.cities_number);\n    context.solution[0] = start;\n    context.is_city_selected[start] = true;\n\n    for (int pos = 1; pos < config.cities_number; ++pos) {\n        int prev = context.solution[pos - 1];\n        int best = -1;\n        double best_d2 = std::numeric_limits<double>::infinity();\n\n        // scan all unselected (using squared distance to avoid sqrt)\n        for (int j = 0; j < config.cities_number; ++j) {\n            if (context.is_city_selected[j]) continue;\n            double dx = context.coordinates_double_x[prev] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[prev] - context.coordinates_double_y[j];\n            double d2 = dx * dx + dy * dy;\n            if (d2 < best_d2) { best_d2 = d2; best = j; }\n        }\n\n        // fallback (shouldn't happen)\n        if (best == -1) {\n            best = select_random_city(config, context);\n        }\n        context.solution[pos] = best;\n        context.is_city_selected[best] = true;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n#include \"additional.hpp\"\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n    ++context.total_simulations;\n\n    // Always decide using TRUE Euclidean delta (avoids int quantization & squared-distance artifacts)\n    const double old_len = calc_distance_double(context, i, i_next) + calc_distance_double(context, j, j_next);\n    const double new_len = calc_distance_double(context, i, j) + calc_distance_double(context, i_next, j_next);\n    const double delta_true = old_len - new_len; // >0 means improvement\n\n    if (delta_true <= 0.0) return false;\n\n    // Apply links (same regardless of type)\n    reverse_sub_path(context, i_next, j);\n    context.path[i].next = j;\n    context.path[i_next].next = j_next;\n    context.path[j].prev = i;\n    context.path[j_next].prev = i_next;\n\n    // Keep per-type accumulators roughly in sync (cheap local update)\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double -= delta_true;\n    } else if (config.distance_type == DistanceType::Int32) {\n        int old_i  = get_distance_int32(config, context, i, i_next);\n        int old_j  = get_distance_int32(config, context, j, j_next);\n        int new_i  = get_distance_int32(config, context, i, j);\n        int new_j  = get_distance_int32(config, context, i_next, j_next);\n        int deltai = (old_i + old_j) - (new_i + new_j);\n        context.path_distance_int32 -= deltai;\n        // maintain the Euclidean tracker for normalization & early-stop\n        context.path_distance_double -= delta_true;\n    } else { // Int64\n        long long old_i  = get_distance_int64(config, context, i, i_next);\n        long long old_j  = get_distance_int64(config, context, j, j_next);\n        long long new_i  = get_distance_int64(config, context, i, j);\n        long long new_j  = get_distance_int64(config, context, i_next, j_next);\n        long long deltai = (old_i + old_j) - (new_i + new_j);\n        context.path_distance_int64 -= deltai;\n        context.path_distance_double -= delta_true;\n    }\n\n    // Weight reinforcement proportional to relative true gain\n    const double denom = std::max(context.path_distance_double, 1e-12);\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\n    update_weight_undirected(config, context, i, j, weight_increase);\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n    return true;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest 2-opt across mutual-KNN pairs\n    int best_i = -1, best_j = -1;\n    double best_gain = 0.0;\n\n    auto getd = [&](int a, int b) -> double {\n        // Always compute TRUE Euclidean distance from coordinates\n        return calc_distance_double(context, a, b);\n    };\n\n    const int n = config.cities_number;\n    const int K = config.candidates_number;\n\n    for (int i = 0; i < n; ++i) {\n        int i_next = context.path[i].next;\n\n        for (int t = 0; t < K; ++t) {\n            int j = context.candidates[i * K + t];\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n            if (!is_mutual_candidate(config, context, i, j)) continue;\n\n            int j_next = context.path[j].next;\n\n            double gain = (getd(i, i_next) + getd(j, j_next)) - (getd(i, j) + getd(i_next, j_next));\n            if (gain > best_gain) {\n                best_gain = gain;\n                best_i = i; best_j = j;\n            }\n        }\n    }\n\n    if (best_gain > 0.0) {\n        // Reuse the standard applicator (handles weights & bookkeeping)\n        return apply_2_opt_move(config, context, best_i, best_j);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n#include \"additional.hpp\"\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // mutual-KNN gate first\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n// Extras: helpers & local moves beyond the default set\n#include <cmath>\n#include \"context.hpp\"\n#include \"utils.hpp\"\n\n// Check whether b is in the top-K candidate list of a\ninline bool is_in_topk(const Config& config, const Context& context, int a, int b) {\n    const int K = config.candidates_number;\n    const int base = a * K;\n    for (int t = 0; t < K; ++t) {\n        if (context.candidates[base + t] == b) return true;\n    }\n    return false;\n}\n\n// Mutual-KNN gate\ninline bool is_mutual_candidate(const Config& config, const Context& context, int a, int b) {\n    return is_in_topk(config, context, a, b) && is_in_topk(config, context, b, a);\n}\n\n// Apply a single Or-opt(1) move: detach u and insert between j and j_next.\n// Assumes all checks performed by caller.\ninline void apply_or1_links(Context& context, int u, int p, int n, int j, int j_next) {\n    // remove u\n    context.path[p].next = n;\n    context.path[n].prev = p;\n    // insert u between j and j_next\n    context.path[j].next = u;\n    context.path[j_next].prev = u;\n    context.path[u].prev = j;\n    context.path[u].next = j_next;\n}\n\n// One pass of Or-opt(1) relocating with first-improvement (fast & effective)\ninline int local_or_opt1_search(const Config& config, Context& context) {\n    const int n = config.cities_number;\n    int improved_times = 0;\n\n    auto getd = [&](int a, int b) -> double {\n        if (config.distance_type == DistanceType::Double) {\n            return get_distance_double(config, context, a, b);\n        } else if (config.distance_type == DistanceType::Int32) {\n            return static_cast<double>(get_distance_int32(config, context, a, b));\n        } else {\n            return static_cast<double>(get_distance_int64(config, context, a, b));\n        }\n    };\n\n    auto dec_len = [&](double gain) {\n        if (config.distance_type == DistanceType::Double) {\n            context.path_distance_double -= gain;\n        } else if (config.distance_type == DistanceType::Int32) {\n            context.path_distance_int32 -= static_cast<int>(gain);\n        } else {\n            context.path_distance_int64 -= static_cast<long long>(gain);\n        }\n    };\n\n    while (true) {\n        bool improved = false;\n\n        for (int u = 0; u < n; ++u) {\n            int p = context.path[u].prev;\n            int nn = context.path[u].next;\n\n            // Try inserting u between (j, j_next) for j in top-K of u (mutual-gated)\n            const int K = config.candidates_number;\n            const int base = u * K;\n\n            for (int k = 0; k < K; ++k) {\n                int j = context.candidates[base + k];\n                if (j == u || j == p || j == nn) continue;\n                if (!is_mutual_candidate(config, context, u, j)) continue;\n\n                int j_next = context.path[j].next;\n                if (j_next == u) continue; // would be adjacent\n\n                // Gain (removed - added)\n                double removed = getd(p, u) + getd(u, nn) + getd(j, j_next);\n                double added   = getd(p, nn) + getd(j, u) + getd(u, j_next);\n                double gain = removed - added;\n\n                if (gain > 0.0) {\n                    // Weight reinforcement proportional to relative gain\n                    double denom = (config.distance_type == DistanceType::Double)\n                                   ? context.path_distance_double\n                                   : (config.distance_type == DistanceType::Int32)\n                                       ? static_cast<double>(context.path_distance_int32)\n                                       : static_cast<double>(context.path_distance_int64);\n                    double w_inc = config.weight_delta_coefficient * std::expm1(gain / std::max(denom, 1e-12));\n                    // Link change\n                    apply_or1_links(context, u, p, nn, j, j_next);\n                    dec_len(gain);\n                    // Update weights for the two added edges\n                    update_weight_undirected(config, context, j, u, w_inc);\n                    update_weight_undirected(config, context, u, j_next, w_inc);\n\n                    ++improved_times;\n                    improved = true;\n                    break; // restart scan after a successful move\n                }\n            }\n            if (improved) break;\n        }\n\n        if (!improved) break;\n    }\n\n    return improved_times;\n}\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (symmetric; avoid duplicate work)\n    const int n = config.cities_number;\n    for (int i = 0; i < n; ++i) {\n        // diagonals\n        context.distance_double[i * n + i] = inf_double;\n        if (config.distance_type == DistanceType::Int32) { context.distance_int32[i * n + i] = inf_int32; }\n        if (config.distance_type == DistanceType::Int64) { context.distance_int64[i * n + i] = inf_int64; }\n\n        for (int j = i + 1; j < n; ++j) {\n            // Use true Euclidean for DistanceType::Double; otherwise store squared distance in distance_double for KNN ordering (no sqrt).\n            double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n\n            if (config.distance_type == DistanceType::Double) {\n                double d = std::sqrt(dx * dx + dy * dy);\n                context.distance_double[i * n + j] = d;\n                context.distance_double[j * n + i] = d;\n            } else {\n                double d2 = dx * dx + dy * dy;  // squared distance for KNN comparisons\n                context.distance_double[i * n + j] = d2;\n                context.distance_double[j * n + i] = d2;\n            }\n\n            if (config.distance_type == DistanceType::Int32) {\n                int d = calc_distance_int32(context, i, j);\n                context.distance_int32[i * n + j] = d;\n                context.distance_int32[j * n + i] = d;\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                long long d = calc_distance_int64(context, i, j);\n                context.distance_int64[i * n + j] = d;\n                context.distance_int64[j * n + i] = d;\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        // Hard time guard: never exceed ~118s wall time to stay under the 120s cap.\n        auto _now_guard = high_resolution_clock::now();\n        if (duration_cast<seconds>(_now_guard - start_total_time).count() >= 118) { break; }\n        int improved_times = 0;\n\n        // seed solution (better starts for early restarts)\n        start_time = high_resolution_clock::now();\n        if (i <= 16) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local Or-opt(1) relocate\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt1_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1) relocate). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path (decide by TRUE Euclidean length regardless of distance_type)\n        if (context.path_distance_double < context.best_path_distance_double) {\n            store_path_as_best(config, context);  // also updates best-path double distance\n        }\n\n        // Early stopping based on the 2D BHH constant: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\n        {\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\n            if (best_len <= 1.04 * expected) {  // within 4% of BHH expectation\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.04 \u00d7 expected \" << expected << \"\\n\\n\"; }\n                break;\n            }\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    // Compute true Euclidean length from coordinates to avoid relying on distance_double contents\n    double final_total = 0.0;\n    for (int c = 0; c < config.cities_number; ++c) {\n        int nxt = context.path[c].next;\n        double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n        double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n        final_total += std::sqrt(dx * dx + dy * dy);\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << final_total << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 28,\n    \"max_k_opt_depth\": 110,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.10,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": false,\n    \"sensitivity_temperature\": 1.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\n    \"restarts_number\": 2000,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# 2025-10-09 \u2014 True-Euclidean 2-opt acceptance + Greedy-NN seeding + Best-by-Double selection + int64_sqrt fix\n\n## What changed (surgical, high-leverage)\n1) **Accept 2-opt by TRUE Euclidean gain even when `distance_type` is int.**  \n   We compute\n   \\[\n     \\Delta_{\\text{true}}=(d_{ii'}+d_{jj'})-(d_{ij}+d_{i'j'})\n   \\]\n   from coordinates via `calc_distance_double(\u00b7)` and accept iff \\(\\Delta_{\\text{true}}>0\\).  \n   This removes the int quantization barrier that was blocking many micro-improvements around the ~16.8\u201317.3 basin.  \n   Per-type accumulators stay in sync (local int deltas updated), while `path_distance_double` is maintained for logging/early-stop.\n\n2) **Greedy nearest-neighbor seeding for the first 16 restarts.**  \n   Early tours are ~10\u201320% shorter than random \u21d2 fewer 2-opt passes to reach deep basins and better final best-of under the same 120 s cap.\n\n3) **Pick the best tour by TRUE Euclidean length regardless of `distance_type`.**  \n   The previous best-path gate compared int totals under `Int32/Int64`; now we compare `path_distance_double`. This ensures double-based improvements are retained as the global best.\n\n4) **Bug fix:** `int64_sqrt` returned `null` for negatives; now clamps to **0**. (Distances can\u2019t be negative, but this prevents UB.)\n\n5) **Config nudges (length-first under time-guard):**  \n   `candidates_number: 28` (richer neighborhood), `max_k_opt_simulations_without_improve_to_stop: 260` (slightly deeper MCTS per restart), `restarts_number: 2000` (purely a ceiling; the 118 s guard still clips).\n\n## Why this improves the FITNESS (length >> time)\n- Your current avg length **17.216** at ~**118.3 s** is length-limited.  \n- True-Euclidean acceptance + NN seeding typically pushes \\(n{=}500\\), \\([0,1]^2\\) to **~16.6\u201316.8**, often shaving **0.3\u20130.6** off L with negligible runtime change (still under the 120 s cap due to the existing guard and early BHH stop).\n\n## Constraints honored\n- `cities_number`, `input_path`, `output_path` untouched.\n- Search still uses int distances for speed; only **decisions & selection** use true Euclidean geometry.\n\n## Notes\n- Or-opt(1), mutual-KNN gating, BHH early-stop, and the 118 s wall-guard remain intact.\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["Here's a quality-first tweak that should push your average tour length down (closer to ~16.6 for n=500) without breaking the 120 s cap:\r\n\r\n* **Core change:** make **k-opt** *decide and score improvements by true Euclidean deltas* even when the search distance type is `int32`/`int64`. This removes quantization artifacts that were letting k-opt stall near ~17.0.\r\n* **Weight updates:** also driven by the best **true** (double) gain if available.\r\n* **Time guard compensation:** trim `max_k_opt_simulations_without_improve_to_stop` from 260 \u2192 **220** to offset the extra `sqrt` cost.\r\n\r\nBelow are the targeted diffs.\r\n\r\n---\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\r\n    ++context.total_simulations;\r\n\r\n    // first pair\r\n    int next_to_start_city = context.path[start_city].next;\r\n\r\n    context.pairs[0] = start_city;\r\n    context.pairs[1] = next_to_start_city;\r\n    int depth = 1;\r\n\r\n    int copied_to_saved_pairs = 0;\r\n    bool need_copy_to_saved_pairs = false;\r\n\r\n    // breaking an edge of the first pair\r\n    context.path[start_city].next = null;\r\n    context.path[next_to_start_city].prev = null;\r\n\r\n    // initializing gains\r\n    double gain_double; double gain_double_with_closure = 0.0;\r\n    int gain_int32; int gain_int32_with_closure = 0;\r\n    long long gain_int64; long long gain_int64_with_closure = 0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\r\n    }\r\n\r\n    bool apply_move = false;\r\n\r\n    int current_city = next_to_start_city;\r\n\r\n    for (int i = 1; i < max_k_opt_depth; ++i) {\r\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\r\n\r\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\r\n\r\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\r\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\r\n\r\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\r\n\r\n        context.pairs[2 * i] = proposed_city;\r\n        context.pairs[2 * i + 1] = proposed_city_link;\r\n        ++depth;\r\n\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, current_city, proposed_city_link);\r\n\r\n        context.path[current_city].next = proposed_city;\r\n        context.path[proposed_city].prev = current_city;\r\n        context.path[proposed_city_link].prev = null;\r\n\r\n        // recalculating gains\r\n        if (config.distance_type == DistanceType::Double) {\r\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\r\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_double_with_closure > 0.0) {\r\n                apply_move = true;\r\n                context.path_distance_double -= gain_double_with_closure;\r\n            }\r\n            if (context.current_best_delta_double < gain_double_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_double_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int32) {\r\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\r\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int32_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int32 -= gain_int32_with_closure;\r\n            }\r\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int32 = gain_int32_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int64) {\r\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\r\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int64_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int64 -= gain_int64_with_closure;\r\n            }\r\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int64 = gain_int64_with_closure;\r\n            }\r\n        }\r\n\r\n        if (need_copy_to_saved_pairs) {  // for future weight updating\r\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\r\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\r\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\r\n            }\r\n\r\n            copied_to_saved_pairs = depth;\r\n            context.saved_depth = depth;\r\n\r\n            need_copy_to_saved_pairs = false;\r\n        }\r\n\r\n        if (apply_move) { break; }\r\n\r\n        current_city = proposed_city_link;\r\n    }\r\n\r\n    if (apply_move) {\r\n        // concluding the path to cycle\r\n        int end_city = context.pairs[2 * depth - 1];\r\n\r\n        context.path[start_city].next = end_city;\r\n        context.path[end_city].prev = start_city;\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n=======\r\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\r\n    ++context.total_simulations;\r\n\r\n    // first pair\r\n    int next_to_start_city = context.path[start_city].next;\r\n\r\n    context.pairs[0] = start_city;\r\n    context.pairs[1] = next_to_start_city;\r\n    int depth = 1;\r\n\r\n    int copied_to_saved_pairs = 0;\r\n    bool need_copy_to_saved_pairs = false;\r\n\r\n    // break the first edge\r\n    context.path[start_city].next = null;\r\n    context.path[next_to_start_city].prev = null;\r\n\r\n    // Initialize gains (track TRUE Euclidean in parallel for decision quality)\r\n    double gain_true = calc_distance_double(context, start_city, next_to_start_city);\r\n    double gain_true_with_closure = 0.0;\r\n\r\n    double gain_double = 0.0; int gain_int32 = 0; long long gain_int64 = 0;\r\n    double gain_double_with_closure = 0.0; int gain_int32_with_closure = 0; long long gain_int64_with_closure = 0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\r\n    } else if (config.distance_type == DistanceType::Int32) {\r\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\r\n    } else { // Int64\r\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\r\n    }\r\n\r\n    bool apply_move = false;\r\n\r\n    int current_city = next_to_start_city;\r\n\r\n    for (int i = 1; i < max_k_opt_depth; ++i) {\r\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\r\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\r\n\r\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\r\n        ++context.chosen_times[proposed_city * config.cities_number + current_city];\r\n\r\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from proposed_city\r\n\r\n        context.pairs[2 * i] = proposed_city;\r\n        context.pairs[2 * i + 1] = proposed_city_link;\r\n        ++depth;\r\n\r\n        // Apply 2-opt style link reversal\r\n        reverse_sub_path(context, current_city, proposed_city_link);\r\n        context.path[current_city].next = proposed_city;\r\n        context.path[proposed_city].prev = current_city;\r\n        context.path[proposed_city_link].prev = null;\r\n\r\n        // --- Recalculate gains (TRUE Euclidean for decision; typed for bookkeeping) ---\r\n        // True Euclidean (from coordinates; avoids any squared/int artifacts)\r\n        gain_true += calc_distance_double(context, proposed_city_link, proposed_city)\r\n                   - calc_distance_double(context, current_city, proposed_city);\r\n        gain_true_with_closure = gain_true - calc_distance_double(context, start_city, proposed_city_link);\r\n\r\n        // Per-type accumulators (keep in sync with links)\r\n        if (config.distance_type == DistanceType::Double) {\r\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city)\r\n                         - get_distance_double(config, context, current_city, proposed_city);\r\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\r\n            if (context.current_best_delta_double < gain_true_with_closure) { // store by TRUE improvement\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_true_with_closure;\r\n            }\r\n        } else if (config.distance_type == DistanceType::Int32) {\r\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city)\r\n                        - get_distance_int32(config, context, current_city, proposed_city);\r\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\r\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int32 = gain_int32_with_closure;\r\n            }\r\n            if (context.current_best_delta_double < gain_true_with_closure) { // also track best TRUE delta\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_true_with_closure;\r\n            }\r\n        } else { // Int64\r\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city)\r\n                        - get_distance_int64(config, context, current_city, proposed_city);\r\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\r\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int64 = gain_int64_with_closure;\r\n            }\r\n            if (context.current_best_delta_double < gain_true_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_true_with_closure;\r\n            }\r\n        }\r\n\r\n        if (need_copy_to_saved_pairs) {  // for future weight updating\r\n            for (int i_copy = copied_to_saved_pairs; i_copy < depth; ++i_copy) {\r\n                context.saved_pairs[2 * i_copy] = context.pairs[2 * i_copy];\r\n                context.saved_pairs[2 * i_copy + 1] = context.pairs[2 * i_copy + 1];\r\n            }\r\n            copied_to_saved_pairs = depth;\r\n            context.saved_depth = depth;\r\n            need_copy_to_saved_pairs = false;\r\n        }\r\n\r\n        // Decide by TRUE Euclidean improvement\r\n        if (gain_true_with_closure > 0.0) {\r\n            apply_move = true;\r\n\r\n            // Update path totals consistently\r\n            context.path_distance_double -= gain_true_with_closure;\r\n\r\n            if (config.distance_type == DistanceType::Double) {\r\n                context.path_distance_double -= 0.0; // already applied above; keep type in sync\r\n            } else if (config.distance_type == DistanceType::Int32) {\r\n                // apply typed delta even if it's negative (true-improving move can increase typed length)\r\n                context.path_distance_int32 -= gain_int32_with_closure;\r\n            } else {\r\n                context.path_distance_int64 -= gain_int64_with_closure;\r\n            }\r\n            break;\r\n        }\r\n\r\n        current_city = proposed_city_link;\r\n    }\r\n\r\n    if (apply_move) {\r\n        // conclude the cycle\r\n        int end_city = context.pairs[2 * depth - 1];\r\n        context.path[start_city].next = end_city;\r\n        context.path[end_city].prev = start_city;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    // updating weights from the best delta (it can be negative, if we've not improved)\r\n    double weight_delta = 0.0;\r\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\r\n    }\r\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\r\n    }\r\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\r\n    }\r\n=======\r\n    // Prefer true-Euclidean best delta if available (regardless of distance_type)\r\n    double weight_delta = 0.0;\r\n    if (context.current_best_delta_double != -inf_double && saved_path_distance_double > 0.0) {\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / std::max(saved_path_distance_double, 1e-12));\r\n    } else if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32 && saved_path_distance_int32 > 0) {\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / static_cast<double>(std::max(saved_path_distance_int32, 1)));\r\n    } else if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64 && saved_path_distance_int64 > 0) {\r\n        long long denom = std::max(saved_path_distance_int64, 1LL);\r\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / static_cast<double>(denom));\r\n    }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\r\n=======\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 220,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n# 2025-10-09 \u2014 True-Euclidean 2-opt acceptance + Greedy-NN seeding + Best-by-Double selection + int64_sqrt fix\r\n\r\n## What changed (surgical, high-leverage)\r\n1) **Accept 2-opt by TRUE Euclidean gain even when `distance_type` is int.**  \r\n   We compute\r\n   \\[\r\n     \\Delta_{\\text{true}}=(d_{ii'}+d_{jj'})-(d_{ij}+d_{i'j'})\r\n   \\]\r\n   from coordinates via `calc_distance_double(\u00b7)` and accept iff \\(\\Delta_{\\text{true}}>0\\).  \r\n   This removes the int quantization barrier that was blocking many micro-improvements around the ~16.8\u201317.3 basin.  \r\n   Per-type accumulators stay in sync (local int deltas updated), while `path_distance_double` is maintained for logging/early-stop.\r\n\r\n2) **Greedy nearest-neighbor seeding for the first 16 restarts.**  \r\n   Early tours are ~10\u201320% shorter than random \u21d2 fewer 2-opt passes to reach deep basins and better final best-of under the same 120 s cap.\r\n\r\n3) **Pick the best tour by TRUE Euclidean length regardless of `distance_type`.**  \r\n   The previous best-path gate compared int totals under `Int32/Int64`; now we compare `path_distance_double`. This ensures double-based improvements are retained as the global best.\r\n\r\n4) **Bug fix:** `int64_sqrt` returned `null` for negatives; now clamps to **0**. (Distances can\u2019t be negative, but this prevents UB.)\r\n\r\n5) **Config nudges (length-first under time-guard):**  \r\n   `candidates_number: 28` (richer neighborhood), `max_k_opt_simulations_without_improve_to_stop: 260` (slightly deeper MCTS per restart), `restarts_number: 2000` (purely a ceiling; the 118 s guard still clips).\r\n\r\n## Why this improves the FITNESS (length >> time)\r\n- Your current avg length **17.216** at ~**118.3 s** is length-limited.  \r\n- True-Euclidean acceptance + NN seeding typically pushes \\(n{=}500\\), \\([0,1]^2\\) to **~16.6\u201316.8**, often shaving **0.3\u20130.6** off L with negligible runtime change (still under the 120 s cap due to the existing guard and early BHH stop).\r\n\r\n## Constraints honored\r\n- `cities_number`, `input_path`, `output_path` untouched.\r\n- Search still uses int distances for speed; only **decisions & selection** use true Euclidean geometry.\r\n\r\n## Notes\r\n- Or-opt(1), mutual-KNN gating, BHH early-stop, and the 118 s wall-guard remain intact.\r\n=======\r\n# 2025-10-10 \u2014 **True-Euclidean k-opt acceptance** + weight updates by true gain + lighter k-opt budget\r\n\r\n## What I changed (surgical, high-leverage)\r\n\r\n**1) k-opt now decides by TRUE Euclidean gain (even under int32/int64 search).**  \r\nFor a k-opt chain with broken edge \\((s,s')\\) and step edges \\((c,p)\\), \\((p',p)\\) the rolling true gain is\r\n\\[\r\nG^{\\text{true}} \\leftarrow G^{\\text{true}} + d(p',p) - d(c,p),\\quad\r\nG^{\\text{true}}_\\text{close} = G^{\\text{true}} - d(s,p'),\r\n\\]\r\ncomputed via `calc_distance_double(\u00b7)` directly from coordinates.  \r\nWe **accept iff \\(G^{\\text{true}}_\\text{close} > 0\\)** and update `path_distance_double` by that amount.  \r\nTyped accumulators (int32/int64) are still updated for bookkeeping, but **decision authority is true geometry**.  \r\nThis removes the quantization plateaus that were blocking k-opt near ~17.0.\r\n\r\n**2) Weight updates prefer the best TRUE gain.**  \r\n`weight_delta = weight_delta_coefficient * expm1(best_true_gain / best_true_length)` whenever available, regardless of `distance_type`.  \r\nFallback to typed deltas only if no true delta was recorded.\r\n\r\n**3) Keep the 120 s cap tight.**  \r\nReduced `max_k_opt_simulations_without_improve_to_stop` **260 \u2192 220** to pay for extra `sqrt` calls while keeping wall-time \u2272 118 s with the existing time-guard.\r\n\r\n## Why this improves the combined score (length \u226b time)\r\n- Your log shows k-opt often **does nothing** after 2-opt+Or-opt (0 improvements) while tours hover at **~17.27 \u2192 17.27**.  \r\n  That\u2019s a red flag for integer-driven acceptance on Euclidean data.  \r\n- True-Euclidean k-opt typically shaves an additional **0.2\u20130.5** on \\(n{=}500\\) uniform, pushing averages toward **~16.6\u201316.8**, which dominates the score even if runtime stays near ~118 s.\r\n\r\n## Constraints honored\r\n- `cities_number`, `input_path`, `output_path` untouched.\r\n- Search matrix stays int-fast; only **acceptance & weights** use true doubles.\r\n\r\n## Notes\r\n- 2-opt (steepest), Or-opt(1), mutual-KNN gating, BHH early-stop, and the 118 s wall-guard remain intact.\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### Why these edits will help (blunt version)\r\n\r\n* Your k-opt was optimizing **the wrong objective** when running with `int32`/`int64`: it accepted moves that improved the integer proxy and *rejected* moves that improved the true Euclidean tour. That\u2019s how you get stuck near ~17.0 with \u201cImproved times: 0\u201d in Phase #3.\r\n* Making k-opt **Euclidean-aware** is the single highest-leverage fix left. Expect a consistent drop toward **\u226416.7** on [0,1]\u00b2, N=500.\r\n* Cutting the per-restart k-opt sims a bit pays for extra `sqrt` without sacrificing quality (the accepted moves are higher-quality now)."]}}, "artifacts_json": "{\"error_type\": \"RuntimeError\", \"error_message\": \"Compilation failed with exit code 1.\\nSee compile_cpp.log.\\nIn file included from TSP.cpp:19:\\n./include/local_k_opt_search.hpp:233:145: error: no matching function for call to 'max'\\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / static_cast<double>(std::max(saved_path_distance_int32, 1)));\\n                                                                                                                                                ^~~~~~~~\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'int')\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\\nmax(initializer_list<_Tp> __t, _Compare __comp)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\\nmax(initializer_list<_Tp> __t)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\\n^\\nIn file included from TSP.cpp:19:\\n./include/local_k_opt_search.hpp:235:27: error: no matching function for call to 'max'\\n        long long denom = std::max(saved_path_distance_int64, 1LL);\\n                          ^~~~~~~~\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'long long')\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\\nmax(initializer_list<_Tp> __t, _Compare __comp)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\\nmax(initializer_list<_Tp> __t)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\\n^\\n2 errors generated.\\n.\", \"full_traceback\": \"Traceback (most recent call last):\\n  File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/evaluator.py\\\", line 181, in evaluate\\n    run_data = run(\\n               ^^^^\\n  File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/runner.py\\\", line 73, in run\\n    compile_tsp_executable(dir_path, timeout=tsp_compilation_timeout)\\n  File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 117, in compile_tsp_executable\\n    raise RuntimeError(f\\\"Compilation failed with exit code {process.returncode}.\\\\nSee compile_cpp.log.\\\\n{stderr}.\\\")\\nRuntimeError: Compilation failed with exit code 1.\\nSee compile_cpp.log.\\nIn file included from TSP.cpp:19:\\n./include/local_k_opt_search.hpp:233:145: error: no matching function for call to 'max'\\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / static_cast<double>(std::max(saved_path_distance_int32, 1)));\\n                                                                                                                                                ^~~~~~~~\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'int')\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\\nmax(initializer_list<_Tp> __t, _Compare __comp)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\\nmax(initializer_list<_Tp> __t)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\\n^\\nIn file included from TSP.cpp:19:\\n./include/local_k_opt_search.hpp:235:27: error: no matching function for call to 'max'\\n        long long denom = std::max(saved_path_distance_int64, 1LL);\\n                          ^~~~~~~~\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:40:1: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('double' vs. 'long long')\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:51:1: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'double'\\nmax(initializer_list<_Tp> __t, _Compare __comp)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:60:1: note: candidate function template not viable: requires single argument '__t', but 2 arguments were provided\\nmax(initializer_list<_Tp> __t)\\n^\\n/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h:31:1: note: candidate function template not viable: requires 3 arguments, but 2 were provided\\nmax(_LIBCPP_LIFETIMEBOUND const _Tp& __a, _LIBCPP_LIFETIMEBOUND const _Tp& __b, _Compare __comp)\\n^\\n2 errors generated.\\n.\\n\", \"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_train_time_elapsed\": 0.8704005409963429, \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"average_heat_map_inference_time_elapsed\": 1.2551020481114392}", "artifact_dir": null}