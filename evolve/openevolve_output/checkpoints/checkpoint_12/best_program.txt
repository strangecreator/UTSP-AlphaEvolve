* heat_map_train.py *:
@@@
import pathlib

BASE_DIR = pathlib.Path(__file__).parent

# torch & related imports
import numpy as np
import torch


# You can train graph neural networks here (actually you can edit the whole file).
# Save them in str(BASE_DIR / "pretrained") directory and use them in `heat_map_inference.py`.
# But mind the training time, it should not exceed 5 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).

# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).
# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.
# Maybe it is better to just improve the c++ code and not try the heat map approach.

# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.


if __name__ == "__main__":
    print("Sample output to log")
@@@

* heat_map_inference.py *:
@@@
import os
import sys
import pathlib
import argparse
import numpy as np

BASE_DIR = pathlib.Path(__file__).parent
sys.path.append(str(BASE_DIR))

# other imports
from heat_map_train import *


def calc_heat_map(cities: np.ndarray) -> np.ndarray:
    cities_number = cities.shape[0]

    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / "pretrained")
    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).

    return np.zeros((cities_number, cities_number), dtype=float)


if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--out", required=True, help="Path to .npy to write the heat map.")
    args = p.parse_args()

    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)
    first_stdin_line = sys.stdin.readline().strip()
    cities_number = int(first_stdin_line)
    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)

    # calculating heat map
    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)
    print("Sample output to log")

    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)
    tmp_path = args.out + ".tmp"

    with open(tmp_path, "wb") as output_temp_file:
        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto “.npy” added
        output_temp_file.flush()
        os.fsync(output_temp_file.fileno())
    
    os.replace(tmp_path, args.out)
@@@

* include/utils.hpp *:
@@@
#pragma once

// standart imports
#include <queue>
#include <cmath>
#include <numeric>
#include <algorithm>


constexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood–Halton–Hammersley (BHH) constant


long long int64_sqrt(long long value) {
    if (value < 0) return null;  // invalid for negatives
    if (value < 2) return value;

    constexpr long long MAX_SQRT_LL = 3037000499LL;

    long long left = 1;
    long long right = std::min<long long>(value, MAX_SQRT_LL);
    long long floor_root = 1;

    while (left <= right) {
        long long candidate = left + (right - left) / 2;

        if (candidate <= value / candidate) {
            floor_root = candidate;
            left = candidate + 1;
        } else {
            right = candidate - 1;
        }
    }
    return floor_root;
}


double calc_distance_double(Context& context, int i, int j) {
    if (i == j) { return inf_double; }
    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);
    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);
    return sqrt(diff_x * diff_x + diff_y * diff_y);
}

int calc_distance_int32(Context& context, int i, int j) {
    if (i == j) { return inf_int32; }
    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);
    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);
    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));
}

long long calc_distance_int64(Context& context, int i, int j) {
    if (i == j) { return inf_int64; }
    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];
    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];
    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);
}


double get_distance_double(const Config& config, Context& context, int i, int j) {
    return context.distance_double[i * config.cities_number + j];
}

int get_distance_int32(const Config& config, Context& context, int i, int j) {
    return context.distance_int32[i * config.cities_number + j];
}

long long get_distance_int64(const Config& config, Context& context, int i, int j) {
    return context.distance_int64[i * config.cities_number + j];
}


double calc_total_distance_double(const Config& config, Context& context) {
    double total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_double(config, context, i, context.path[i].next);
    }

    return total_distance;
}

int calc_total_distance_int32(const Config& config, Context& context) {
    int total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_int32(config, context, i, context.path[i].next);
    }

    return total_distance;
}

long long calc_total_distance_int64(const Config& config, Context& context) {
    long long total_distance = 0.0;

    for (int i = 0; i < config.cities_number; ++i) {
        total_distance += get_distance_int64(config, context, i, context.path[i].next);
    }

    return total_distance;
}


void calc_and_save_total_distance(const Config& config, Context& context) {
    if (config.distance_type == DistanceType::Double) {
        context.path_distance_double = calc_total_distance_double(config, context);
    }
    if (config.distance_type == DistanceType::Int32) {
        context.path_distance_int32 = calc_total_distance_int32(config, context);
    }
    if (config.distance_type == DistanceType::Int64) {
        context.path_distance_int64 = calc_total_distance_int64(config, context);
    }
}


void identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {
    // Build KNN lists with self removed and a stable nearest-first order.
    for (int i = 0; i < config.cities_number; ++i) {
        const int n = config.cities_number;
        const int effective_k = std::min(config.candidates_number, n - 1);

        // Fill [0..n-1], then swap-out `i` to the end and ignore it.
        std::iota(context.buffer.begin(), context.buffer.end(), 0);
        std::swap(context.buffer[i], context.buffer[n - 1]);

        auto cmp = [&](int u, int v) {
            // True if u should come before v (closer first unless reversed).
            return static_cast<bool>((metric[i * n + u] < metric[i * n + v]) ^ is_reversed);
        };

        // Partition to top-K among first (n-1) entries, then sort that prefix.
        std::nth_element(context.buffer.begin(),
                         context.buffer.begin() + effective_k,
                         context.buffer.begin() + (n - 1),
                         cmp);
        std::sort(context.buffer.begin(), context.buffer.begin() + effective_k, cmp);

        // Write top-K; if requested K > n-1, pad by repeating bests.
        for (int j = 0; j < effective_k; ++j) {
            context.candidates[i * config.candidates_number + j] = context.buffer[j];
        }
        for (int j = effective_k; j < config.candidates_number; ++j) {
            context.candidates[i * config.candidates_number + j] = context.buffer[j - effective_k];
        }
    }
}


int get_random_int_by_module(int mod) {
	return rand() % mod;
}


bool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {
    return (i == j || context.path[i].next == j || context.path[j].next == i);
}


void reverse_sub_path(Context& context, int i, int j) {
    int current_city = i;

    while (true) {
        std::swap(context.path[current_city].prev, context.path[current_city].next);

        if (current_city == j) { return; }

        current_city = context.path[current_city].prev;
    }
}


double expected_tsp_length_2d(long long n, double width, double height) {
    if (n <= 1 || width <= 0.0 || height <= 0.0) {
        return 0.0;
    }

    double area = width * height;
    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);
    return expected_length;
}
@@@

* include/context.hpp *:
@@@
#pragma once

// standart imports
#include <string>
#include <vector>
#include <limits>
#include <iostream>


// global variables declaration
constexpr int null = -1;
constexpr double e = 2.718281;
constexpr double inf_double = std::numeric_limits<double>::infinity();
constexpr int inf_int32 = std::numeric_limits<int>::max();
constexpr long long inf_int64 = std::numeric_limits<long long>::max();


enum class CandidatesSource { KNN, HeatMap };
enum class DistanceType { Int32, Int64, Double };


struct Config {
    int cities_number;
    std::string input_path;
    std::string output_path;
    bool use_heat_map_as_initial_weights;
    CandidatesSource candidates_source;
    int candidates_number;
    int max_k_opt_depth;
    bool random_k_opt_depth_after_first_iteration;
    double min_potential_to_consider;
    double exploration_coefficient;
    double weight_delta_coefficient;
    double sensitivity_temperature;
    int max_k_opt_simulations_without_improve_to_stop;
    int restarts_number;
    DistanceType distance_type;
    double magnify_rate;

    Config(const json& config) {
        cities_number = config["cities_number"];
        input_path = config["input_path"];
        output_path = config["output_path"];
        use_heat_map_as_initial_weights = config["use_heat_map_as_initial_weights"];

        if (config["candidates_source"].get<std::string>() == "knn") {
            candidates_source = CandidatesSource::KNN;
        } else if (config["candidates_source"].get<std::string>() == "heat_map") {
            candidates_source = CandidatesSource::HeatMap;
        } else {
            throw std::invalid_argument("Unknown candidates source: '" + config["candidates_source"].get<std::string>() + "'.");
        }

        candidates_number = config["candidates_number"];
        max_k_opt_depth = config["max_k_opt_depth"];
        random_k_opt_depth_after_first_iteration = config["random_k_opt_depth_after_first_iteration"];
        min_potential_to_consider = config["min_potential_to_consider"];
        exploration_coefficient = config["exploration_coefficient"];
        weight_delta_coefficient = config["weight_delta_coefficient"];
        sensitivity_temperature = config["sensitivity_temperature"];
        max_k_opt_simulations_without_improve_to_stop = config["max_k_opt_simulations_without_improve_to_stop"];
        restarts_number = config["restarts_number"];

        if (config["distance_type"].get<std::string>() == "int32") {
            distance_type = DistanceType::Int32;
        } else if (config["distance_type"].get<std::string>() == "int64") {
            distance_type = DistanceType::Int64;
        } else if (config["distance_type"].get<std::string>() == "double") {
            distance_type = DistanceType::Double;
        } else {
            throw std::invalid_argument("Unknown distance type: '" + config["distance_type"].get<std::string>() + "'.");
        }

        magnify_rate = config["magnify_rate"];

        // warnings
        if (distance_type == DistanceType::Double) {
            if (cities_number > 1'000'000) {
                std::cout << "Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\n";
            }
        } else {
            if (magnify_rate < 10'000.0) {
                std::cout << "Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\n";
            }
            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {
                std::cout << "Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\n";
            }
            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {
                std::cout << "Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\n";
            }
        }
    }
};


struct City {
  int prev;
  int next;
};


struct Context {
    // coordinates
    double* coordinates_double_x = nullptr;
    double* coordinates_double_y = nullptr;

    int* coordinates_int32_x = nullptr;
    int* coordinates_int32_y = nullptr;

    long long* coordinates_int64_x = nullptr;
    long long* coordinates_int64_y = nullptr;

    // distances
    double* distance_double = nullptr;
    int* distance_int32 = nullptr;
    long long* distance_int64 = nullptr;

    // weights
    double* heat_map = nullptr;
    double* weight = nullptr;
    double* potential = nullptr;

    // candidates
    int* candidates = nullptr;

    // local k opt search
    int* pairs = nullptr;
    long long* chosen_times = nullptr;
    long long total_simulations = 0;

    // path
    City* path = nullptr;
    double path_distance_double = inf_double;
    int path_distance_int32 = inf_int32;
    long long path_distance_int64 = inf_int64;

    City* best_path = nullptr;
    double best_path_distance_double = inf_double;
    int best_path_distance_int32 = inf_int32;
    long long best_path_distance_int64 = inf_int64;

    int* solution;
    std::vector<bool> is_city_selected;

    // other utils/tmp variables
    std::vector<int> buffer;

    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {
        coordinates_double_x = new double[config.cities_number];
        coordinates_double_y = new double[config.cities_number];

        if (config.distance_type == DistanceType::Int32) {
            coordinates_int32_x = new int[config.cities_number];
            coordinates_int32_y = new int[config.cities_number];
        }
        if (config.distance_type == DistanceType::Int64) {
            coordinates_int64_x = new long long[config.cities_number];
            coordinates_int64_y = new long long[config.cities_number];
        }

        distance_double = new double[config.cities_number * config.cities_number];
        if (config.distance_type == DistanceType::Int32) {
            distance_int32 = new int[config.cities_number * config.cities_number];
        }
        if (config.distance_type == DistanceType::Int64) {
            distance_int64 = new long long[config.cities_number * config.cities_number];
        }

        if (config.use_heat_map_as_initial_weights) {
            heat_map = new double[config.cities_number * config.cities_number];
        }
        weight = new double[config.cities_number * config.cities_number];
        potential = new double[config.cities_number * config.cities_number];

        candidates = new int[config.cities_number * config.candidates_number];

        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option
        chosen_times = new long long[config.cities_number * config.cities_number];
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            chosen_times[i] = 0;
        }

        path = new City[config.cities_number];
        best_path = new City[config.cities_number];
        solution = new int[config.cities_number];
    }

    ~Context() {
        delete[] coordinates_double_x;
        delete[] coordinates_double_y;

        if (coordinates_int32_x) { delete[] coordinates_int32_x; }
        if (coordinates_int32_y) { delete[] coordinates_int32_y; }

        if (coordinates_int64_x) { delete[] coordinates_int64_x; }
        if (coordinates_int64_y) { delete[] coordinates_int64_y; }

        delete[] distance_double;
        if (distance_int32) { delete[] distance_int32; }
        if (distance_int64) { delete[] distance_int64; }

        if (heat_map) { delete[] heat_map; }
        delete[] weight;
        delete[] potential;

        delete[] candidates;

        delete[] pairs;
        delete[] chosen_times;

        delete[] path;
        delete[] best_path;
        delete[] solution;
    }
};


void convert_solution_to_path(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        int current_city = context.solution[i];

        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];
        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];
    }
}

void convert_path_to_solution(const Config& config, Context& context) {
    int current_city = 0;

    for (int i = 0; i < config.cities_number; ++i) {
        context.solution[i] = current_city;

        current_city = context.path[current_city].next;
    }
}

void store_path_as_best(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        context.best_path[i].prev = context.path[i].prev;
        context.best_path[i].next = context.path[i].next;
    }

    if (config.distance_type == DistanceType::Double) {
        context.best_path_distance_double = context.path_distance_double;
    }
    if (config.distance_type == DistanceType::Int32) {
        context.best_path_distance_int32 = context.path_distance_int32;
    }
    if (config.distance_type == DistanceType::Int64) {
        context.best_path_distance_int64 = context.path_distance_int64;
    }
}

void restore_best_path(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
        context.path[i].prev = context.best_path[i].prev;
        context.path[i].next = context.best_path[i].next;
    }
}
@@@

* include/random_solution.hpp *:
@@@
#pragma once


// * The following functions are used to randomly generate an initial solution.
// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.


int select_random_city(const Config& config, Context& context) {
	int random_start = get_random_int_by_module(config.cities_number);

	for (int i = 0; i < config.cities_number; ++i) {
		int city = (random_start + i) % config.cities_number;

		if (!context.is_city_selected[city]) {
			return city;
		}
	}

	return null;
}

void generate_random_solution(const Config& config, Context& context) {
    // Stronger initializer: regret-2 cheapest insertion (good tours fast).
    // Falls back to previous NN-based version for very large n.
    const int n = config.cities_number;

    for (int i = 0; i < n; ++i) {
        context.solution[i] = null;
        context.is_city_selected[i] = false;
    }

    if (n <= 2000) {
        // --- Seed with a farthest pair chosen from a random sample (O(s^2)) ---
        const int s = std::min(64, n);
        std::vector<int> sample; sample.reserve(s);
        std::vector<char> seen(n, 0);
        while ((int)sample.size() < s) {
            int r = get_random_int_by_module(n);
            if (!seen[r]) { seen[r] = 1; sample.push_back(r); }
        }

        int a = sample[0], b = sample[0];
        double best_d = -1.0;
        for (int ii = 0; ii < s; ++ii) {
            for (int jj = ii + 1; jj < s; ++jj) {
                double d = context.distance_double[sample[ii] * n + sample[jj]];
                if (d > best_d) { best_d = d; a = sample[ii]; b = sample[jj]; }
            }
        }

        std::vector<int> tour;
        tour.reserve(n);
        tour.push_back(a);
        tour.push_back(b);

        std::vector<char> used(n, 0);
        used[a] = used[b] = 1;

        // --- Regret-2 cheapest insertion loop ---
        while ((int)tour.size() < n) {
            int best_city = -1, best_pos = 0;
            double best_ins = inf_double;
            double best_regret = -inf_double;

            for (int u = 0; u < n; ++u) {
                if (used[u]) continue;

                double best_delta = inf_double, second_delta = inf_double;
                int insert_pos = 0;

                const int m = (int)tour.size();
                for (int t = 0; t < m; ++t) {
                    int i = tour[t];
                    int j = tour[(t + 1) % m];
                    // Δ = d(i,u) + d(u,j) - d(i,j)
                    double delta = context.distance_double[i * n + u]
                                 + context.distance_double[u * n + j]
                                 - context.distance_double[i * n + j];

                    if (delta < best_delta) {
                        second_delta = best_delta;
                        best_delta = delta;
                        insert_pos = t + 1;
                    } else if (delta < second_delta) {
                        second_delta = delta;
                    }
                }

                double regret = second_delta - best_delta; // "regret-2"
                if (regret > best_regret || (regret == best_regret && best_delta < best_ins)) {
                    best_regret = regret;
                    best_ins = best_delta;
                    best_city = u;
                    best_pos = insert_pos;
                }
            }

            // Insert the chosen city at the best position.
            tour.insert(tour.begin() + best_pos, best_city);
            used[best_city] = 1;
        }

        // Materialize to context.solution
        for (int i = 0; i < n; ++i) {
            context.solution[i] = tour[i];
            context.is_city_selected[i] = 1;
        }
    } else {
        // --- Fallback: previous NN over candidate set (O(n * K)) ---
        int current_city = get_random_int_by_module(n);
        context.solution[0] = current_city;
        context.is_city_selected[current_city] = true;

        for (int i = 1; i < n; ++i) {
            int next_city = null;
            double min_distance = inf_double;

            // Try candidate list first
            for (int j = 0; j < config.candidates_number; ++j) {
                int candidate = context.candidates[current_city * config.candidates_number + j];
                if (!context.is_city_selected[candidate]) {
                    double dist = context.distance_double[current_city * n + candidate];
                    if (dist < min_distance) {
                        min_distance = dist;
                        next_city = candidate;
                    }
                }
            }

            // Fallback to full scan if needed
            if (next_city == null) {
                for (int j = 0; j < n; ++j) {
                    if (!context.is_city_selected[j]) {
                        double dist = context.distance_double[current_city * n + j];
                        if (dist < min_distance) {
                            min_distance = dist;
                            next_city = j;
                        }
                    }
                }
            }

            context.solution[i] = next_city;
            context.is_city_selected[next_city] = true;
            current_city = next_city;
        }
    }
}
@@@

* include/local_2_opt_search.hpp *:
@@@
#pragma once


bool apply_2_opt_move(const Config& config, Context& context, int i, int j) {
    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }

    int i_next = context.path[i].next;
	int j_next = context.path[j].next;

    ++context.chosen_times[i * config.cities_number + j];
	++context.chosen_times[j * config.cities_number + i];
	++context.chosen_times[i_next * config.cities_number + j_next];
	++context.chosen_times[j_next * config.cities_number + i_next];

    ++context.total_simulations;

    // calculating delta
    bool apply_move = false;
    double weight_increase = 0.0;

    if (config.distance_type == DistanceType::Double) {
        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);
        if (delta > 0.0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, delta / context.path_distance_double) - 1);
            context.path_distance_double -= delta;
        }
    }
    if (config.distance_type == DistanceType::Int32) {
        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);
        if (delta > 0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int32) - 1);
            context.path_distance_int32 -= delta;
        }
    }
    if (config.distance_type == DistanceType::Int64) {
        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);
        if (delta > 0) {
            apply_move = true;
            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int64) - 1);
            context.path_distance_int64 -= delta;
        }
    }

    if (apply_move) {
        // applying 2 opt move
        reverse_sub_path(context, i_next, j);

        context.path[i].next = j;
        context.path[i_next].next = j_next;
        context.path[j].prev = i;
        context.path[j_next].prev = i_next;

        // updating weights
        context.weight[i * config.cities_number + j] += weight_increase;
        context.weight[j * config.cities_number + i] += weight_increase;
        context.weight[i_next * config.cities_number + j_next] += weight_increase;
        context.weight[j_next * config.cities_number + i_next] += weight_increase;

        return true;
    }
    return false;
}


bool improve_by_2_opt_move(const Config& config, Context& context) {
    for (int i = 0; i < config.cities_number; ++i) {
		for (int j = 0; j < config.candidates_number; ++j) {
			int candidate = context.candidates[i * config.candidates_number + j];

			if (apply_2_opt_move(config, context, i, candidate)) { return true; }
		}
	}
    return false;
}

int local_2_opt_search(const Config& config, Context& context) {
    int improved_times = 0;

    while (improve_by_2_opt_move(config, context)) { ++improved_times; };

    return improved_times;
}
@@@

* include/local_k_opt_search.hpp *:
@@@
#pragma once

// standart imports
#include <cmath>
#include <iostream>


void calc_potential_inplace(const Config& config, Context& context, int i, int j) {
    if (i == j) {
        context.potential[i * config.cities_number + j] = 0.0;
        return;
    }

    double weight = context.weight[i * config.cities_number + j];

    // this forms a smooth ReLU function
    if (weight < 0) { weight = pow(e, weight); }
    else { weight += 1.0; }

    context.potential[i * config.cities_number + j] = weight + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value
}

int get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {
    int next_city = context.path[current_city].next;

	double total_potential = 0.0;
    int candidates_available = 0;

	for (int i = 0; i < config.candidates_number; ++i) {
        int candidate = context.candidates[current_city * config.candidates_number + i];
        double potential = context.potential[current_city * config.cities_number + candidate];

        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available

		total_potential += potential;
        ++candidates_available;
	}

    if (candidates_available == 0) { return null; }

    // choosing the random available candidate proportionally
    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;

	for (int i = 0; i < config.candidates_number; ++i) {
        int candidate = context.candidates[current_city * config.candidates_number + i];
        double potential = context.potential[current_city * config.cities_number + candidate];

        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available

        random_potential -= potential;
        if (random_potential <= 0) { return candidate; }
    }

	return null;
}


bool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {
    ++context.total_simulations;

    // first pair
    int next_to_start_city = context.path[start_city].next;

    context.pairs[0] = start_city;
    context.pairs[1] = next_to_start_city;
    int depth = 1;

    // breaking an edge of the first pair
    context.path[start_city].next = null;
    context.path[next_to_start_city].prev = null;

    // initializing gains
    double gain_double; double gain_double_with_closure = 0.0;
    int gain_int32; int gain_int32_with_closure = 0;
    long long gain_int64; long long gain_int64_with_closure = 0;

    if (config.distance_type == DistanceType::Double) {
        gain_double = get_distance_double(config, context, start_city, next_to_start_city);
    }
    if (config.distance_type == DistanceType::Int32) {
        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);
    }
    if (config.distance_type == DistanceType::Int64) {
        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);
    }

    bool apply_move = false;
    double weight_increase = 0.0;

    int current_city = next_to_start_city;

    for (int i = 1; i < max_k_opt_depth; ++i) {
        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);

        if (proposed_city == null) { return false; }  // no candidates, could not improve

        ++context.chosen_times[current_city * config.cities_number + proposed_city];
		++context.chosen_times[proposed_city * config.cities_number + current_city];

        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)

        context.pairs[2 * i] = proposed_city;
        context.pairs[2 * i + 1] = proposed_city_link;
        ++depth;

        // applying 2 opt move
        reverse_sub_path(context, current_city, proposed_city_link);

        context.path[current_city].next = proposed_city;
        context.path[proposed_city].prev = current_city;
        context.path[proposed_city_link].prev = null;

        // recalculating gains
        if (config.distance_type == DistanceType::Double) {
            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);
            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);

            weight_increase = config.weight_delta_coefficient * (pow(e, gain_double_with_closure / context.path_distance_double) - 1);

            if (gain_double_with_closure > 0.0) {
                apply_move = true;
                context.path_distance_double -= gain_double_with_closure;
            }
        }
        if (config.distance_type == DistanceType::Int32) {
            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);
            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);

            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int32_with_closure) / context.path_distance_int32) - 1);

            if (gain_int32_with_closure > 0) {
                apply_move = true;
                context.path_distance_int32 -= gain_int32_with_closure;
            }
        }
        if (config.distance_type == DistanceType::Int64) {
            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);
            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);

            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int64_with_closure) / context.path_distance_int64) - 1);

            if (gain_int64_with_closure > 0) {
                apply_move = true;
                context.path_distance_int64 -= gain_int64_with_closure;
            }
        }

        if (apply_move) { break; }

        current_city = proposed_city_link;
    }

    // updating weights
    for (int i = 0; i < depth; ++i) {
        int current_city = context.pairs[2 * i];
        int proposed_city = (i < depth - 1) ? context.pairs[2 * i + 2] : start_city;

        double factor = 1.0;
        if (!apply_move) {
            // exponential decrease in sensitivity
            factor = pow(e, -i / config.sensitivity_temperature);
        }

        context.weight[current_city * config.cities_number + proposed_city] += weight_increase * factor;
        context.weight[proposed_city * config.cities_number + current_city] += weight_increase * factor;
    }

    if (apply_move) {
        int end_city = context.pairs[2 * depth - 1];

        context.path[start_city].next = end_city;
        context.path[end_city].prev = start_city;

        return true;
    }
    return false;
}


bool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {
    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {
        // saving current path
        convert_path_to_solution(config, context);

        int start_city = get_random_int_by_module(config.cities_number);
        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) { return true; }

        // restoring the path that was before the move
        convert_solution_to_path(config, context);
    }

    return false;
}

int local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {
    // calculating current potentials for each edge
    for (int i = 0; i < config.cities_number; ++i) {
        for (int j = 0; j < config.cities_number; ++j) {
            calc_potential_inplace(config, context, i, j);
        }
    }

    // running simulations and trying to improve
    int improved_times = 0;

    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };

    return improved_times;
}
@@@

* include/additional.hpp *:
@@@
#pragma once


// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.
@@@

* TSP.cpp *:
@@@
// standart imports
#include <string>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>

// json imports
#include "include/json.hpp"

using json = nlohmann::json;
using namespace std::chrono;

// other imports
#include "include/context.hpp"
#include "include/utils.hpp"
#include "include/random_solution.hpp"
#include "include/local_2_opt_search.hpp"
#include "include/local_k_opt_search.hpp"

// additional functions & methods
#include "include/additional.hpp"


// --- config parameters ---
//   `cities_number`: number of points on the 2D surface.
//   `input_path`: path to the file with cities coordinates and the edge heat map.
//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.
//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.
//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.
//   `candidates_number`: number of candidate cities for each city.
//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.
//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).
//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).
//   `exploration_coefficient`: hyperparameter for exploration.
//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.
//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessfull simulation depending on the length of a chain.
//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.
//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).
//   `distance_type`: "int32", "int64" or "double".
//   `magnify_rate`: when `distance_type` is "int32" or "int64" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)


void read_input_data(const Config& config, Context& context) {
    std::ifstream input_file(config.input_path);

    int cities_number; input_file >> cities_number;

    // reading coordinates
    for (int i = 0; i < config.cities_number; ++i) {
        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];

        if (config.distance_type == DistanceType::Int32) {
            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);
            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);
        }
        if (config.distance_type == DistanceType::Int64) {
            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);
            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);
        }
    }

    // calculating distances
    for (int i = 0; i < config.cities_number; ++i) {
        for (int j = 0; j < config.cities_number; ++j) {
            context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);
            if (config.distance_type == DistanceType::Int32) {
                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);
            }
            if (config.distance_type == DistanceType::Int64) {
                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);
            }
        }
    }

    if (config.use_heat_map_as_initial_weights) {
        // reading heat map
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            input_file >> context.heat_map[i];
            context.weight[i] = context.heat_map[i];
        }
    } else {
        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {
            context.weight[i] = 0.0;
        }
    }

    // calculating candidates
        // Always use KNN for candidate selection based on recent research
        identify_candidates_for_each_node(config, context, context.distance_double, false);
}


void solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution
    // initialization
    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;
    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;

    int max_k_opt_depth = config.max_k_opt_depth;

    // --- Compute bounding box to parameterize BHH target E[L_n] ≈ β * sqrt(n * A) ---
    // β ≈ 0.7120 (BHH_CONSTANT_2D), A = (max_x - min_x) * (max_y - min_y)
    double min_x = std::numeric_limits<double>::infinity();
    double max_x = -std::numeric_limits<double>::infinity();
    double min_y = std::numeric_limits<double>::infinity();
    double max_y = -std::numeric_limits<double>::infinity();
    for (int i = 0; i < config.cities_number; ++i) {
        min_x = std::min(min_x, context.coordinates_double_x[i]);
        max_x = std::max(max_x, context.coordinates_double_x[i]);
        min_y = std::min(min_y, context.coordinates_double_y[i]);
        max_y = std::max(max_y, context.coordinates_double_y[i]);
    }
    double width = std::max(1e-12, max_x - min_x);
    double height = std::max(1e-12, max_y - min_y);
    const double bhh_target = expected_tsp_length_2d(static_cast<long long>(config.cities_number), width, height) * 1.07; // 7% slack

    // Stagnation early stop: break if no best improvement for too long.
    const int no_improve_limit = std::max(50, config.restarts_number / 5);
    double last_best = inf_double;
    int stale_iters = 0;

    for (int i = 1; i < config.restarts_number + 1; ++i) {
        if (i % 100 == 0) { std::cout << "# --------- Iteration: " << i << '\n'; }
        int improved_times = 0;

        // Phase #1: strong initializer
        start_time = high_resolution_clock::now();
        generate_random_solution(config, context);
        convert_solution_to_path(config, context);
        end_time = high_resolution_clock::now();

        calc_and_save_total_distance(config, context);
        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) {
            std::cout << std::setprecision(8)
                      << "Phase #1 (random cycle). Total distance: " << context.path_distance_double
                      << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n";
        }

        // Phase #2: 2-opt
        start_time = high_resolution_clock::now();
        improved_times = local_2_opt_search(config, context);
        end_time = high_resolution_clock::now();

        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) {
            std::cout << std::setprecision(8)
                      << "Phase #2 (local 2'opt search). Total distance: " << context.path_distance_double
                      << ", Improved times: " << improved_times
                      << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n";
        }

        // Phase #3: k-opt simulations (UCB-guided)
        start_time = high_resolution_clock::now();
        improved_times = local_k_opt_search(config, context, max_k_opt_depth);
        end_time = high_resolution_clock::now();

        if (config.distance_type != DistanceType::Double) {
            context.path_distance_double = calc_total_distance_double(config, context);
        }
        if (i % 100 == 0) {
            std::cout << std::setprecision(8)
                      << "Phase #3 (local k'opt search). Total distance: " << context.path_distance_double
                      << ", Improved times: " << improved_times
                      << ", Time: " << duration_cast<milliseconds>(end_time - start_time).count() << " ms\n";
        }

        // Track the best path found so far
        if (
            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||
            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||
            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)
        ) {
            store_path_as_best(config, context);
        }

        // --- Adaptive k depth ---
        if (config.random_k_opt_depth_after_first_iteration) {
            int base_depth = std::min(5 + (rand() % 15), config.cities_number / 4);
            double progress = static_cast<double>(i) / config.restarts_number;
            max_k_opt_depth = base_depth + static_cast<int>(progress * config.cities_number / 8);
            max_k_opt_depth = std::min(max_k_opt_depth, config.cities_number / 2);
        }

        // --- Early stopping: BHH-guided target OR stagnation ---
        double best_now = context.path_distance_double;
        if (config.distance_type == DistanceType::Double) {
            best_now = std::min(best_now, context.best_path_distance_double);
        }

        if (best_now + 1e-12 < last_best) {
            last_best = best_now;
            stale_iters = 0;
        } else {
            ++stale_iters;
        }

        if (best_now <= bhh_target || stale_iters >= no_improve_limit) {
            if (i % 100 != 0) { std::cout << "# --------- Iteration: " << i << '\n'; }
            std::cout << "Stopping early: "
                      << (best_now <= bhh_target ? "BHH target reached." : "stagnation threshold reached.")
                      << "\n\n";
            break;
        }

        if (i % 100 == 0) { std::cout << '\n'; }
    }

    // final convertation (context.best_path to context.solution)
    restore_best_path(config, context);
    convert_path_to_solution(config, context);

    end_total_time = high_resolution_clock::now();
    std::cout << "Total elapsed time: " << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << " sec\n\n";
}


int main(int argc, char** argv) {
    // reading configuration
    std::cout << "Reading configuration...\n";
    if (argc != 2) {
        std::cerr << "Usage: The first and only argument should be the path to the config file.";
        return 1;
    }
    
    std::ifstream config_file(argv[1]);
    json config_raw; config_file >> config_raw;
    Config config(config_raw);

    std::cout << "Number of cities: " << config.cities_number << "\n\n";

    // initialization & memory allocation
    Context context(config);

    // reading input data
    std::cout << "Reading input data...\n";
    read_input_data(config, context);

    // solving
    std::cout << "Solving...\n";
    solve(config, context);

    // printing the solution
    std::ofstream output_file(config.output_path);

    std::cout << "Final solution:\n";
    for (int i = 0; i < config.cities_number; ++i) {
        std::cout << context.solution[i] << ' ';
        output_file << context.solution[i] << ' ';
    }
    std::cout << "\n\nFinal solution score: " << calc_total_distance_double(config, context) << '\n';

    return 0;
}
@@@

* config.json *:
@@@
{
    "cities_number": 200,
    "input_path": "/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_input.txt",
    "output_path": "/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_output.txt",
    "use_heat_map_as_initial_weights": true,
    "candidates_source": "knn",
    "candidates_number": 24,
    "max_k_opt_depth": 48,
    "random_k_opt_depth_after_first_iteration": true,
    "min_potential_to_consider": 0.0,
    "exploration_coefficient": 0.5,
    "weight_delta_coefficient": 3.0,
    "sensitivity_temperature": 2.0,
    "max_k_opt_simulations_without_improve_to_stop": 150,
    "restarts_number": 600,
    "distance_type": "double",
    "magnify_rate": 1000000
}
@@@