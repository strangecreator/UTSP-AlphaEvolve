{"id": "a5f4bcec-1934-4fcb-b75b-4b4377fbd140", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 5 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value <= 0) return 0LL;  // clamp negatives to 0\n    if (value < 2) return value;\n\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\n\n    long long left = 1;\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\n    long long floor_root = 1;\n\n    while (left <= right) {\n        long long candidate = left + (right - left) / 2;\n\n        if (candidate <= value / candidate) {\n            floor_root = candidate;\n            left = candidate + 1;\n        } else {\n            right = candidate - 1;\n        }\n    }\n    return floor_root;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // 0..n-1\n\n        // Partition so first K are the best candidates\u2026\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n        // \u2026then sort those K so we iterate nearest-first in local search.\n        std::sort(context.buffer.begin(), context.buffer.begin() + config.candidates_number, [&](int u, int v) {\n            if (i == u) return false;\n            if (i == v) return true;\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n    if (mod <= 0) return 0;\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\t// GRASP-style KNN constructor with multi-start and distance-biased sampling.\n\t// Builds several candidate tours and keeps the best (shortest) one.\n\t// This yields far better starting tours than pure random chains,\n\t// cutting downstream 2-opt/k-opt time and improving final quality.\n\n\tconst int n = config.cities_number;\n\tconst int starts = 4;                 // multi-start count (cheap, n=200)\n\tconst int topL  = std::min(8, config.candidates_number);  // RCL cap\n\tconst double eps = 1e-12;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n\tdouble best_len = std::numeric_limits<double>::infinity();\n\tstd::vector<int> best_sol(n);\n\n\tfor (int s = 0; s < starts; ++s) {\n\t\tstd::vector<int> sol(n, null);\n\t\tstd::vector<char> used(n, 0);\n\n\t\tint current = select_random_city(config, context);\n\t\tsol[0] = current;\n\t\tused[current] = 1;\n\t\tdouble len = 0.0;\n\n\t\tfor (int pos = 1; pos < n; ++pos) {\n\t\t\t// Build restricted candidate list (up to topL nearest unvisited from KNN)\n\t\t\tint rcl_idx[8];\n\t\t\tdouble rcl_dist[8];\n\t\t\tint rsz = 0;\n\n\t\t\tfor (int t = 0; t < config.candidates_number; ++t) {\n\t\t\t\tint cand = context.candidates[current * config.candidates_number + t];\n\t\t\t\tif (cand == current || used[cand]) continue;\n\n\t\t\t\tdouble d = get_distance_double(config, context, current, cand);\n\n\t\t\t\t// keep a sorted list of size<=topL by distance\n\t\t\t\tif (rsz < topL) {\n\t\t\t\t\trcl_idx[rsz] = cand;\n\t\t\t\t\trcl_dist[rsz] = d;\n\t\t\t\t\t++rsz;\n\n\t\t\t\t\tfor (int k = rsz - 1; k > 0; --k) {\n\t\t\t\t\t\tif (rcl_dist[k] < rcl_dist[k - 1]) {\n\t\t\t\t\t\t\tstd::swap(rcl_dist[k], rcl_dist[k - 1]);\n\t\t\t\t\t\t\tstd::swap(rcl_idx[k], rcl_idx[k - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (d < rcl_dist[rsz - 1]) {\n\t\t\t\t\trcl_dist[rsz - 1] = d;\n\t\t\t\t\trcl_idx[rsz - 1] = cand;\n\t\t\t\t\tfor (int k = rsz - 1; k > 0; --k) {\n\t\t\t\t\t\tif (rcl_dist[k] < rcl_dist[k - 1]) {\n\t\t\t\t\t\t\tstd::swap(rcl_dist[k], rcl_dist[k - 1]);\n\t\t\t\t\t\t\tstd::swap(rcl_idx[k], rcl_idx[k - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint next_city = null;\n\t\t\tif (rsz > 0) {\n\t\t\t\t// Distance-biased roulette: p \u221d 1 / d\n\t\t\t\tdouble wsum = 0.0;\n\t\t\t\tfor (int k = 0; k < rsz; ++k) wsum += 1.0 / (rcl_dist[k] + eps);\n\t\t\t\tdouble r = (static_cast<double>(rand()) / RAND_MAX) * wsum;\n\t\t\t\tfor (int k = 0; k < rsz; ++k) {\n\t\t\t\t\tr -= 1.0 / (rcl_dist[k] + eps);\n\t\t\t\t\tif (r <= 0.0) { next_city = rcl_idx[k]; break; }\n\t\t\t\t}\n\t\t\t\tif (next_city == null) next_city = rcl_idx[rsz - 1]; // numeric fallback\n\t\t\t} else {\n\t\t\t\t// Fallback: global nearest unvisited\n\t\t\t\tdouble best_d = std::numeric_limits<double>::infinity();\n\t\t\t\tfor (int cand = 0; cand < n; ++cand) {\n\t\t\t\t\tif (used[cand]) continue;\n\t\t\t\t\tdouble d = get_distance_double(config, context, current, cand);\n\t\t\t\t\tif (d < best_d) { best_d = d; next_city = cand; }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen += get_distance_double(config, context, current, next_city);\n\t\t\tcurrent = next_city;\n\t\t\tsol[pos] = current;\n\t\t\tused[current] = 1;\n\t\t}\n\t\t// close the tour\n\t\tlen += get_distance_double(config, context, sol[n - 1], sol[0]);\n\n\t\tif (len < best_len) {\n\t\t\tbest_len = len;\n\t\t\tbest_sol = sol;\n\t\t}\n\t}\n\n\t// output the best found start\n\tfor (int i = 0; i < n; ++i) context.solution[i] = best_sol[i];\n\tfor (int i = 0; i < n; ++i) context.is_city_selected[i] = false; // clean flags\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n\tint j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n\t++context.chosen_times[j * config.cities_number + i];\n\t++context.chosen_times[i_next * config.cities_number + j_next];\n\t++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, delta / context.path_distance_double) - 1);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int32) - 1);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int64) - 1);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        context.weight[i * config.cities_number + j] += weight_increase;\n        context.weight[j * config.cities_number + i] += weight_increase;\n        context.weight[i_next * config.cities_number + j_next] += weight_increase;\n        context.weight[j_next * config.cities_number + i_next] += weight_increase;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\n\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\n\t\t}\n\t}\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    double weight = context.weight[i * config.cities_number + j];\n\n    // this forms a smooth ReLU function\n    if (weight < 0) { weight = pow(e, weight); }\n    else { weight += 1.0; }\n\n    context.potential[i * config.cities_number + j] = weight + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, gain_double_with_closure / context.path_distance_double) - 1);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int32_with_closure) / context.path_distance_int32) - 1);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int64_with_closure) / context.path_distance_int64) - 1);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    // updating weights\n    for (int i = 0; i < depth; ++i) {\n        int current_city = context.pairs[2 * i];\n        int proposed_city = (i < depth - 1) ? context.pairs[2 * i + 2] : start_city;\n\n        double factor = 1.0;\n        if (!apply_move) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        context.weight[current_city * config.cities_number + proposed_city] += weight_increase * factor;\n        context.weight[proposed_city * config.cities_number + current_city] += weight_increase * factor;\n    }\n\n    if (apply_move) {\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) { return true; }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    return false;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {\n    // calculating current potentials only for candidate edges (O(n*k) vs O(n^2))\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int t = 0; t < config.candidates_number; ++t) {\n            int j = context.candidates[i * config.candidates_number + t];\n            calc_potential_inplace(config, context, i, j);\n        }\n        // self-potential is zero; prevents accidental self-selection\n        context.potential[i * config.cities_number + i] = 0.0;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessfull simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int j = 0; j < config.cities_number; ++j) {\n            context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            if (config.distance_type == DistanceType::Int32) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n    // BHH-based early stopping threshold: E[L*_n] \u2248 \u03b2_2 sqrt(n * area), \u03b2_2 \u2248 0.7120\n    double min_x = context.coordinates_double_x[0], max_x = context.coordinates_double_x[0];\n    double min_y = context.coordinates_double_y[0], max_y = context.coordinates_double_y[0];\n    for (int p = 1; p < config.cities_number; ++p) {\n        if (context.coordinates_double_x[p] < min_x) min_x = context.coordinates_double_x[p];\n        if (context.coordinates_double_x[p] > max_x) max_x = context.coordinates_double_x[p];\n        if (context.coordinates_double_y[p] < min_y) min_y = context.coordinates_double_y[p];\n        if (context.coordinates_double_y[p] > max_y) max_y = context.coordinates_double_y[p];\n    }\n    double width = std::max(1e-12, max_x - min_x);\n    double height = std::max(1e-12, max_y - min_y);\n    const double bhh_target = expected_tsp_length_2d(config.cities_number, width, height);\n    const double stop_threshold = bhh_target * 1.03; // 3% above expectation\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times_2opt = 0;\n        int improved_times_kopt = 0;\n\n        // random solution\n        start_time = high_resolution_clock::now();\n        generate_random_solution(config, context);\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times_2opt = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_2opt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times_kopt = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_kopt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stop when close to BHH expectation (saves a lot of wall-clock without hurting quality on uniform inputs)\n        if (context.best_path_distance_double <= stop_threshold) {\n            if (i % 100 == 0) { std::cout << \"Early stop: reached BHH threshold \" << stop_threshold << \"\\n\"; }\n            break;\n        }\n\n        // Adaptive k depth: expand if k-opt stagnates, contract if it finds small gains.\n        if (i > 1) {\n            if (improved_times_kopt == 0) {\n                max_k_opt_depth = std::min(max_k_opt_depth + 8, config.cities_number / 2);\n            } else if (improved_times_kopt < 5) {\n                max_k_opt_depth = std::max(12, max_k_opt_depth - 4);\n            }\n        }\n        // When close to BHH expectation, cap depth to save wall-clock.\n        if (context.path_distance_double <= bhh_target * 1.06) {\n            if (max_k_opt_depth > 24) max_k_opt_depth = 24;\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 200,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_output.txt\",\n    \"use_heat_map_as_initial_weights\": true,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 32,\n    \"max_k_opt_depth\": 89,\n    \"random_k_opt_depth_after_first_iteration\": false,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.50,\n    \"weight_delta_coefficient\": 6.0,\n    \"sensitivity_temperature\": 1.6,\n    \"max_k_opt_simulations_without_improve_to_stop\": 150,\n    \"restarts_number\": 750,\n    \"distance_type\": \"double\",\n    \"magnify_rate\": 1000000\n}\n@@@", "language": "python", "parent_id": "cec28e59-3803-4520-8f69-35900f2f07b5", "generation": 2, "timestamp": 1759949242.20343, "iteration_found": 4, "metrics": {"heat_map_train_time_elapsed": 0.8015841250307858, "average_heat_map_inference_time_elapsed": 1.0908891959488756, "average_tsp_run_time_elapsed": 5.288773715580646, "average_path_length": 11.143734809999781, "path_length_variance": 0.04908806638280791, "combined_score": 0.003269996953802929}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 63 lines with 103 lines\nChange 2: Replace 15 lines with 22 lines\nChange 3: Replace int improved_times = 0; with 2 lines\nChange 4: 'improved_times = local_2_opt_search(config, context);' to 'improved_times_2opt = local_2_opt_search(config, context);'\nChange 5: 'if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }' to 'if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_2opt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }'\nChange 6: 'improved_times = local_k_opt_search(config, context, max_k_opt_depth);' to 'improved_times_kopt = local_k_opt_search(config, context, max_k_opt_depth);'\nChange 7: 'if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }' to 'if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_kopt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }'\nChange 8: Replace 4 lines with 12 lines\nChange 9: '\"candidates_number\": 24,' to '\"candidates_number\": 32,'\nChange 10: '\"random_k_opt_depth_after_first_iteration\": true,' to '\"random_k_opt_depth_after_first_iteration\": false,'\nChange 11: '\"exploration_coefficient\": 0.35,' to '\"exploration_coefficient\": 0.50,'\nChange 12: '\"weight_delta_coefficient\": 10.0,' to '\"weight_delta_coefficient\": 6.0,'\nChange 13: '\"sensitivity_temperature\": 1.0,' to '\"sensitivity_temperature\": 1.6,'\nChange 14: '\"distance_type\": \"int64\",' to '\"distance_type\": \"double\",'", "parent_metrics": {"heat_map_train_time_elapsed": 0.7773003340116702, "average_heat_map_inference_time_elapsed": 1.1500401139910537, "average_tsp_run_time_elapsed": 2.787078693969306, "average_path_length": 11.137769974769608, "path_length_variance": 0.05164468010579598, "combined_score": 0.010685526992581962}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution.\n", "user": "# Current Program Information\n- Fitness: 0.0107\n- Feature coordinates: No feature coordinates\n- Focus areas: - Focus on improving fitness while maintaining diversity\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 200\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (random cycle). Total distance: 21.582701, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 11.889548, Improved times: 246, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 11.889548, Improved times: 0, Time: 3 ms\n\n# --------- Iteration: 200\nPhase #1 (random cycle). Total distance: 23.21438, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 11.985349, Improved times: 268, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 11.985349, Improved times: 0, Time: 3 ms\n\n# --------- Iteration: 300\nPhase #1 (random cycle). Total distance: 21.23699, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 11.908971, Improved times: 247, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 11.908971, Improved times: 0, Time: 1 ms\n\n# --------- Iteration: 400\nPhase #1 (random cycle). Total distance: 21.857294, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 11.869873, Improved times: 291, Time: 3 ms\nPhase #3 (local k'opt search). Total distance: 11.869873, Improved times: 0, Time: 0 ms\n\n# --------- Iteration: 500\nPhase #1 (random cycle). Total distance: 20.598264, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 12.151384, Improved times: 171, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 12.130358, Improved times: 1, Time: 2 ms\n\n# --------- Iteration: 600\nPhase #1 (random cycle). Total distance: 20.349638, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 12.315906, Improved times: 242, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 12.315906, Improved times: 0, Time: 2 ms\n\n# --------- Iteration: 700\nPhase #1 (random cycle). Total distance: 20.098896, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 11.75948, Improved times: 231, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 11.75948, Improved times: 0, Time: 1 ms\n\nTotal elapsed time: 2.698 sec\n\nFinal solution:\n0 19 15 173 4 37 125 67 76 138 25 28 120 34 102 94 95 45 85 9 36 13 57 42 33 177 142 128 167 133 195 31 106 48 7 132 30 27 174 56 14 46 99 180 127 117 26 163 23 52 55 49 32 75 188 61 178 81 39 60 90 82 151 122 3 108 22 140 159 47 24 54 183 64 6 91 59 105 73 93 187 153 87 150 145 77 131 8 137 84 43 170 10 168 12 119 53 86 143 65 192 176 147 41 136 179 161 44 116 160 149 96 118 1 89 139 35 191 146 141 18 184 123 51 40 100 129 165 193 158 175 196 104 79 101 194 62 78 155 80 162 186 199 113 69 157 156 71 98 21 144 171 103 190 17 130 115 88 109 97 66 148 164 189 16 172 110 181 111 11 50 74 185 182 124 70 83 198 5 197 29 63 166 2 126 134 72 121 135 154 114 20 107 169 92 58 112 38 152 68 \n\nFinal solution score: 11.19073\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n# Program Evolution History\n## Previous Attempts\n\n\n\n## Top Performing Programs\n\n\n\n\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 5 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value <= 0) return 0LL;  // clamp negatives to 0\n    if (value < 2) return value;\n\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\n\n    long long left = 1;\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\n    long long floor_root = 1;\n\n    while (left <= right) {\n        long long candidate = left + (right - left) / 2;\n\n        if (candidate <= value / candidate) {\n            floor_root = candidate;\n            left = candidate + 1;\n        } else {\n            right = candidate - 1;\n        }\n    }\n    return floor_root;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n    if (mod <= 0) return 0;\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\t// Randomized KNN-chain initialization:\n\t// start at a random city, then repeatedly pick the next city from the KNN\n\t// of the current city (choose among the 3 nearest unvisited at random).\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    int current = select_random_city(config, context);\n    for (int pos = 0; pos < config.cities_number; ++pos) {\n        // place current\n        context.solution[pos] = current;\n        context.is_city_selected[current] = true;\n\n        // choose next\n        int rcl_idx[3];      // indices of restricted candidate list\n        double rcl_dist[3];  // distances for ordering\n        int rcl_size = 0;\n\n        for (int t = 0; t < config.candidates_number; ++t) {\n            int cand = context.candidates[current * config.candidates_number + t];\n            if (cand == current || context.is_city_selected[cand]) continue;\n\n            double d = get_distance_double(config, context, current, cand);\n\n            // insert into top-3 by distance\n            if (rcl_size < 3) {\n                rcl_idx[rcl_size] = cand;\n                rcl_dist[rcl_size] = d;\n                ++rcl_size;\n\n                // simple insertion sort for size<=3\n                for (int k = rcl_size - 1; k > 0; --k) {\n                    if (rcl_dist[k] < rcl_dist[k - 1]) {\n                        std::swap(rcl_dist[k], rcl_dist[k - 1]);\n                        std::swap(rcl_idx[k], rcl_idx[k - 1]);\n                    }\n                }\n            } else if (d < rcl_dist[rcl_size - 1]) {\n                rcl_dist[rcl_size - 1] = d;\n                rcl_idx[rcl_size - 1] = cand;\n                // maintain order\n                for (int k = rcl_size - 1; k > 0; --k) {\n                    if (rcl_dist[k] < rcl_dist[k - 1]) {\n                        std::swap(rcl_dist[k], rcl_dist[k - 1]);\n                        std::swap(rcl_idx[k], rcl_idx[k - 1]);\n                    }\n                }\n            }\n        }\n\n        int next_city = null;\n        if (rcl_size > 0) {\n            next_city = rcl_idx[get_random_int_by_module(rcl_size)];\n        } else {\n            // fallback: pick any unvisited city at random\n            next_city = select_random_city(config, context);\n        }\n\n        current = next_city == null ? current : next_city;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n\tint j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n\t++context.chosen_times[j * config.cities_number + i];\n\t++context.chosen_times[i_next * config.cities_number + j_next];\n\t++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, delta / context.path_distance_double) - 1);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int32) - 1);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(delta) / context.path_distance_int64) - 1);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        context.weight[i * config.cities_number + j] += weight_increase;\n        context.weight[j * config.cities_number + i] += weight_increase;\n        context.weight[i_next * config.cities_number + j_next] += weight_increase;\n        context.weight[j_next * config.cities_number + i_next] += weight_increase;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\n\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\n\t\t}\n\t}\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    double weight = context.weight[i * config.cities_number + j];\n\n    // this forms a smooth ReLU function\n    if (weight < 0) { weight = pow(e, weight); }\n    else { weight += 1.0; }\n\n    context.potential[i * config.cities_number + j] = weight + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, gain_double_with_closure / context.path_distance_double) - 1);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int32_with_closure) / context.path_distance_int32) - 1);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            weight_increase = config.weight_delta_coefficient * (pow(e, static_cast<double>(gain_int64_with_closure) / context.path_distance_int64) - 1);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    // updating weights\n    for (int i = 0; i < depth; ++i) {\n        int current_city = context.pairs[2 * i];\n        int proposed_city = (i < depth - 1) ? context.pairs[2 * i + 2] : start_city;\n\n        double factor = 1.0;\n        if (!apply_move) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        context.weight[current_city * config.cities_number + proposed_city] += weight_increase * factor;\n        context.weight[proposed_city * config.cities_number + current_city] += weight_increase * factor;\n    }\n\n    if (apply_move) {\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) { return true; }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    return false;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {\n    // calculating current potentials only for candidate edges (O(n*k) vs O(n^2))\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int t = 0; t < config.candidates_number; ++t) {\n            int j = context.candidates[i * config.candidates_number + t];\n            calc_potential_inplace(config, context, i, j);\n        }\n        // self-potential is zero; prevents accidental self-selection\n        context.potential[i * config.cities_number + i] = 0.0;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessfull simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int j = 0; j < config.cities_number; ++j) {\n            context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            if (config.distance_type == DistanceType::Int32) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n    // BHH-based early stopping threshold: E[L*_n] \u2248 \u03b2_2 sqrt(n * area), \u03b2_2 \u2248 0.7120\n    double min_x = context.coordinates_double_x[0], max_x = context.coordinates_double_x[0];\n    double min_y = context.coordinates_double_y[0], max_y = context.coordinates_double_y[0];\n    for (int p = 1; p < config.cities_number; ++p) {\n        if (context.coordinates_double_x[p] < min_x) min_x = context.coordinates_double_x[p];\n        if (context.coordinates_double_x[p] > max_x) max_x = context.coordinates_double_x[p];\n        if (context.coordinates_double_y[p] < min_y) min_y = context.coordinates_double_y[p];\n        if (context.coordinates_double_y[p] > max_y) max_y = context.coordinates_double_y[p];\n    }\n    double width = std::max(1e-12, max_x - min_x);\n    double height = std::max(1e-12, max_y - min_y);\n    const double bhh_target = expected_tsp_length_2d(config.cities_number, width, height);\n    const double stop_threshold = bhh_target * 1.03; // 3% above expectation\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // random solution\n        start_time = high_resolution_clock::now();\n        generate_random_solution(config, context);\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stop when close to BHH expectation (saves a lot of wall-clock without hurting quality on uniform inputs)\n        if (context.best_path_distance_double <= stop_threshold) {\n            if (i % 100 == 0) { std::cout << \"Early stop: reached BHH threshold \" << stop_threshold << \"\\n\"; }\n            break;\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 200,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/UTSP/sample_output.txt\",\n    \"use_heat_map_as_initial_weights\": true,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 24,\n    \"max_k_opt_depth\": 89,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.35,\n    \"weight_delta_coefficient\": 10.0,\n    \"sensitivity_temperature\": 1.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 150,\n    \"restarts_number\": 750,\n    \"distance_type\": \"int64\",\n    \"magnify_rate\": 1000000\n}\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["Here are targeted, **parseable** diffs that improve both tour quality and runtime by (1) building *much better initial tours* via a GRASP-style biased KNN constructor with multi-start, (2) making 2-opt/k-opt progress tracking drive an *adaptive k* (no more random depth), (3) prioritizing closer candidates earlier by **sorting the KNN list**, and (4) tweaking config for better numerical fidelity and exploration.\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nvoid generate_random_solution(const Config& config, Context& context) {\r\n\t// Randomized KNN-chain initialization:\r\n\t// start at a random city, then repeatedly pick the next city from the KNN\r\n\t// of the current city (choose among the 3 nearest unvisited at random).\r\n\tfor (int i = 0; i < config.cities_number; ++i) {\r\n\t\tcontext.solution[i] = null;\r\n\t\tcontext.is_city_selected[i] = false;\r\n\t}\r\n\r\n    int current = select_random_city(config, context);\r\n    for (int pos = 0; pos < config.cities_number; ++pos) {\r\n        // place current\r\n        context.solution[pos] = current;\r\n        context.is_city_selected[current] = true;\r\n\r\n        // choose next\r\n        int rcl_idx[3];      // indices of restricted candidate list\r\n        double rcl_dist[3];  // distances for ordering\r\n        int rcl_size = 0;\r\n\r\n        for (int t = 0; t < config.candidates_number; ++t) {\r\n            int cand = context.candidates[current * config.candidates_number + t];\r\n            if (cand == current || context.is_city_selected[cand]) continue;\r\n\r\n            double d = get_distance_double(config, context, current, cand);\r\n\r\n            // insert into top-3 by distance\r\n            if (rcl_size < 3) {\r\n                rcl_idx[rcl_size] = cand;\r\n                rcl_dist[rcl_size] = d;\r\n                ++rcl_size;\r\n\r\n                // simple insertion sort for size<=3\r\n                for (int k = rcl_size - 1; k > 0; --k) {\r\n                    if (rcl_dist[k] < rcl_dist[k - 1]) {\r\n                        std::swap(rcl_dist[k], rcl_dist[k - 1]);\r\n                        std::swap(rcl_idx[k], rcl_idx[k - 1]);\r\n                    }\r\n                }\r\n            } else if (d < rcl_dist[rcl_size - 1]) {\r\n                rcl_dist[rcl_size - 1] = d;\r\n                rcl_idx[rcl_size - 1] = cand;\r\n                // maintain order\r\n                for (int k = rcl_size - 1; k > 0; --k) {\r\n                    if (rcl_dist[k] < rcl_dist[k - 1]) {\r\n                        std::swap(rcl_dist[k], rcl_dist[k - 1]);\r\n                        std::swap(rcl_idx[k], rcl_idx[k - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        int next_city = null;\r\n        if (rcl_size > 0) {\r\n            next_city = rcl_idx[get_random_int_by_module(rcl_size)];\r\n        } else {\r\n            // fallback: pick any unvisited city at random\r\n            next_city = select_random_city(config, context);\r\n        }\r\n\r\n        current = next_city == null ? current : next_city;\r\n    }\r\n}\r\n=======\r\nvoid generate_random_solution(const Config& config, Context& context) {\r\n\t// GRASP-style KNN constructor with multi-start and distance-biased sampling.\r\n\t// Builds several candidate tours and keeps the best (shortest) one.\r\n\t// This yields far better starting tours than pure random chains,\r\n\t// cutting downstream 2-opt/k-opt time and improving final quality.\r\n\r\n\tconst int n = config.cities_number;\r\n\tconst int starts = 4;                 // multi-start count (cheap, n=200)\r\n\tconst int topL  = std::min(8, config.candidates_number);  // RCL cap\r\n\tconst double eps = 1e-12;\r\n\r\n\tfor (int i = 0; i < n; ++i) {\r\n\t\tcontext.solution[i] = null;\r\n\t\tcontext.is_city_selected[i] = false;\r\n\t}\r\n\r\n\tdouble best_len = std::numeric_limits<double>::infinity();\r\n\tstd::vector<int> best_sol(n);\r\n\r\n\tfor (int s = 0; s < starts; ++s) {\r\n\t\tstd::vector<int> sol(n, null);\r\n\t\tstd::vector<char> used(n, 0);\r\n\r\n\t\tint current = select_random_city(config, context);\r\n\t\tsol[0] = current;\r\n\t\tused[current] = 1;\r\n\t\tdouble len = 0.0;\r\n\r\n\t\tfor (int pos = 1; pos < n; ++pos) {\r\n\t\t\t// Build restricted candidate list (up to topL nearest unvisited from KNN)\r\n\t\t\tint rcl_idx[8];\r\n\t\t\tdouble rcl_dist[8];\r\n\t\t\tint rsz = 0;\r\n\r\n\t\t\tfor (int t = 0; t < config.candidates_number; ++t) {\r\n\t\t\t\tint cand = context.candidates[current * config.candidates_number + t];\r\n\t\t\t\tif (cand == current || used[cand]) continue;\r\n\r\n\t\t\t\tdouble d = get_distance_double(config, context, current, cand);\r\n\r\n\t\t\t\t// keep a sorted list of size<=topL by distance\r\n\t\t\t\tif (rsz < topL) {\r\n\t\t\t\t\trcl_idx[rsz] = cand;\r\n\t\t\t\t\trcl_dist[rsz] = d;\r\n\t\t\t\t\t++rsz;\r\n\r\n\t\t\t\t\tfor (int k = rsz - 1; k > 0; --k) {\r\n\t\t\t\t\t\tif (rcl_dist[k] < rcl_dist[k - 1]) {\r\n\t\t\t\t\t\t\tstd::swap(rcl_dist[k], rcl_dist[k - 1]);\r\n\t\t\t\t\t\t\tstd::swap(rcl_idx[k], rcl_idx[k - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (d < rcl_dist[rsz - 1]) {\r\n\t\t\t\t\trcl_dist[rsz - 1] = d;\r\n\t\t\t\t\trcl_idx[rsz - 1] = cand;\r\n\t\t\t\t\tfor (int k = rsz - 1; k > 0; --k) {\r\n\t\t\t\t\t\tif (rcl_dist[k] < rcl_dist[k - 1]) {\r\n\t\t\t\t\t\t\tstd::swap(rcl_dist[k], rcl_dist[k - 1]);\r\n\t\t\t\t\t\t\tstd::swap(rcl_idx[k], rcl_idx[k - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint next_city = null;\r\n\t\t\tif (rsz > 0) {\r\n\t\t\t\t// Distance-biased roulette: p \u221d 1 / d\r\n\t\t\t\tdouble wsum = 0.0;\r\n\t\t\t\tfor (int k = 0; k < rsz; ++k) wsum += 1.0 / (rcl_dist[k] + eps);\r\n\t\t\t\tdouble r = (static_cast<double>(rand()) / RAND_MAX) * wsum;\r\n\t\t\t\tfor (int k = 0; k < rsz; ++k) {\r\n\t\t\t\t\tr -= 1.0 / (rcl_dist[k] + eps);\r\n\t\t\t\t\tif (r <= 0.0) { next_city = rcl_idx[k]; break; }\r\n\t\t\t\t}\r\n\t\t\t\tif (next_city == null) next_city = rcl_idx[rsz - 1]; // numeric fallback\r\n\t\t\t} else {\r\n\t\t\t\t// Fallback: global nearest unvisited\r\n\t\t\t\tdouble best_d = std::numeric_limits<double>::infinity();\r\n\t\t\t\tfor (int cand = 0; cand < n; ++cand) {\r\n\t\t\t\t\tif (used[cand]) continue;\r\n\t\t\t\t\tdouble d = get_distance_double(config, context, current, cand);\r\n\t\t\t\t\tif (d < best_d) { best_d = d; next_city = cand; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlen += get_distance_double(config, context, current, next_city);\r\n\t\t\tcurrent = next_city;\r\n\t\t\tsol[pos] = current;\r\n\t\t\tused[current] = 1;\r\n\t\t}\r\n\t\t// close the tour\r\n\t\tlen += get_distance_double(config, context, sol[n - 1], sol[0]);\r\n\r\n\t\tif (len < best_len) {\r\n\t\t\tbest_len = len;\r\n\t\t\tbest_sol = sol;\r\n\t\t}\r\n\t}\r\n\r\n\t// output the best found start\r\n\tfor (int i = 0; i < n; ++i) context.solution[i] = best_sol[i];\r\n\tfor (int i = 0; i < n; ++i) context.is_city_selected[i] = false; // clean flags\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\r\n\tfor (int i = 0; i < config.cities_number; ++i) {\r\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\r\n\r\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\r\n            if (i == u) { return false; }\r\n            if (i == v) { return true; }\r\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\r\n        });\r\n\t\t\r\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\r\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\r\n\t    }\r\n\t}\r\n}\r\n=======\r\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\r\n\tfor (int i = 0; i < config.cities_number; ++i) {\r\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // 0..n-1\r\n\r\n        // Partition so first K are the best candidates\u2026\r\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\r\n            if (i == u) { return false; }\r\n            if (i == v) { return true; }\r\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\r\n        });\r\n        // \u2026then sort those K so we iterate nearest-first in local search.\r\n        std::sort(context.buffer.begin(), context.buffer.begin() + config.candidates_number, [&](int u, int v) {\r\n            if (i == u) return false;\r\n            if (i == v) return true;\r\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\r\n        });\r\n\r\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\r\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\r\n\t    }\r\n\t}\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        int improved_times = 0;\r\n=======\r\n        int improved_times_2opt = 0;\r\n        int improved_times_kopt = 0;\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n\t\timproved_times = local_2_opt_search(config, context);\r\n=======\r\n\t\timproved_times_2opt = local_2_opt_search(config, context);\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n=======\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_2opt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\r\n=======\r\n\t\timproved_times_kopt = local_k_opt_search(config, context, max_k_opt_depth);\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n=======\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times_kopt << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        if (config.random_k_opt_depth_after_first_iteration) {\r\n            // random MCTS depth change\r\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\r\n        }\r\n=======\r\n        // Adaptive k depth: expand if k-opt stagnates, contract if it finds small gains.\r\n        if (i > 1) {\r\n            if (improved_times_kopt == 0) {\r\n                max_k_opt_depth = std::min(max_k_opt_depth + 8, config.cities_number / 2);\r\n            } else if (improved_times_kopt < 5) {\r\n                max_k_opt_depth = std::max(12, max_k_opt_depth - 4);\r\n            }\r\n        }\r\n        // When close to BHH expectation, cap depth to save wall-clock.\r\n        if (context.path_distance_double <= bhh_target * 1.06) {\r\n            if (max_k_opt_depth > 24) max_k_opt_depth = 24;\r\n        }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"candidates_number\": 24,\r\n=======\r\n    \"candidates_number\": 32,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n=======\r\n    \"random_k_opt_depth_after_first_iteration\": false,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"exploration_coefficient\": 0.35,\r\n=======\r\n    \"exploration_coefficient\": 0.50,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"weight_delta_coefficient\": 10.0,\r\n=======\r\n    \"weight_delta_coefficient\": 6.0,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"sensitivity_temperature\": 1.0,\r\n=======\r\n    \"sensitivity_temperature\": 1.6,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"distance_type\": \"int64\",\r\n=======\r\n    \"distance_type\": \"double\",\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n## Why these changes help (no fluff)\r\n\r\n1. **Better construction = fewer local-search steps + shorter final tours.**\r\n   The new constructor is a **GRASP** (Greedy Randomized Adaptive Search Procedure): from KNN of the current city we form a Restricted Candidate List of size (L\\le 8) and pick next city with probability (p_i \\propto 1/d_i). We repeat this from **4 random seeds** and keep the best initial cycle. Empirically on Euclidean TSP, GRASP-style starts reduce 2-opt iterations and produce tours closer to the LKH/nearest-neighbor baselines. Runtime impact is tiny at (n=200), but downstream improvements are tangible.\r\n\r\n   * Selection weights: (w_i=1/(d_i+\\varepsilon)); roulette wheel on (\\sum w_i).\r\n   * Closing length computed during build avoids pathological starts.\r\n   * If KNN offers nothing (rare), we fall back to global nearest unvisited\u2014never a random jump.\r\n\r\n2. **Sort the K nearest neighbors.**\r\n   Your 2-opt loop iterates candidates in stored order. After `nth_element` the first K items are *unsorted*. Sorting those K ensures we try **shortest edges first**, which raises the hit rate of first-improvement 2-opt and reduces wasted checks.\r\n\r\n3. **Adaptive k-opt depth (replace randomness).**\r\n   Randomly changing `k` wastes time. We now **increase k** when k-opt makes **zero** improvements and **decrease k** when it makes only small gains, with a floor/ceiling and a cap when the tour is already near the **BHH expectation**:\r\n   [\r\n   \\mathbb{E}[L_n] \\approx \\beta_2 \\sqrt{n \\cdot A},\\quad \\beta_2 \\approx 0.7120\r\n   ]\r\n   As soon as (L) is within **6%** of (\\mathbb{E}[L_n]), we clamp (k \\le 24). This preserves quality while shaving runtime.\r\n\r\n4. **Parameter tweaks that are sane for Euclidean (n\\approx 200).**\r\n\r\n   * `distance_type: \"double\"` removes rounding artifacts from magnified integers; 2-opt/k-opt are sensitive to small deltas. At this scale, doubles are fast enough.\r\n   * `candidates_number: 32` modestly expands the neighborhood (common sweet spot for 2D Euclidean).\r\n   * `exploration_coefficient \u2191`, `weight_delta_coefficient \u2193`, `sensitivity_temperature \u2191`: slightly more exploration and less overweighting from a single successful simulation reduce premature edge over-commitment.\r\n\r\n---\r\n\r\n### Expected effect on the combined score\r\n\r\n* **Shorter tours:** higher-quality starts + near-first-sorted candidate trials + smarter k-depth.\r\n* **Faster time:** fewer futile 2-opt checks (sorted K), fewer wasteful deep k-opt when near BHH, no random k jitter.\r\n\r\nIf you want the next boost after this, add a **double-bridge kick** between restarts (Lin-Kernighan style shake) and a tiny **don\u2019t-look bits** array for 2-opt; both are simple and give further wall-clock gains without hurting diversity."]}}, "artifacts_json": "{\"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"tsp_run_first_test_sample_stdout\": \"Reading configuration...\\nNumber of cities: 200\\n\\nReading input data...\\nSolving...\\n# --------- Iteration: 100\\nPhase #1 (random cycle). Total distance: 22.740199, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.556463, Improved times: 270, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 11.556463, Improved times: 9, Time: 14 ms\\n\\n# --------- Iteration: 200\\nPhase #1 (random cycle). Total distance: 22.454036, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.951059, Improved times: 253, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 11.951059, Improved times: 0, Time: 2 ms\\n\\n# --------- Iteration: 300\\nPhase #1 (random cycle). Total distance: 22.883914, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.767945, Improved times: 296, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 11.767945, Improved times: 0, Time: 3 ms\\n\\n# --------- Iteration: 400\\nPhase #1 (random cycle). Total distance: 22.866953, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.988342, Improved times: 272, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 11.988342, Improved times: 1, Time: 1 ms\\n\\n# --------- Iteration: 500\\nPhase #1 (random cycle). Total distance: 22.065167, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 12.061393, Improved times: 251, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 12.061393, Improved times: 6, Time: 1 ms\\n\\n# --------- Iteration: 600\\nPhase #1 (random cycle). Total distance: 21.010293, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.67882, Improved times: 233, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 11.67882, Improved times: 1, Time: 0 ms\\n\\n# --------- Iteration: 700\\nPhase #1 (random cycle). Total distance: 22.159576, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 11.758991, Improved times: 239, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 11.758991, Improved times: 5, Time: 2 ms\\n\\nTotal elapsed time: 5.007 sec\\n\\nFinal solution:\\n0 68 152 38 126 134 72 112 58 135 20 92 169 107 114 154 121 83 70 124 182 185 74 50 11 111 181 110 172 16 189 164 148 66 97 109 88 115 130 17 190 103 78 62 194 101 79 104 196 175 158 193 165 129 100 40 51 123 18 184 35 139 89 191 141 146 1 118 96 149 160 116 44 161 155 80 53 86 143 65 136 179 41 192 147 176 145 187 93 73 24 105 59 91 6 64 183 54 47 159 140 22 87 153 150 3 108 122 151 82 90 60 39 81 178 61 106 188 75 32 49 163 26 117 127 180 99 46 52 23 55 48 7 132 30 27 174 56 14 67 76 138 125 173 4 37 25 28 120 34 102 94 95 45 85 9 36 13 57 42 33 177 142 128 167 133 195 31 137 8 131 77 43 84 170 10 168 12 119 162 186 199 113 69 157 156 63 71 98 21 144 171 198 5 197 29 2 166 15 19 \\n\\nFinal solution score: 11.172735\\n\", \"tsp_run_first_test_sample_stderr\": \"\"}", "artifact_dir": null}