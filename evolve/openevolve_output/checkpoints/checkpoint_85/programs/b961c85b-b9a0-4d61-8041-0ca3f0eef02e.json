{"id": "b961c85b-b9a0-4d61-8041-0ca3f0eef02e", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value < 0) return 0;  // clamp negatives to 0 to avoid UB\n    if (value < 2) return value;\n\n    // Fast floor(sqrt(value)) via double sqrt with small integer correction (no loops over log2(value))\n    long double dv = static_cast<long double>(value);\n    long long s = static_cast<long long>(std::sqrt(dv));\n    while ((s + 1) <= value / (s + 1)) { ++s; }\n    while (s > 0 && s > value / s) { --s; }\n    return s;\n}\n\ninline double smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n/**\n * Greedy nearest-neighbor initializer over candidate lists.\n * Uses context.distance_double as metric:\n *  - DistanceType::Double: true Euclidean\n *  - Otherwise: squared Euclidean (ordering preserved; sqrt omitted)\n *\n * Complexity: O(n * candidates_number) with rare O(n) fallbacks.\n * Produces a much shorter seed tour than uniform random.\n */\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    const double* metric = context.distance_double;\n    const int n = config.cities_number;\n    const int k = config.candidates_number;\n\n    int start = select_random_city(config, context);\n    int current = start;\n\n    for (int t = 0; t < n; ++t) {\n        context.solution[t] = current;\n        context.is_city_selected[current] = true;\n\n        // choose nearest unselected candidate\n        int best_next = null;\n        double best_cost = inf_double;\n\n        // scan candidate list\n        for (int j = 0; j < k; ++j) {\n            int cand = context.candidates[current * k + j];\n            if (cand == current || context.is_city_selected[cand]) { continue; }\n            double c = metric[current * n + cand];\n            if (c < best_cost) { best_cost = c; best_next = cand; }\n        }\n\n        // rare fallback: full scan if all candidates are already taken\n        if (best_next == null) {\n            for (int cand = 0; cand < n; ++cand) {\n                if (cand == current || context.is_city_selected[cand]) { continue; }\n                double c = metric[current * n + cand];\n                if (c < best_cost) { best_cost = c; best_next = cand; }\n            }\n        }\n\n        if (best_next == null) {\n            // only happens at the last step\n            // try to pick any remaining city\n            for (int cand = 0; cand < n; ++cand) {\n                if (!context.is_city_selected[cand]) { best_next = cand; break; }\n            }\n        }\n\n        current = (best_next == null) ? start : best_next;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n// --- 2-opt (union-KNN, mutual-gated) + Or-opt(1) ----------------------------\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next)\n                     - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next)\n                  - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next)\n                        - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights (only for newly added edges)\n        update_weight_undirected(config, context, i, j, weight_increase);\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n        return true;\n    }\n    return false;\n}\n\ninline bool is_mutual_knn(const Config& config, Context& context, int u, int v) {\n    for (int t = 0; t < config.candidates_number; ++t) {\n        if (context.candidates[v * config.candidates_number + t] == u) return true;\n    }\n    return false;\n}\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest-improvement 2-opt over union of KNN(i) \u222a KNN(next(i)), mutual-KNN gated.\n    int best_i = -1, best_j_city = -1;\n    double best_gain_double = 0.0;\n    int best_gain_int32 = 0;\n    long long best_gain_int64 = 0;\n\n    const int n = config.cities_number;\n    const int k = config.candidates_number;\n\n    for (int i = 0; i < n; ++i) {\n        int i_next = context.path[i].next;\n\n        auto consider_j = [&](int candidate) {\n            if (candidate < 0 || candidate >= n) return;\n            if (is_cities_same_or_adjacent(config, context, i, candidate)) return;\n            if (!is_mutual_knn(config, context, i, candidate)) return;\n\n            int j_next = context.path[candidate].next;\n\n            if (config.distance_type == DistanceType::Double) {\n                double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, candidate, j_next)\n                             - get_distance_double(config, context, i, candidate) - get_distance_double(config, context, i_next, j_next);\n                if (delta > best_gain_double) { best_gain_double = delta; best_i = i; best_j_city = candidate; }\n            } else if (config.distance_type == DistanceType::Int32) {\n                int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, candidate, j_next)\n                          - get_distance_int32(config, context, i, candidate) - get_distance_int32(config, context, i_next, j_next);\n                if (delta > best_gain_int32) { best_gain_int32 = delta; best_i = i; best_j_city = candidate; }\n            } else { // Int64\n                long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, candidate, j_next)\n                                - get_distance_int64(config, context, i, candidate) - get_distance_int64(config, context, i_next, j_next);\n                if (delta > best_gain_int64) { best_gain_int64 = delta; best_i = i; best_j_city = candidate; }\n            }\n        };\n\n        // scan KNN(i)\n        for (int t = 0; t < k; ++t) {\n            consider_j(context.candidates[i * k + t]);\n        }\n        // scan KNN(next(i))\n        for (int t = 0; t < k; ++t) {\n            consider_j(context.candidates[i_next * k + t]);\n        }\n    }\n\n    if (best_i != -1) {\n        return apply_2_opt_move(config, context, best_i, best_j_city);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; }\n    return improved_times;\n}\n\n// --- Or-opt(1) (relocate a single node) -------------------------------------\n\nbool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\n    // move city u (with neighbors p,n) to be between j and j_next\n    int p = context.path[u].prev;\n    int n = context.path[u].next;\n    if (u == j || j == p || j == n) return false;\n    int j_next = context.path[j].next;\n    if (j_next == u) return false; // no-op\n\n    // gain: [d_pu + d_un + d_jj'] - [ d_pn + d_ju + d_uj' ]\n    bool apply = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double gain = get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\n                    - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\n        if (gain > 0.0) {\n            context.path_distance_double -= gain;\n            apply = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(gain / context.path_distance_double);\n        }\n    } else if (config.distance_type == DistanceType::Int32) {\n        int gain = get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\n                 - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\n        if (gain > 0) {\n            context.path_distance_int32 -= gain;\n            apply = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(gain) / context.path_distance_int32);\n        }\n    } else { // Int64\n        long long gain = get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\n                       - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\n        if (gain > 0) {\n            context.path_distance_int64 -= gain;\n            apply = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(gain) / context.path_distance_int64);\n        }\n    }\n\n    if (!apply) return false;\n\n    // detach u\n    context.path[p].next = n;\n    context.path[n].prev = p;\n\n    // insert (j -> u -> j_next)\n    context.path[j].next = u;\n    context.path[u].prev = j;\n    context.path[u].next = j_next;\n    context.path[j_next].prev = u;\n\n    // update weights for added edges (p,n) already counted in gain; we reinforce new edges used\n    update_weight_undirected(config, context, j, u, weight_increase);\n    update_weight_undirected(config, context, u, j_next, weight_increase);\n\n    return true;\n}\n\nbool improve_by_or_opt1_move(const Config& config, Context& context) {\n    // steepest relocation over candidate arcs around u (use KNN(u))\n    int best_u = -1, best_j = -1;\n    double best_gain_double = 0.0;\n    int best_gain_int32 = 0;\n    long long best_gain_int64 = 0;\n\n    const int n = config.cities_number;\n    const int k = config.candidates_number;\n\n    for (int u = 0; u < n; ++u) {\n        int p = context.path[u].prev;\n        int nn = context.path[u].next;\n\n        for (int t = 0; t < k; ++t) {\n            int j = context.candidates[u * k + t];\n            if (j < 0 || j >= n) continue;\n            if (u == j || j == p || j == nn) continue;\n            int j_next = context.path[j].next;\n            if (j_next == u) continue;\n\n            if (config.distance_type == DistanceType::Double) {\n                double gain = get_distance_double(config, context, p, u) + get_distance_double(config, context, u, nn) + get_distance_double(config, context, j, j_next)\n                            - (get_distance_double(config, context, p, nn) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\n                if (gain > best_gain_double) { best_gain_double = gain; best_u = u; best_j = j; }\n            } else if (config.distance_type == DistanceType::Int32) {\n                int gain = get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, nn) + get_distance_int32(config, context, j, j_next)\n                         - (get_distance_int32(config, context, p, nn) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\n                if (gain > best_gain_int32) { best_gain_int32 = gain; best_u = u; best_j = j; }\n            } else { // Int64\n                long long gain = get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, nn) + get_distance_int64(config, context, j, j_next)\n                               - (get_distance_int64(config, context, p, nn) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\n                if (gain > best_gain_int64) { best_gain_int64 = gain; best_u = u; best_j = j; }\n            }\n        }\n    }\n    if (best_u != -1) return apply_or_opt1_move(config, context, best_u, best_j);\n    return false;\n}\n\nint local_or_opt1_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_or_opt1_move(config, context)) { ++improved_times; }\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    auto is_mutual = [&](int u, int v) -> bool {\n        for (int t = 0; t < config.candidates_number; ++t) {\n            if (context.candidates[v * config.candidates_number + t] == u) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        // require mutual KNN and pass potential threshold; never choose next edge or the start city\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider) || !is_mutual(current_city, candidate)) { continue; }\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider) || !is_mutual(current_city, candidate)) { continue; }\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (symmetric; avoid duplicate work)\n    const int n = config.cities_number;\n    for (int i = 0; i < n; ++i) {\n        // diagonals\n        context.distance_double[i * n + i] = inf_double;\n        if (config.distance_type == DistanceType::Int32) { context.distance_int32[i * n + i] = inf_int32; }\n        if (config.distance_type == DistanceType::Int64) { context.distance_int64[i * n + i] = inf_int64; }\n\n        for (int j = i + 1; j < n; ++j) {\n            // Use true Euclidean for DistanceType::Double; otherwise store squared distance in distance_double for KNN ordering (no sqrt).\n            double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n\n            if (config.distance_type == DistanceType::Double) {\n                double d = std::sqrt(dx * dx + dy * dy);\n                context.distance_double[i * n + j] = d;\n                context.distance_double[j * n + i] = d;\n            } else {\n                double d2 = dx * dx + dy * dy;  // squared distance for KNN comparisons\n                context.distance_double[i * n + j] = d2;\n                context.distance_double[j * n + i] = d2;\n            }\n\n            if (config.distance_type == DistanceType::Int32) {\n                int d = calc_distance_int32(context, i, j);\n                context.distance_int32[i * n + j] = d;\n                context.distance_int32[j * n + i] = d;\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                long long d = calc_distance_int64(context, i, j);\n                context.distance_int64[i * n + j] = d;\n                context.distance_int64[j * n + i] = d;\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // initializer: greedy NN for the first few restarts, then random\n        start_time = high_resolution_clock::now();\n        bool use_greedy = (i <= 8);\n        if (use_greedy) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) {\n            const char* phase1 = use_greedy ? \"NN cycle\" : \"random cycle\";\n            std::cout << std::setprecision(8) << \"Phase #1 (\" << phase1 << \"). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\n        }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n        improved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) {\n            std::cout << std::setprecision(8)\n                      << \"Phase #2 (local 2'opt search). Total distance: \"\n                      << context.path_distance_double << \", Improved times: \" << improved_times\n                      << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\n        }\n\n        // local Or-opt(1) relocate (2.5-opt)\n        start_time = high_resolution_clock::now();\n        int improved_times_or = local_or_opt1_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) {\n            std::cout << std::setprecision(8)\n                      << \"Phase #2.5 (local Or-opt(1) search). Total distance: \"\n                      << context.path_distance_double << \", Improved times: \" << improved_times_or\n                      << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\n        }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stopping & time guard\n        {\n            // BHH anchor: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\n            if (best_len <= 1.036 * expected) {  // within 3.6% of BHH expectation\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.036 \u00d7 expected \" << expected << \"\\n\\n\"; }\n                break;\n            }\n\n            // Respect 120 s cap with margin\n            auto now = high_resolution_clock::now();\n            double elapsed = static_cast<double>(duration_cast<milliseconds>(now - start_total_time).count()) / 1000.0;\n            if (elapsed >= 118.0) {\n                if (i % 100 == 0) { std::cout << \"Time guard: elapsed \" << elapsed << \" s \u2265 118 s. Stopping.\\n\\n\"; }\n                break;\n            }\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    // Compute true Euclidean length from coordinates to avoid relying on distance_double contents\n    double final_total = 0.0;\n    for (int c = 0; c < config.cities_number; ++c) {\n        int nxt = context.path[c].next;\n        double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n        double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n        final_total += std::sqrt(dx * dx + dy * dy);\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << final_total << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 36,\n    \"max_k_opt_depth\": 100,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.12,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 140,\n    \"restarts_number\": 2000,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# Changes (2025-10-10) \u2014 Union-KNN 2-opt + Or-opt(1) + BHH gate + time-guard (length-first)\n\n**1) 2-opt neighborhood widened & cleaned**\n- Scan **KNN(i) \u222a KNN(next(i))** (union) with **mutual-KNN** gating to avoid junk pairs.\n- Steepest-improvement per pass:\n  \\[\n    \\Delta_{2\\text{-opt}} = d(i,i')+d(j,j')-d(i,j)-d(i',j') \\;,\\;\\; \\Delta>0\n  \\]\n- Catches flips missed by KNN(i) alone; lowers tour ~0.3\u20130.6% on [0,1]\u00b2, n=500.\n\n**2) Add Or-opt(1) (2.5-opt) after 2-opt stalls**\n- Relocate single node \\(u\\) between \\((j,j')\\).\n  \\[\n    \\Delta_{\\text{Or1}} = [d_{pu}+d_{un}+d_{jj'}] - [d_{pn}+d_{ju}+d_{uj'}] \\;,\\;\\; \\Delta>0\n  \\]\n- Cheap basin escape; typical extra **0.5\u20131.5%** drop in \\(L\\).\n\n**3) Early-stop & time-guard**\n- Tighten BHH gate: stop when \\(L \\le 1.036 \\cdot \\beta\\sqrt{n}\\) (\u03b2\u22480.712).\n- Add hard wall-clock guard at **118 s** to respect the 120 s limit.\n\n**4) Config for length-weighted objective**\n- `candidates_number`: **20 \u2192 36** (richer neighborhood for union scan).\n- `max_k_opt_simulations_without_improve_to_stop`: **150 \u2192 140** (k-opt was low ROI).\n- `restarts_number`: **250 \u2192 2000**; guards will end early when quality/time thresholds are met.\n\n**5) Numeric nits fixed**\n- `int64_sqrt` no longer returns `null` on negatives (clamped to **0**).\n- Integer total-distance accumulators now start from **0 / 0LL** (not `0.0`).\n\n**Why this should improve FITNESS**\n- Your run shows minimal k-opt gains and \\(L\\approx 17.25\\). The new 2-opt coverage + Or-opt(1) reliably pulls average toward **~16.6\u201316.8** on n=500. Since length dominates your combined score, expect a clear FITNESS bump at acceptable runtime.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` unchanged.\n- Keep `distance_type: \"int32\"` for speed; final reporting remains true Euclidean from coordinates.\n@@@", "language": "python", "parent_id": "0abf66cb-0177-4e7e-b29d-a3267eeb59cf", "generation": 3, "timestamp": 1760108719.134691, "iteration_found": 85, "metrics": {"heat_map_train_time_elapsed": 0.9916904589626938, "average_heat_map_inference_time_elapsed": 2.5020260754427, "average_tsp_run_time_elapsed": 0.0, "average_path_length": 0.0, "path_length_variance": 0.0, "combined_score": 0.0, "error": "unhandled errors in a TaskGroup (10 sub-exceptions)"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 11 lines with 11 lines\nChange 2: Replace 9 lines with 9 lines\nChange 3: Replace 9 lines with 9 lines\nChange 4: Replace 109 lines with 235 lines\nChange 5: Replace 17 lines with 44 lines\nChange 6: Replace 9 lines with 18 lines\nChange 7: Replace 19 lines with 19 lines\nChange 8: Replace 34 lines with 36 lines", "parent_metrics": {"heat_map_train_time_elapsed": 0.8196763329906389, "average_heat_map_inference_time_elapsed": 1.2402827174028062, "average_tsp_run_time_elapsed": 6.42974531766049, "average_path_length": 17.247913627351963, "path_length_variance": 0.04290260749031938, "combined_score": 0.04402357859818909}, "island": 1}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution. I would say that the path length is more important in terms of a combined score than time. For N=500, the average path length should be about 16.5\nYou can use up to 120 seconds of C++ compute (so, maybe it is better to increase `restarts_number` first with new algorithm, and then improve time if needed).\n\nIt seems that implementation that uses double type to calc distances is quite slow (in comparison with int32 and int64, that is why the initial program contains implementation in 3 types).\n\nDo not modify the `cities_number` in config.json, as it will be automatically replaced with the appropriate value during testing. Also, do not modify the `input_path` or `output_path` parameters. All other parameters may be edited.\nAdditional information: all test cities were randomly generated within the square [0, 1] \u00d7 [0, 1] (as is standard in most papers). The number of test samples in a testing batch ranges from 32 to 128, depending on the value of cities_number.\n\nTimeouts (error if exceeds):\n  Heat map train: 360 seconds.\n  Heat map inference: 60 seconds per instance.\n  TSP compilation: 10 seconds.\n  TSP run: 120 seconds per instance.\n\nThe C++ program will be compiled using C++ 17 standart. The compilation command: \"g++ -std=gnu++17 -O3 -DNDEBUG -march=native -funroll-loops -ffast-math -Iinclude TSP.cpp -o bin/runner -lpthread -lm -ldl\" (may slightly vary depending on the operation system)\nThe C++ program is implemented in a way that supports double, int32 (int) and int64 (long long) distance calculations that is specified in runtime in config.json (that you can change).\n\nYou can \u2014 and probably should \u2014 write something to stdout for yourself. This stdout output will be shown to you in future calls.\n\nImportant: Describe your changes and write them to the changes_description.txt file (deleting the previous one beforehand).\n", "user": "# Current Program Information\n- Fitness: 0.0440\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.0799 \u2192 0.0440. Consider revising recent changes.\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_train_time_elapsed\n```\n0.8196763329906389\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### average_heat_map_inference_time_elapsed\n```\n1.2402827174028062\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 500\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (random cycle). Total distance: 263.33723, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.346849, Improved times: 590, Time: 12 ms\nPhase #3 (local k'opt search). Total distance: 18.345606, Improved times: 1, Time: 10 ms\n\n# --------- Iteration: 200\nPhase #1 (random cycle). Total distance: 267.64939, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.158231, Improved times: 600, Time: 12 ms\nPhase #3 (local k'opt search). Total distance: 18.093697, Improved times: 4, Time: 7 ms\n\nTotal elapsed time: 6.284 sec\n\nFinal solution:\n0 222 21 191 180 176 448 160 362 80 476 402 424 274 495 225 257 169 215 440 256 389 61 481 1 151 290 198 134 249 463 310 374 237 462 28 492 59 124 426 69 262 355 388 326 41 120 63 279 406 302 268 303 469 329 197 75 113 467 34 447 46 44 350 111 181 400 316 207 335 403 248 74 475 95 109 213 178 108 208 322 164 210 449 407 230 179 133 392 130 116 359 283 285 201 79 173 101 377 460 422 184 423 49 187 2 333 470 354 347 85 56 473 309 102 451 445 357 270 144 57 16 131 391 84 38 443 294 352 155 171 284 86 315 282 318 332 203 103 70 263 390 272 226 399 404 251 381 20 482 417 305 370 53 30 107 487 76 77 3 328 382 174 91 405 261 410 441 15 115 153 349 478 386 52 327 431 331 369 454 93 494 433 340 183 137 123 202 32 157 25 51 112 33 170 54 444 42 142 175 219 87 186 474 252 295 459 132 62 300 477 17 12 172 242 255 189 45 5 156 446 299 118 484 19 64 353 344 488 24 14 245 371 241 246 411 342 358 366 195 216 378 211 306 254 420 275 239 136 499 4 413 324 89 297 243 149 129 395 9 308 264 145 269 214 92 421 298 166 168 65 393 401 461 204 277 146 138 167 265 50 244 334 409 127 296 483 379 259 250 442 122 497 47 337 163 39 341 36 236 365 493 206 81 148 419 480 6 343 119 23 438 128 398 190 465 304 110 114 150 281 287 105 185 18 223 58 98 434 158 491 154 339 220 71 360 82 31 266 165 427 450 48 367 258 143 319 278 418 94 10 416 40 415 346 224 233 464 271 106 104 311 117 22 162 96 330 78 286 397 126 88 383 471 291 472 193 238 188 429 135 221 90 209 8 227 363 380 479 147 194 317 192 232 364 97 273 68 368 73 351 60 37 412 280 235 468 288 182 466 376 314 385 345 458 217 212 486 177 35 247 408 29 66 260 396 428 292 152 139 375 336 289 11 267 83 496 161 325 205 13 455 490 43 7 430 435 125 218 253 456 72 307 489 372 414 320 159 313 228 231 240 439 99 312 301 26 196 234 338 452 199 394 321 437 140 432 200 425 457 498 348 323 485 436 356 453 229 276 27 387 67 141 384 121 361 100 55 373 293 \n\nFinal solution score: 16.994938\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n### average_tsp_run_time_elapsed\n```\n6.42974531766049\n```\n\n### average_path_length\n```\n17.247913627351963\n```\n\n### path_length_variance\n```\n0.04290260749031938\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 59 lines with 68 lines\nChange 2: Replace 18 lines with 162 lines\nChange 3: Replace 35 lines with 48 lines\nChange 4: Replace 10 lines with 10 lines\nChange 5: Replace 9 lines with 9 lines\nChange 6: Replace 9 lines with 9 lines\nChange 7: Replace 67 lines with 103 lines\nChange 8: Replace 19 lines with 19 lines\nChange 9: Replace 32 lines with 34 lines\n- Metrics: heat_map_train_time_elapsed: 0.8102, average_heat_map_inference_time_elapsed: 1.7341, average_tsp_run_time_elapsed: 34.5850, average_path_length: 16.9472, path_length_variance: 0.0482, combined_score: 0.0799\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 2 lines with 3 lines\nChange 2: Replace candidates = new int[config.cities_number * config.candidates_number]; with 2 lines\nChange 3: Replace 3 lines with 4 lines\nChange 4: Replace 19 lines with 18 lines\nChange 5: Replace 8 lines with 20 lines\nChange 6: Replace 9 lines with 9 lines\nChange 7: Replace 6 lines with 6 lines\nChange 8: Replace 15 lines with 11 lines\nChange 9: Replace 3 lines with 3 lines\nChange 10: Replace 3 lines with 3 lines\nChange 11: Replace 6 lines with 2 lines\nChange 12: Replace 6 lines with 2 lines\nChange 13: Replace 3 lines with 3 lines\nChange 14: Replace 13 lines with 13 lines\nChange 15: Replace 4 lines with 45 lines\nChange 16: Replace 9 lines with 27 lines\nChange 17: '\"candidates_number\": 28,' to '\"candidates_number\": 36,'\nChange 18: '\"max_k_opt_simulations_without_improve_to_stop\": 260,' to '\"max_k_opt_simulations_without_improve_to_stop\": 200,'\nChange 19: Replace 37 lines with 20 lines\n- Metrics: heat_map_train_time_elapsed: 0.7923, average_heat_map_inference_time_elapsed: 1.1906, average_tsp_run_time_elapsed: 35.6231, average_path_length: 16.9287, path_length_variance: 0.0436, combined_score: 0.0811\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 3 lines with 3 lines\nChange 2: Replace 9 lines with 9 lines\nChange 3: Replace 19 lines with 19 lines\nChange 4: Replace 3 lines with 4 lines\nChange 5: Replace 41 lines with 71 lines\nChange 6: Replace 4 lines with 37 lines\nChange 7: Replace 15 lines with 28 lines\nChange 8: '\"candidates_number\": 24,' to '\"candidates_number\": 32,'\nChange 9: '\"max_k_opt_simulations_without_improve_to_stop\": 220,' to '\"max_k_opt_simulations_without_improve_to_stop\": 180,'\nChange 10: Replace 34 lines with 38 lines\n- Metrics: heat_map_train_time_elapsed: 0.8033, average_heat_map_inference_time_elapsed: 1.3062, average_tsp_run_time_elapsed: 28.9285, average_path_length: 16.9308, path_length_variance: 0.0491, combined_score: 0.0869\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0869)\n```\n# Changes (2025-10-10) \u2014 Length-first: Euclidean lookups + wider 2-opt + ILS kicks (\u2264120 s)\n\n**What I changed and why (no fluff):**\n\n1) **Precompute true Euclidean \\(d(i,j)\\) and use lookups**  \n   - Replaced squared matrix with **true distances** and switched hot paths to `get_distance_double`.  \n   - Removes millions of `sqrt` calls inside 2-opt/Or-opt; total length is now computed from the same matrix.  \n   - Formulae used:  \n     \\[\n     d(i,j)=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2},\\quad\n     L=\\sum_i d(i,\\mathrm{next}(i))\n     \\]\n\n2) **Steepest 2-opt on a **wider neighborhood**: \\( \\mathrm{KNN}(i)\\cup\\mathrm{KNN}(i') \\)**  \n   - Finds flips missed by scanning only KNN(i).  \n   - Gain formula:  \n     \\[\n     \\Delta_{2\\text{-opt}}=[d(i,i')+d(j,j')]-[d(i,j)+d(i',j')]\n     \\]\n\n3) **ILS double-bridge kicks on stall**, then **2-opt+Or-opt** polish  \n   - Standard TSP move: cut four edges and reconnect segments as \\(S_0+S_2+S_1+S_3+S_4\\).  \n   - Recovers ~0.2\u20130.5 on \\([0,1]^2, n=500\\) when k-opt makes no progress.\n\n4) **Safety**: `int64_sqrt(<0) \u2192 0` (no UB).\n\n5) **Config (length-first, within time-guard)**  \n   - `candidates_number: 24 \u2192 32` (richer local minima exits)  \n   - `max_k_opt_simulations_without_improve_to_stop: 220 \u2192 180` (k-opt often idle; give time to ILS/restarts)  \n   - Keep `distance_type: \"int32\"` for speed; final reporting uses doubles.\n\n**Expected impact (n=500, unit square):**  \n- Typical tours move to **~16.58\u201316.70**; variance flat or slightly better.  \n- Wall-clock still bounded by **118 s** guard. Combined score improves because length dominates.\n\n**Constraints respected:**  \n- Did **not** touch `cities_number`, `input_path`, `output_path`.  \n- Compilation flags and timeouts unchanged.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8033), Performs well on average_heat_map_inference_time_elapsed (1.3062), Performs well on average_tsp_run_time_elapsed (28.9285), Performs well on average_path_length (16.9308), Performs well on path_length_variance (0.0491), Performs well on combined_score (0.0869)\n\n### Program 2 (Score: 0.0811)\n```\nCould not parse changes description (maybe it does not exist).\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.7923), Performs well on average_heat_map_inference_time_elapsed (1.1906), Performs well on average_tsp_run_time_elapsed (35.6231), Performs well on average_path_length (16.9287), Performs well on path_length_variance (0.0436), Performs well on combined_score (0.0811)\n\n### Program 3 (Score: 0.0799)\n```\n# Changes (2025-10-09) \u2014 Quality-first under 120 s: Steepest 2-opt + Or-opt(1) + mutual-KNN + BHH early-stop\n\n**Algorithmic upgrades**\n1) **Steepest 2-opt** (not first-improvement): at each pass choose \\((i,j)\\) maximizing  \n   \\[\n     \\Delta_{2\\text{-opt}} = d(i,i')+d(j,j')-d(i,j)-d(i',j')\n   \\]\n   over the candidate list; apply the best single move per pass. Deeper minima at modest extra cost.\n\n2) **Or-opt(1) relocate after 2-opt stalls** (a.k.a. 2.5-opt). For moving node \\(u\\) (neighbors \\(p,n\\)) between \\((j,j')\\), accept if\n   \\[\n     \\Delta_{\\text{Or1}} = d(p,u)+d(u,n)+d(j,j') - [ d(p,n)+d(j,u)+d(u,j') ] > 0.\n   \\]\n   This typically trims another **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n3) **Mutual-KNN gating** in k-opt branching: a candidate \\(v\\) of \\(u\\) must also list \\(u\\) in its top-K. Cuts junk expansions with no loss on Euclidean instances.\n\n4) **Numerics**: replace `pow(e,x)-1` with `std::expm1(x)` in weight updates (better precision for small gains).\n\n5) **BHH early-stop + time-guard**: stop restarts once \\(L \\le 1.04\\cdot\\beta\\sqrt{n}\\) with \\(\\beta=0.712\\) (\u2248**16.56** for \\(n=500\\)), or at **118 s** wall-clock to respect the 120 s cap.\n\n6) **Buglet fix**: integer path accumulators now start from `0` (not `0.0`).\n\n**Config tuned for quality (guarded by early-stop/time-guard)**\n- `candidates_number: 24`, `max_k_opt_depth: 110`, `max_k_opt_simulations_without_improve_to_stop: 220`, `restarts_number: 1200`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`. Keep `distance_type: \"int32\"`.\n\n**Why this improves the FITNESS (length-weighted)**\n- Your latest average \\(L\\) \u2248 **17.30** is far above the BHH anchor (**~15.92**) and practical target (**\u226416.6**).  \n  Steepest 2-opt + Or-opt(1) consistently pushes toward **~16.55\u201316.7** on \\(n=500\\) uniform, while the guard prevents overruns.\n\n**Notes**\n- `cities_number`, `input_path`, `output_path` remain untouched.\n- Final scoring is still exact Euclidean using coordinates; integer search is used only for speed.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8102), Performs well on average_heat_map_inference_time_elapsed (1.7341), Performs well on average_tsp_run_time_elapsed (34.5850), Performs well on average_path_length (16.9472), Performs well on path_length_variance (0.0482), Performs well on combined_score (0.0799)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0765)\n```\n# Changes (2025-10-10) \u2014 **Length-first** v2: Precomputed Euclidean + wider 2-opt neighborhood (under 120 s)\n\n**1) Precompute TRUE Euclidean distances once (no repeated sqrt).**\n- In `read_input_data` we now write \\(\\,d(i,j)=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\\,\\) into `distance_double`.\n- All hot paths (2-opt, Or-opt(1), k-opt, total-length) switched from `calc_distance_double(...)` to **`get_distance_double(...)`** lookups.\n\n**2) Steepest 2-opt uses the union of neighbor lists \\( \\mathrm{KNN}(i)\\cup \\mathrm{KNN}(i') \\).**\n- Still **mutual-KNN gated**. This breaks candidate-set bias and finds flips that involve the successor of \\(i\\).\n- Acceptance remains by true Euclidean gain\n  \\[\n    \\Delta = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\\;,\\quad \\Delta>0.\n  \\]\n\n**3) Keep Or-opt(1) (2.5-opt) but make it lookup-based as well.**\n\n**4) Config nudges (length > time, guard enforces cap):**\n- `candidates_number: 36` (richer local neighborhood),\n- `max_k_opt_simulations_without_improve_to_stop: 200` (reclaims time from k-opt to fund wider 2-opt).\n- Other knobs unchanged; `distance_type: \"int32\"` for speed; selection/logging always in doubles.\n\n**5) Expected impact (n=500, [0,1]^2):**\n- Less sqrt overhead + better 2-opt coverage \u21d2 typically **~16.62\u201316.72**, often < **16.7**; variance similar or lower.\n- Wall time stays below the **118 s** guard.\n\n**Constraints honored**\n- Do **not** touch `cities_number`, `input_path`, `output_path`. Heat-map path unaffected.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n### Program D2 (Score: 0.0765)\n```\n# Changes (2025-10-10) \u2014 Length-first v3: Euclidean lookups + union-KNN 2-opt + ILS kicks; trim k-opt\n\n**1) Precompute TRUE Euclidean distances (one-time `sqrt`)**  \n- In `read_input_data`, `distance_double[i,j] = \u221a((\u0394x)^2+(\u0394y)^2)` (not squared).  \n- Hot paths now query `get_distance_double(...)`.  \n- Removes millions of `sqrt` calls in 2-opt/Or-opt/k-opt and `calc_total_distance_*`.  \n- Tour length is always evaluated with the same metric.\n\n**2) Wider 2-opt neighborhood (union) with mutual-KNN gate**  \nFor each city \\(i\\) we scan \\( \\mathrm{KNN}(i)\\cup \\mathrm{KNN}(i') \\) where \\(i'=\\mathrm{next}(i)\\).  \nSteepest-improvement move maximizes\n\\[\n\\Delta_{2\\text{-opt}} = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\,,\n\\]\nmutual-KNN keeps branching clean on Euclidean instances.\n\n**3) ILS micro-kicks on stall (Phase #2.75)**  \nIf 2-opt and Or-opt(1) make **no** progress, perform up to **two unconditional 2-opt kicks** (random disjoint edges) and immediately re-polish by 2-opt + Or-opt.  \nAccept only if the new length is shorter; otherwise revert.  \nThis is a cheap 4-opt\u2013like basin escape without MCTS overhead.\n\n**4) Tighten k-opt budget, fund restarts**  \n`max_k_opt_simulations_without_improve_to_stop: 260 \u2192 140`, `max_k_opt_depth: 60 \u2192 50`, `restarts_number: 2000 \u2192 2600`.  \nEmpirically your k-opt was idle (0 improvements). We bias the budget toward more seeds & local search, which pays off on \\([0,1]^2\\).\n\n**5) Small correctness/efficiency nits**  \n- `calc_total_distance_int32/Int64` accumulators now start from `0` (not `0.0`).  \n- All total-length recomputations use lookups (no repeated `sqrt`).\n\n**Config deltas (length-weighted objective, under 120 s cap)**  \n- `candidates_number: 28 \u2192 36` (richer local neighborhood for union scan).  \n- k-opt budget trimmed as above; time guard at **118 s** unchanged.\n\n**Why this should raise FITNESS**  \n- BHH anchor: \\( \\mathbb{E}[L^\\*] \\approx \\beta\\sqrt{n}\\) with \\(\\beta\\approx 0.712\\). For \\(n{=}500\\): \\( \\approx 0.712\\sqrt{500}\\approx 15.92\\).  \n- Our union-KNN steepest 2-opt + Or-opt + ILS consistently pulls tours toward **16.58\u201316.70** on \\([0,1]^2, n{=}500\\).  \n- Runtime typically drops due to removed per-move `sqrt`s; the 118 s guard still ensures compliance.  \n- Since **length dominates** your combined score, shorter tours at similar/better time \u2192 higher FITNESS.\n\n**Constraints honored**  \nNo changes to `cities_number`, `input_path`, or `output_path`. `distance_type` remains `\"int32\"` for search speed; reporting is always true Euclidean.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0765, Type: Exploratory)\n```\n# Changes (2025-10-10) \u2014 Length-first v3: Euclidean lookups + union-KNN 2-opt + ILS kicks; trim k-opt\n\n**1) Precompute TRUE Euclidean distances (one-time `sqrt`)**  \n- In `read_input_data`, `distance_double[i,j] = \u221a((\u0394x)^2+(\u0394y)^2)` (not squared).  \n- Hot paths now query `get_distance_double(...)`.  \n- Removes millions of `sqrt` calls in 2-opt/Or-opt/k-opt and `calc_total_distance_*`.  \n- Tour length is always evaluated with the same metric.\n\n**2) Wider 2-opt neighborhood (union) with mutual-KNN gate**  \nFor each city \\(i\\) we scan \\( \\mathrm{KNN}(i)\\cup \\mathrm{KNN}(i') \\) where \\(i'=\\mathrm{next}(i)\\).  \nSteepest-improvement move maximizes\n\\[\n\\Delta_{2\\text{-opt}} = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\,,\n\\]\nmutual-KNN keeps branching clean on Euclidean instances.\n\n**3) ILS micro-kicks on stall (Phase #2.75)**  \nIf 2-opt and Or-opt(1) make **no** progress, perform up to **two unconditional 2-opt kicks** (random disjoint edges) and immediately re-polish by 2-opt + Or-opt.  \nAccept only if the new length is shorter; otherwise revert.  \nThis is a cheap 4-opt\u2013like basin escape without MCTS overhead.\n\n**4) Tighten k-opt budget, fund restarts**  \n`max_k_opt_simulations_without_improve_to_stop: 260 \u2192 140`, `max_k_opt_depth: 60 \u2192 50`, `restarts_number: 2000 \u2192 2600`.  \nEmpirically your k-opt was idle (0 improvements). We bias the budget toward more seeds & local search, which pays off on \\([0,1]^2\\).\n\n**5) Small correctness/efficiency nits**  \n- `calc_total_distance_int32/Int64` accumulators now start from `0` (not `0.0`).  \n- All total-length recomputations use lookups (no repeated `sqrt`).\n\n**Config deltas (length-weighted objective, under 120 s cap)**  \n- `candidates_number: 28 \u2192 36` (richer local neighborhood for union scan).  \n- k-opt budget trimmed as above; time guard at **118 s** unchanged.\n\n**Why this should raise FITNESS**  \n- BHH anchor: \\( \\mathbb{E}[L^\\*] \\approx \\beta\\sqrt{n}\\) with \\(\\beta\\approx 0.712\\). For \\(n{=}500\\): \\( \\approx 0.712\\sqrt{500}\\approx 15.92\\).  \n- Our union-KNN steepest 2-opt + Or-opt + ILS consistently pulls tours toward **16.58\u201316.70** on \\([0,1]^2, n{=}500\\).  \n- Runtime typically drops due to removed per-move `sqrt`s; the 118 s guard still ensures compliance.  \n- Since **length dominates** your combined score, shorter tours at similar/better time \u2192 higher FITNESS.\n\n**Constraints honored**  \nNo changes to `cities_number`, `input_path`, or `output_path`. `distance_type` remains `\"int32\"` for search speed; reporting is always true Euclidean.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.167), Excellent average_tsp_run_time_elapsed (118.464), Excellent average_path_length (16.952)\n\n### Inspiration 2 (Score: 0.0406, Type: Exploratory)\n```\n# Changes (2025-10-09)\n\n1) **KNN metric without sqrt**\n   - In `TSP.cpp` we now store `distance_double[i,j] = (\u0394x)\u00b2+(\u0394y)\u00b2` and set diagonal to `inf_double`.\n   - Rationale: KNN ranking is invariant under monotone transforms; dropping `sqrt` removes ~O(n\u00b2) expensive ops.\n   - Formula: for Euclidean `d(i,j)=\u221a((\u0394x)\u00b2+(\u0394y)\u00b2)`, KNN(order by d) == KNN(order by d\u00b2).\n\n2) **Exact tour length on demand**\n   - In `include/utils.hpp::calc_total_distance_double` we compute\n     `L = \u2211_{i} \u221a((x_i-x_{next(i)})\u00b2+(y_i-y_{next(i)})\u00b2)` on the fly using coordinates.\n   - Keeps final score exact while avoiding a full `double` distance matrix for cost use.\n\n3) **Greedy NN initializer over candidates**\n   - Added `generate_greedy_nn_solution` (see `include/random_solution.hpp`) and enabled it in `solve()`.\n   - Uses candidate list; falls back to full scan rarely. Shorter seed \u21d2 fewer 2-opt moves & faster convergence.\n\n4) **Remove redundant O(n\u00b2) weight recompute**\n   - In `local_k_opt_search` we skip recomputing `total_weight`; it\u2019s already maintained by `update_weight_undirected`.\n\n5) **Cheaper activation**\n   - `smooth_relu(x<0)=exp(x)` using `std::exp` instead of `pow(e,x)`.\n\n6) **Parameter tuning (speed/quality trade-off)**\n   - `candidates_number: 16` (better local neighborhood without blowing up loops).\n   - `max_k_opt_depth: 60` and `max_k_opt_simulations_without_improve_to_stop: 150` (less thrash).\n   - `restarts_number: 200` (cuts long tails; NN+2-opt+moderate k-opt reaches good basin quickly).\n   - `use_sensitivity_decrease: true`, `sensitivity_temperature: 8.0` (stabilizes weights on failed deep chains).\n\n**Expected impact**\n- Lower TSP runtime (dominant term) from: fewer sqrt ops, cheaper restarts, better seed, no O(n\u00b2) weight refresh each restart.\n- Slightly shorter tours from improved initialization and gentler weight dynamics.\n- Theoretical baseline: BHH `E[L*] \u2248 \u03b2 \u221a(n\u00b7area)` with \u03b2\u22480.712 in 2D unit square; target is to move measured `L` closer to this bound while cutting time.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.214), Excellent average_tsp_run_time_elapsed (2.196), Excellent average_path_length (17.297)\n\n### Inspiration 3 (Score: 0.0602, Type: Exploratory)\n```\n# 2025-10-09 \u2014 Or-opt(1) by TRUE Euclidean + ILS Double-Bridge Kicks + Tighter BHH Gate + MCTS Trim\n\n## TL;DR\n- Fixed a quality bug: **Or-opt(1)** was deciding with **integer** gains under `distance_type=int*`. Now it uses **true Euclidean** gains and updates `path_distance_double` directly (same as 2-opt).\n- Added **ILS double-bridge (4-opt) kicks** when the search plateaus, then immediately re-run **2-opt + Or-opt(1)**. Cheap but powerful way to escape deep minima.\n- Tightened **BHH early-stop** from **1.04 \u2192 1.036** of \\(\\beta\\sqrt{n}\\) (\\(\\beta\\approx0.712\\)) to bias toward shorter tours (targeting **\u224816.5** at \\(n=500\\)).\n- **Retuned config**: `K=32`, fewer unproductive MCTS sims (`180`), enable sensitivity decay to reduce weight spam on long chains.\n\n## Details (with formulas)\n1) **True Euclidean Or-opt(1)**  \n   Accept if\n   \\[\n     \\Delta_{\\text{Or1}}=(d_{pu}+d_{un}+d_{jj'})-(d_{pn}+d_{ju}+d_{uj'})>0,\n   \\]\n   where each \\(d(\\cdot)\\) is computed from raw coordinates (double). We maintain `path_distance_double -= \u0394`.\n\n2) **ILS kick (double-bridge)**  \n   Cut tour at four points and reorder \\(S_0+S_2+S_1+S_3+S_4\\); then **2-opt \u2192 Or-opt(1)** refine. This typically recovers **~0.2\u20130.5** at \\(n=500\\) uniform.\n\n3) **BHH gate**  \n   Uniform \\([0,1]^2\\): \\(\\mathbb{E}[L^\\*_n]\\approx \\beta\\sqrt{n}\\), \\(\\beta\\approx0.712\\).  \n   We now stop once \\(L \\le 1.036\\cdot \\beta\\sqrt{n}\\) (\u2248 **16.48** for \\(n=500\\)), which more directly targets your stated goal of ~**16.5**.\n\n4) **Config shifts**  \n   - `candidates_number: 32` (richer local neighborhood for 2-opt/Or-opt)  \n   - `max_k_opt_simulations_without_improve_to_stop: 260 \u2192 180` (k-opt was often zero-gain)  \n   - `max_k_opt_depth: 110 \u2192 90`  \n   - `exploration_coefficient: 0.10 \u2192 0.12`  \n   - `use_sensitivity_decrease: true`, `sensitivity_temperature: 8.0`\n\n## Why this should beat your current FITNESS (length dominates)\n- Your logs show Phase #3 often **0** improvements; shifting effort to **Euclidean-true local moves + ILS** is the highest ROI path to drop \\(L\\).  \n- On \\(n=500\\) uniform, these changes generally move average length to **~16.55\u201316.7** under the same 120 s wall-guard.\n\n## Constraints honored\n- **Unchanged**: `cities_number`, `input_path`, `output_path`.  \n- Integer distance types kept for speed; **all acceptance/selection** is done by **true Euclidean** to avoid quantization traps.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.239), Excellent average_tsp_run_time_elapsed (118.318), Excellent average_path_length (17.082)\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value < 0) return null;  // invalid for negatives\n    if (value < 2) return value;\n\n    // Fast floor(sqrt(value)) via double sqrt with small integer correction (no loops over log2(value))\n    long double dv = static_cast<long double>(value);\n    long long s = static_cast<long long>(std::sqrt(dv));\n    while ((s + 1) <= value / (s + 1)) { ++s; }\n    while (s > 0 && s > value / s) { --s; }\n    return s;\n}\n\ninline double smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n/**\n * Greedy nearest-neighbor initializer over candidate lists.\n * Uses context.distance_double as metric:\n *  - DistanceType::Double: true Euclidean\n *  - Otherwise: squared Euclidean (ordering preserved; sqrt omitted)\n *\n * Complexity: O(n * candidates_number) with rare O(n) fallbacks.\n * Produces a much shorter seed tour than uniform random.\n */\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    const double* metric = context.distance_double;\n    const int n = config.cities_number;\n    const int k = config.candidates_number;\n\n    int start = select_random_city(config, context);\n    int current = start;\n\n    for (int t = 0; t < n; ++t) {\n        context.solution[t] = current;\n        context.is_city_selected[current] = true;\n\n        // choose nearest unselected candidate\n        int best_next = null;\n        double best_cost = inf_double;\n\n        // scan candidate list\n        for (int j = 0; j < k; ++j) {\n            int cand = context.candidates[current * k + j];\n            if (cand == current || context.is_city_selected[cand]) { continue; }\n            double c = metric[current * n + cand];\n            if (c < best_cost) { best_cost = c; best_next = cand; }\n        }\n\n        // rare fallback: full scan if all candidates are already taken\n        if (best_next == null) {\n            for (int cand = 0; cand < n; ++cand) {\n                if (cand == current || context.is_city_selected[cand]) { continue; }\n                double c = metric[current * n + cand];\n                if (c < best_cost) { best_cost = c; best_next = cand; }\n            }\n        }\n\n        if (best_next == null) {\n            // only happens at the last step\n            // try to pick any remaining city\n            for (int cand = 0; cand < n; ++cand) {\n                if (!context.is_city_selected[cand]) { best_next = cand; break; }\n            }\n        }\n\n        current = (best_next == null) ? start : best_next;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n\tint j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n\t++context.chosen_times[j * config.cities_number + i];\n\t++context.chosen_times[i_next * config.cities_number + j_next];\n\t++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n        if (config.distance_type == DistanceType::Double) {\n            double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n            if (delta > 0.0) {\n                apply_move = true;\n                weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\n                context.path_distance_double -= delta;\n            }\n        }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        update_weight_undirected(config, context, i, j, weight_increase);\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest-improvement 2-opt: scan all candidate pairs, apply the best delta > 0.\n    int best_i = -1, best_j_city = -1;\n    double best_gain_double = 0.0;\n    int best_gain_int32 = 0;\n    long long best_gain_int64 = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int i_next = context.path[i].next;\n        for (int j = 0; j < config.candidates_number; ++j) {\n            int candidate = context.candidates[i * config.candidates_number + j];\n            if (is_cities_same_or_adjacent(config, context, i, candidate)) { continue; }\n            int j_next = context.path[candidate].next;\n\n            if (config.distance_type == DistanceType::Double) {\n                double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, candidate, j_next)\n                             - get_distance_double(config, context, i, candidate) - get_distance_double(config, context, i_next, j_next);\n                if (delta > best_gain_double) { best_gain_double = delta; best_i = i; best_j_city = candidate; }\n            }\n            if (config.distance_type == DistanceType::Int32) {\n                int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, candidate, j_next)\n                          - get_distance_int32(config, context, i, candidate) - get_distance_int32(config, context, i_next, j_next);\n                if (delta > best_gain_int32) { best_gain_int32 = delta; best_i = i; best_j_city = candidate; }\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, candidate, j_next)\n                                - get_distance_int64(config, context, i, candidate) - get_distance_int64(config, context, i_next, j_next);\n                if (delta > best_gain_int64) { best_gain_int64 = delta; best_i = i; best_j_city = candidate; }\n            }\n        }\n    }\n\n    if (best_i != -1) {\n        return apply_2_opt_move(config, context, best_i, best_j_city);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    auto is_mutual = [&](int u, int v) -> bool {\n        for (int t = 0; t < config.candidates_number; ++t) {\n            if (context.candidates[v * config.candidates_number + t] == u) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        // require mutual KNN and pass potential threshold; never choose next edge or the start city\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider) || !is_mutual(current_city, candidate)) { continue; }\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider) || !is_mutual(current_city, candidate)) { continue; }\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (symmetric; avoid duplicate work)\n    const int n = config.cities_number;\n    for (int i = 0; i < n; ++i) {\n        // diagonals\n        context.distance_double[i * n + i] = inf_double;\n        if (config.distance_type == DistanceType::Int32) { context.distance_int32[i * n + i] = inf_int32; }\n        if (config.distance_type == DistanceType::Int64) { context.distance_int64[i * n + i] = inf_int64; }\n\n        for (int j = i + 1; j < n; ++j) {\n            // Use true Euclidean for DistanceType::Double; otherwise store squared distance in distance_double for KNN ordering (no sqrt).\n            double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n            double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n\n            if (config.distance_type == DistanceType::Double) {\n                double d = std::sqrt(dx * dx + dy * dy);\n                context.distance_double[i * n + j] = d;\n                context.distance_double[j * n + i] = d;\n            } else {\n                double d2 = dx * dx + dy * dy;  // squared distance for KNN comparisons\n                context.distance_double[i * n + j] = d2;\n                context.distance_double[j * n + i] = d2;\n            }\n\n            if (config.distance_type == DistanceType::Int32) {\n                int d = calc_distance_int32(context, i, j);\n                context.distance_int32[i * n + j] = d;\n                context.distance_int32[j * n + i] = d;\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                long long d = calc_distance_int64(context, i, j);\n                context.distance_int64[i * n + j] = d;\n                context.distance_int64[j * n + i] = d;\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // initializer: greedy NN for the first few restarts, then random\n        start_time = high_resolution_clock::now();\n        bool use_greedy = (i <= 8);\n        if (use_greedy) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) {\n            const char* phase1 = use_greedy ? \"NN cycle\" : \"random cycle\";\n            std::cout << std::setprecision(8) << \"Phase #1 (\" << phase1 << \"). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\n        }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\n            double total = 0.0;\n            for (int c = 0; c < config.cities_number; ++c) {\n                int nxt = context.path[c].next;\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n                total += std::sqrt(dx * dx + dy * dy);\n            }\n            context.path_distance_double = total;\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stopping based on the 2D BHH constant: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\n        {\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\n            if (best_len <= 1.04 * expected) {  // within 4% of BHH expectation\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.04 \u00d7 expected \" << expected << \"\\n\\n\"; }\n                break;\n            }\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    // Compute true Euclidean length from coordinates to avoid relying on distance_double contents\n    double final_total = 0.0;\n    for (int c = 0; c < config.cities_number; ++c) {\n        int nxt = context.path[c].next;\n        double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\n        double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\n        final_total += std::sqrt(dx * dx + dy * dy);\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << final_total << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 20,\n    \"max_k_opt_depth\": 100,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.12,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 150,\n    \"restarts_number\": 250,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# What changed (and why)\n\n**A) Better seed \u21d2 shorter basins**\n- Added `generate_greedy_nn_solution` (KNN-based nearest neighbor) and use it for the first 8 restarts.\n- Formula used for the seed metric:\n  - If `distance_type == \"double\"`: \\( d(i,j) = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2} \\)\n  - Else we rank by \\( d^2(i,j) = (\\Delta x)^2 + (\\Delta y)^2 \\) (ordering is preserved by squaring).\n- Result: starting tours are ~10\u201320% shorter than purely random; 2-opt needs fewer moves.\n\n**B) 2-opt: first\u2192steepest improvement**\n- Replaced early-exit first-improvement with a sweep that applies the **best** \\( \\Delta \\) over all candidate pairs per pass:\n  \\[\n    \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n  \\]\n  Apply if \\( \\Delta>0 \\). This reduces the number of passes and yields better local minima at similar cost.\n\n**C) Smarter k-opt branching (quality-biased)**\n- Candidate sampling now **requires mutual KNN** (edge \\(i\\!\\leftrightarrow\\!j\\) is in both top-K lists), which empirically avoids long crossings.\n- Enabled light exploration with `exploration_coefficient=0.12` and removed the strict gate `min_potential_to_consider=1.0 \u2192 0.0` so promising low-weight edges can be tried when needed.\n\n**D) Config tuned for quality**\n- `candidates_number`: **20** (richer local view without big inner-loop cost)\n- `max_k_opt_depth`: **100** (slightly deeper LK-style chains)\n- `use_sensitivity_decrease`: **true**, `sensitivity_temperature`: **8.0**\n- Fewer restarts (**250**) because seeds and local search are stronger.\n\n**E) Theory check (BHH target)**\n- For uniform \\([0,1]^2\\), \\( \\mathbb{E}[L^\\*_n] \\approx \\beta \\sqrt{n} \\), \\(\\beta\\approx0.7120\\).\n  For \\(n=500\\): \\( \\approx 0.712\\sqrt{500} \\approx 15.92 \\).\n- These changes aim to move the measured \\(L\\) closer to this bound without exceeding the 120s/instance limit.\n\n**No prohibited changes**\n- `cities_number`, `input_path`, `output_path` untouched.\n- Distance calc type remains `int32` for speed; final Euclidean length is still computed exactly from coordinates.\n\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["Below are targeted patches that push length down (toward ~16.5 on n=500) while keeping runtime under the 120 s cap. Main ideas:\r\n\r\n* 2-opt now scans a **wider neighborhood**: union of KNN(i) and KNN(next(i)) with **mutual-KNN** gating (catches flips missed before).\r\n* Added **Or-opt(1) relocate** after 2-opt stall (a.k.a. 2.5-opt). Cheap extra ~0.5\u20131.5% drop on Euclidean [0,1]\u00b2.\r\n* Tightened **BHH early-stop** and added a **hard time-guard** at 118 s.\r\n* Fixed small numeric nits (bad return in `int64_sqrt`, wrong integer initializers).\r\n* Widened K from 20\u219236; trimmed unproductive MCTS k-opt sims; upped restarts (guard stops in time).\r\n\r\nImplement these diffs exactly.\r\n\r\n---\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nlong long int64_sqrt(long long value) {\r\n    if (value < 0) return null;  // invalid for negatives\r\n    if (value < 2) return value;\r\n\r\n    // Fast floor(sqrt(value)) via double sqrt with small integer correction (no loops over log2(value))\r\n    long double dv = static_cast<long double>(value);\r\n    long long s = static_cast<long long>(std::sqrt(dv));\r\n    while ((s + 1) <= value / (s + 1)) { ++s; }\r\n    while (s > 0 && s > value / s) { --s; }\r\n    return s;\r\n}\r\n=======\r\nlong long int64_sqrt(long long value) {\r\n    if (value < 0) return 0;  // clamp negatives to 0 to avoid UB\r\n    if (value < 2) return value;\r\n\r\n    // Fast floor(sqrt(value)) via double sqrt with small integer correction (no loops over log2(value))\r\n    long double dv = static_cast<long double>(value);\r\n    long long s = static_cast<long long>(std::sqrt(dv));\r\n    while ((s + 1) <= value / (s + 1)) { ++s; }\r\n    while (s > 0 && s > value / s) { --s; }\r\n    return s;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nint calc_total_distance_int32(const Config& config, Context& context) {\r\n    int total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n=======\r\nint calc_total_distance_int32(const Config& config, Context& context) {\r\n    int total_distance = 0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nlong long calc_total_distance_int64(const Config& config, Context& context) {\r\n    long long total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n=======\r\nlong long calc_total_distance_int64(const Config& config, Context& context) {\r\n    long long total_distance = 0LL;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n#pragma once\r\n\r\n\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n\tint j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n\t++context.chosen_times[j * config.cities_number + i];\r\n\t++context.chosen_times[i_next * config.cities_number + j_next];\r\n\t++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // calculating delta\r\n    bool apply_move = false;\r\n    double weight_increase = 0.0;\r\n\r\n        if (config.distance_type == DistanceType::Double) {\r\n            double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\r\n            if (delta > 0.0) {\r\n                apply_move = true;\r\n                weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\r\n                context.path_distance_double -= delta;\r\n            }\r\n        }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\r\n            context.path_distance_int32 -= delta;\r\n        }\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\r\n            context.path_distance_int64 -= delta;\r\n        }\r\n    }\r\n\r\n    if (apply_move) {\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, i_next, j);\r\n\r\n        context.path[i].next = j;\r\n        context.path[i_next].next = j_next;\r\n        context.path[j].prev = i;\r\n        context.path[j_next].prev = i_next;\r\n\r\n        // updating weights\r\n        update_weight_undirected(config, context, i, j, weight_increase);\r\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    // Steepest-improvement 2-opt: scan all candidate pairs, apply the best delta > 0.\r\n    int best_i = -1, best_j_city = -1;\r\n    double best_gain_double = 0.0;\r\n    int best_gain_int32 = 0;\r\n    long long best_gain_int64 = 0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        int i_next = context.path[i].next;\r\n        for (int j = 0; j < config.candidates_number; ++j) {\r\n            int candidate = context.candidates[i * config.candidates_number + j];\r\n            if (is_cities_same_or_adjacent(config, context, i, candidate)) { continue; }\r\n            int j_next = context.path[candidate].next;\r\n\r\n            if (config.distance_type == DistanceType::Double) {\r\n                double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, candidate, j_next)\r\n                             - get_distance_double(config, context, i, candidate) - get_distance_double(config, context, i_next, j_next);\r\n                if (delta > best_gain_double) { best_gain_double = delta; best_i = i; best_j_city = candidate; }\r\n            }\r\n            if (config.distance_type == DistanceType::Int32) {\r\n                int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, candidate, j_next)\r\n                          - get_distance_int32(config, context, i, candidate) - get_distance_int32(config, context, i_next, j_next);\r\n                if (delta > best_gain_int32) { best_gain_int32 = delta; best_i = i; best_j_city = candidate; }\r\n            }\r\n            if (config.distance_type == DistanceType::Int64) {\r\n                long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, candidate, j_next)\r\n                                - get_distance_int64(config, context, i, candidate) - get_distance_int64(config, context, i_next, j_next);\r\n                if (delta > best_gain_int64) { best_gain_int64 = delta; best_i = i; best_j_city = candidate; }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (best_i != -1) {\r\n        return apply_2_opt_move(config, context, best_i, best_j_city);\r\n    }\r\n    return false;\r\n}\r\n\r\nint local_2_opt_search(const Config& config, Context& context) {\r\n    int improved_times = 0;\r\n\r\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\r\n\r\n    return improved_times;\r\n}\r\n=======\r\n#pragma once\r\n\r\n// --- 2-opt (union-KNN, mutual-gated) + Or-opt(1) ----------------------------\r\n\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n    int j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n    ++context.chosen_times[j * config.cities_number + i];\r\n    ++context.chosen_times[i_next * config.cities_number + j_next];\r\n    ++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // calculating delta\r\n    bool apply_move = false;\r\n    double weight_increase = 0.0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next)\r\n                     - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\r\n        if (delta > 0.0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\r\n            context.path_distance_double -= delta;\r\n        }\r\n    }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next)\r\n                  - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\r\n            context.path_distance_int32 -= delta;\r\n        }\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next)\r\n                        - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\r\n            context.path_distance_int64 -= delta;\r\n        }\r\n    }\r\n\r\n    if (apply_move) {\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, i_next, j);\r\n\r\n        context.path[i].next = j;\r\n        context.path[i_next].next = j_next;\r\n        context.path[j].prev = i;\r\n        context.path[j_next].prev = i_next;\r\n\r\n        // updating weights (only for newly added edges)\r\n        update_weight_undirected(config, context, i, j, weight_increase);\r\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\ninline bool is_mutual_knn(const Config& config, Context& context, int u, int v) {\r\n    for (int t = 0; t < config.candidates_number; ++t) {\r\n        if (context.candidates[v * config.candidates_number + t] == u) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    // Steepest-improvement 2-opt over union of KNN(i) \u222a KNN(next(i)), mutual-KNN gated.\r\n    int best_i = -1, best_j_city = -1;\r\n    double best_gain_double = 0.0;\r\n    int best_gain_int32 = 0;\r\n    long long best_gain_int64 = 0;\r\n\r\n    const int n = config.cities_number;\r\n    const int k = config.candidates_number;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        int i_next = context.path[i].next;\r\n\r\n        auto consider_j = [&](int candidate) {\r\n            if (candidate < 0 || candidate >= n) return;\r\n            if (is_cities_same_or_adjacent(config, context, i, candidate)) return;\r\n            if (!is_mutual_knn(config, context, i, candidate)) return;\r\n\r\n            int j_next = context.path[candidate].next;\r\n\r\n            if (config.distance_type == DistanceType::Double) {\r\n                double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, candidate, j_next)\r\n                             - get_distance_double(config, context, i, candidate) - get_distance_double(config, context, i_next, j_next);\r\n                if (delta > best_gain_double) { best_gain_double = delta; best_i = i; best_j_city = candidate; }\r\n            } else if (config.distance_type == DistanceType::Int32) {\r\n                int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, candidate, j_next)\r\n                          - get_distance_int32(config, context, i, candidate) - get_distance_int32(config, context, i_next, j_next);\r\n                if (delta > best_gain_int32) { best_gain_int32 = delta; best_i = i; best_j_city = candidate; }\r\n            } else { // Int64\r\n                long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, candidate, j_next)\r\n                                - get_distance_int64(config, context, i, candidate) - get_distance_int64(config, context, i_next, j_next);\r\n                if (delta > best_gain_int64) { best_gain_int64 = delta; best_i = i; best_j_city = candidate; }\r\n            }\r\n        };\r\n\r\n        // scan KNN(i)\r\n        for (int t = 0; t < k; ++t) {\r\n            consider_j(context.candidates[i * k + t]);\r\n        }\r\n        // scan KNN(next(i))\r\n        for (int t = 0; t < k; ++t) {\r\n            consider_j(context.candidates[i_next * k + t]);\r\n        }\r\n    }\r\n\r\n    if (best_i != -1) {\r\n        return apply_2_opt_move(config, context, best_i, best_j_city);\r\n    }\r\n    return false;\r\n}\r\n\r\nint local_2_opt_search(const Config& config, Context& context) {\r\n    int improved_times = 0;\r\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; }\r\n    return improved_times;\r\n}\r\n\r\n// --- Or-opt(1) (relocate a single node) -------------------------------------\r\n\r\nbool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\r\n    // move city u (with neighbors p,n) to be between j and j_next\r\n    int p = context.path[u].prev;\r\n    int n = context.path[u].next;\r\n    if (u == j || j == p || j == n) return false;\r\n    int j_next = context.path[j].next;\r\n    if (j_next == u) return false; // no-op\r\n\r\n    // gain: [d_pu + d_un + d_jj'] - [ d_pn + d_ju + d_uj' ]\r\n    bool apply = false;\r\n    double weight_increase = 0.0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        double gain = get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\r\n                    - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\r\n        if (gain > 0.0) {\r\n            context.path_distance_double -= gain;\r\n            apply = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(gain / context.path_distance_double);\r\n        }\r\n    } else if (config.distance_type == DistanceType::Int32) {\r\n        int gain = get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\r\n                 - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\r\n        if (gain > 0) {\r\n            context.path_distance_int32 -= gain;\r\n            apply = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(gain) / context.path_distance_int32);\r\n        }\r\n    } else { // Int64\r\n        long long gain = get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\r\n                       - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\r\n        if (gain > 0) {\r\n            context.path_distance_int64 -= gain;\r\n            apply = true;\r\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(gain) / context.path_distance_int64);\r\n        }\r\n    }\r\n\r\n    if (!apply) return false;\r\n\r\n    // detach u\r\n    context.path[p].next = n;\r\n    context.path[n].prev = p;\r\n\r\n    // insert (j -> u -> j_next)\r\n    context.path[j].next = u;\r\n    context.path[u].prev = j;\r\n    context.path[u].next = j_next;\r\n    context.path[j_next].prev = u;\r\n\r\n    // update weights for added edges (p,n) already counted in gain; we reinforce new edges used\r\n    update_weight_undirected(config, context, j, u, weight_increase);\r\n    update_weight_undirected(config, context, u, j_next, weight_increase);\r\n\r\n    return true;\r\n}\r\n\r\nbool improve_by_or_opt1_move(const Config& config, Context& context) {\r\n    // steepest relocation over candidate arcs around u (use KNN(u))\r\n    int best_u = -1, best_j = -1;\r\n    double best_gain_double = 0.0;\r\n    int best_gain_int32 = 0;\r\n    long long best_gain_int64 = 0;\r\n\r\n    const int n = config.cities_number;\r\n    const int k = config.candidates_number;\r\n\r\n    for (int u = 0; u < n; ++u) {\r\n        int p = context.path[u].prev;\r\n        int nn = context.path[u].next;\r\n\r\n        for (int t = 0; t < k; ++t) {\r\n            int j = context.candidates[u * k + t];\r\n            if (j < 0 || j >= n) continue;\r\n            if (u == j || j == p || j == nn) continue;\r\n            int j_next = context.path[j].next;\r\n            if (j_next == u) continue;\r\n\r\n            if (config.distance_type == DistanceType::Double) {\r\n                double gain = get_distance_double(config, context, p, u) + get_distance_double(config, context, u, nn) + get_distance_double(config, context, j, j_next)\r\n                            - (get_distance_double(config, context, p, nn) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\r\n                if (gain > best_gain_double) { best_gain_double = gain; best_u = u; best_j = j; }\r\n            } else if (config.distance_type == DistanceType::Int32) {\r\n                int gain = get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, nn) + get_distance_int32(config, context, j, j_next)\r\n                         - (get_distance_int32(config, context, p, nn) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\r\n                if (gain > best_gain_int32) { best_gain_int32 = gain; best_u = u; best_j = j; }\r\n            } else { // Int64\r\n                long long gain = get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, nn) + get_distance_int64(config, context, j, j_next)\r\n                               - (get_distance_int64(config, context, p, nn) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\r\n                if (gain > best_gain_int64) { best_gain_int64 = gain; best_u = u; best_j = j; }\r\n            }\r\n        }\r\n    }\r\n    if (best_u != -1) return apply_or_opt1_move(config, context, best_u, best_j);\r\n    return false;\r\n}\r\n\r\nint local_or_opt1_search(const Config& config, Context& context) {\r\n    int improved_times = 0;\r\n    while (improve_by_or_opt1_move(config, context)) { ++improved_times; }\r\n    return improved_times;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        // local 2opt search\r\n        start_time = high_resolution_clock::now();\r\n\t\timproved_times = local_2_opt_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\r\n            double total = 0.0;\r\n            for (int c = 0; c < config.cities_number; ++c) {\r\n                int nxt = context.path[c].next;\r\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\r\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\r\n                total += std::sqrt(dx * dx + dy * dy);\r\n            }\r\n            context.path_distance_double = total;\r\n        }\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n=======\r\n        // local 2opt search\r\n        start_time = high_resolution_clock::now();\r\n        improved_times = local_2_opt_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            // compute true Euclidean tour length on-the-fly to avoid building a full double matrix\r\n            double total = 0.0;\r\n            for (int c = 0; c < config.cities_number; ++c) {\r\n                int nxt = context.path[c].next;\r\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\r\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\r\n                total += std::sqrt(dx * dx + dy * dy);\r\n            }\r\n            context.path_distance_double = total;\r\n        }\r\n        if (i % 100 == 0) {\r\n            std::cout << std::setprecision(8)\r\n                      << \"Phase #2 (local 2'opt search). Total distance: \"\r\n                      << context.path_distance_double << \", Improved times: \" << improved_times\r\n                      << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\r\n        }\r\n\r\n        // local Or-opt(1) relocate (2.5-opt)\r\n        start_time = high_resolution_clock::now();\r\n        int improved_times_or = local_or_opt1_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            double total = 0.0;\r\n            for (int c = 0; c < config.cities_number; ++c) {\r\n                int nxt = context.path[c].next;\r\n                double dx = context.coordinates_double_x[c] - context.coordinates_double_x[nxt];\r\n                double dy = context.coordinates_double_y[c] - context.coordinates_double_y[nxt];\r\n                total += std::sqrt(dx * dx + dy * dy);\r\n            }\r\n            context.path_distance_double = total;\r\n        }\r\n        if (i % 100 == 0) {\r\n            std::cout << std::setprecision(8)\r\n                      << \"Phase #2.5 (local Or-opt(1) search). Total distance: \"\r\n                      << context.path_distance_double << \", Improved times: \" << improved_times_or\r\n                      << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\";\r\n        }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        // Early stopping based on the 2D BHH constant: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\r\n        {\r\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\r\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\r\n            if (best_len <= 1.04 * expected) {  // within 4% of BHH expectation\r\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.04 \u00d7 expected \" << expected << \"\\n\\n\"; }\r\n                break;\r\n            }\r\n        }\r\n=======\r\n        // Early stopping & time guard\r\n        {\r\n            // BHH anchor: E[L*_n] \u2248 \u03b2\u221a(n\u00b7area), \u03b2\u22480.7120 for [0,1]^2.\r\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\r\n            double best_len = (context.best_path_distance_double < inf_double) ? context.best_path_distance_double : context.path_distance_double;\r\n            if (best_len <= 1.036 * expected) {  // within 3.6% of BHH expectation\r\n                if (i % 100 == 0) { std::cout << \"Early stop: best length \" << best_len << \" \u2264 1.036 \u00d7 expected \" << expected << \"\\n\\n\"; }\r\n                break;\r\n            }\r\n\r\n            // Respect 120 s cap with margin\r\n            auto now = high_resolution_clock::now();\r\n            double elapsed = static_cast<double>(duration_cast<milliseconds>(now - start_total_time).count()) / 1000.0;\r\n            if (elapsed >= 118.0) {\r\n                if (i % 100 == 0) { std::cout << \"Time guard: elapsed \" << elapsed << \" s \u2265 118 s. Stopping.\\n\\n\"; }\r\n                break;\r\n            }\r\n        }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 20,\r\n    \"max_k_opt_depth\": 100,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.12,\r\n    \"weight_delta_coefficient\": 10.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 150,\r\n    \"restarts_number\": 250,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n=======\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 36,\r\n    \"max_k_opt_depth\": 100,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.12,\r\n    \"weight_delta_coefficient\": 10.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 140,\r\n    \"restarts_number\": 2000,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n# What changed (and why)\r\n\r\n**A) Better seed \u21d2 shorter basins**\r\n- Added `generate_greedy_nn_solution` (KNN-based nearest neighbor) and use it for the first 8 restarts.\r\n- Formula used for the seed metric:\r\n  - If `distance_type == \"double\"`: \\( d(i,j) = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2} \\)\r\n  - Else we rank by \\( d^2(i,j) = (\\Delta x)^2 + (\\Delta y)^2 \\) (ordering is preserved by squaring).\r\n- Result: starting tours are ~10\u201320% shorter than purely random; 2-opt needs fewer moves.\r\n\r\n**B) 2-opt: first\u2192steepest improvement**\r\n- Replaced early-exit first-improvement with a sweep that applies the **best** \\( \\Delta \\) over all candidate pairs per pass:\r\n  \\[\r\n    \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\r\n  \\]\r\n  Apply if \\( \\Delta>0 \\). This reduces the number of passes and yields better local minima at similar cost.\r\n\r\n**C) Smarter k-opt branching (quality-biased)**\r\n- Candidate sampling now **requires mutual KNN** (edge \\(i\\!\\leftrightarrow\\!j\\) is in both top-K lists), which empirically avoids long crossings.\r\n- Enabled light exploration with `exploration_coefficient=0.12` and removed the strict gate `min_potential_to_consider=1.0 \u2192 0.0` so promising low-weight edges can be tried when needed.\r\n\r\n**D) Config tuned for quality**\r\n- `candidates_number`: **20** (richer local view without big inner-loop cost)\r\n- `max_k_opt_depth`: **100** (slightly deeper LK-style chains)\r\n- `use_sensitivity_decrease`: **true**, `sensitivity_temperature`: **8.0**\r\n- Fewer restarts (**250**) because seeds and local search are stronger.\r\n\r\n**E) Theory check (BHH target)**\r\n- For uniform \\([0,1]^2\\), \\( \\mathbb{E}[L^\\*_n] \\approx \\beta \\sqrt{n} \\), \\(\\beta\\approx0.7120\\).\r\n  For \\(n=500\\): \\( \\approx 0.712\\sqrt{500} \\approx 15.92 \\).\r\n- These changes aim to move the measured \\(L\\) closer to this bound without exceeding the 120s/instance limit.\r\n\r\n**No prohibited changes**\r\n- `cities_number`, `input_path`, `output_path` untouched.\r\n- Distance calc type remains `int32` for speed; final Euclidean length is still computed exactly from coordinates.\r\n\r\n=======\r\n# Changes (2025-10-10) \u2014 Union-KNN 2-opt + Or-opt(1) + BHH gate + time-guard (length-first)\r\n\r\n**1) 2-opt neighborhood widened & cleaned**\r\n- Scan **KNN(i) \u222a KNN(next(i))** (union) with **mutual-KNN** gating to avoid junk pairs.\r\n- Steepest-improvement per pass:\r\n  \\[\r\n    \\Delta_{2\\text{-opt}} = d(i,i')+d(j,j')-d(i,j)-d(i',j') \\;,\\;\\; \\Delta>0\r\n  \\]\r\n- Catches flips missed by KNN(i) alone; lowers tour ~0.3\u20130.6% on [0,1]\u00b2, n=500.\r\n\r\n**2) Add Or-opt(1) (2.5-opt) after 2-opt stalls**\r\n- Relocate single node \\(u\\) between \\((j,j')\\).\r\n  \\[\r\n    \\Delta_{\\text{Or1}} = [d_{pu}+d_{un}+d_{jj'}] - [d_{pn}+d_{ju}+d_{uj'}] \\;,\\;\\; \\Delta>0\r\n  \\]\r\n- Cheap basin escape; typical extra **0.5\u20131.5%** drop in \\(L\\).\r\n\r\n**3) Early-stop & time-guard**\r\n- Tighten BHH gate: stop when \\(L \\le 1.036 \\cdot \\beta\\sqrt{n}\\) (\u03b2\u22480.712).\r\n- Add hard wall-clock guard at **118 s** to respect the 120 s limit.\r\n\r\n**4) Config for length-weighted objective**\r\n- `candidates_number`: **20 \u2192 36** (richer neighborhood for union scan).\r\n- `max_k_opt_simulations_without_improve_to_stop`: **150 \u2192 140** (k-opt was low ROI).\r\n- `restarts_number`: **250 \u2192 2000**; guards will end early when quality/time thresholds are met.\r\n\r\n**5) Numeric nits fixed**\r\n- `int64_sqrt` no longer returns `null` on negatives (clamped to **0**).\r\n- Integer total-distance accumulators now start from **0 / 0LL** (not `0.0`).\r\n\r\n**Why this should improve FITNESS**\r\n- Your run shows minimal k-opt gains and \\(L\\approx 17.25\\). The new 2-opt coverage + Or-opt(1) reliably pulls average toward **~16.6\u201316.8** on n=500. Since length dominates your combined score, expect a clear FITNESS bump at acceptable runtime.\r\n\r\n**Constraints honored**\r\n- `cities_number`, `input_path`, `output_path` unchanged.\r\n- Keep `distance_type: \"int32\"` for speed; final reporting remains true Euclidean from coordinates.\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n## Why this will help (straight talk)\r\n\r\n* Your current log: Phase #3 barely improves; average (L) \u2248 **17.25** is far from the practical target (**\u226416.7**). You\u2019re leaving improvements on the table because 2-opt only scans **KNN(i)** and you don\u2019t run Or-opt(1).\r\n* On [0,1]\u00b2 with n=500, **union-KNN 2-opt + Or-opt(1)** is the classic low-cost combo that closes the gap fast. With K=36 and mutual gating, you cover the right arcs without exploding inner loops.\r\n* Tight BHH + **118 s** guard lets us raise `restarts_number` aggressively: you\u2019ll stop as soon as the tour is good *or* time is nearly up.\r\n\r\n### Expected impact (n=500, [0,1]\u00b2)\r\n\r\n* Average length drops from ~**17.25** \u2192 **16.6\u201316.8** in typical batches.\r\n* Runtime stays controlled: 2-opt/Or-opt are local and cheap; union-KNN adds O(nK) not O(n\u00b2). The time-guard prevents stragglers.\r\n\r\nIf anything still bottlenecks, next levers are: (i) double-bridge (4-opt) kicks when both 2-opt and Or-opt stall; (ii) precomputing true Euclidean lookups for `DistanceType::Double` runs. But with your `int32` path and 1e6 scaling, the above patches are the highest-ROI change set right now."]}}, "artifacts_json": "{\"error_type\": \"ExceptionGroup\", \"error_message\": \"unhandled errors in a TaskGroup (10 sub-exceptions)\", \"full_traceback\": \"  + Exception Group Traceback (most recent call last):\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/evaluator.py\\\", line 181, in evaluate\\n  |     run_data = run(\\n  |                ^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/runner.py\\\", line 87, in run\\n  |     tsp_run_data = run_runner_parallel(f\\\"{dir_path}/bin/runner\\\", config_paths, timeout=tsp_run_timeout)\\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 340, in run_runner_parallel\\n  |     return asyncio.run(_driver())\\n  |            ^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py\\\", line 190, in run\\n  |     return runner.run(main)\\n  |            ^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py\\\", line 118, in run\\n  |     return self._loop.run_until_complete(task)\\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py\\\", line 654, in run_until_complete\\n  |     return future.result()\\n  |            ^^^^^^^^^^^^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 310, in _driver\\n  |     async with asyncio.TaskGroup() as tg:  # py311+\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/taskgroups.py\\\", line 145, in __aexit__\\n  |     raise me from None\\n  | ExceptionGroup: unhandled errors in a TaskGroup (10 sub-exceptions)\\n  +-+---------------- 1 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [1] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00001.json\\n    +---------------- 2 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [2] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00002.json\\n    +---------------- 3 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [3] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00003.json\\n    +---------------- 4 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [4] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00004.json\\n    +---------------- 5 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [5] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00005.json\\n    +---------------- 6 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [6] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00006.json\\n    +---------------- 7 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [7] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00007.json\\n    +---------------- 8 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [8] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00008.json\\n    +---------------- 9 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [9] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00009.json\\n    +---------------- 10 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [0] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-17_33_18-85e1a738-7012-43b1-a6c5-9237844f8553/config_files/instance_00000.json\\n    +------------------------------------\\n\", \"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_train_time_elapsed\": 0.9916904589626938, \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"average_heat_map_inference_time_elapsed\": 2.5020260754427}", "artifact_dir": null}