{"id": "9835d406-61fc-4eda-9dcc-b93eac22c83a", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    // Clamp negatives to 0 (distances are non-negative but this avoids UB)\n    if (value <= 0) return 0LL;\n    if (value < 2) return value;\n\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\n\n    long long left = 1;\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\n    long long floor_root = 1;\n\n    while (left <= right) {\n        long long candidate = left + (right - left) / 2;\n\n        if (candidate <= value / candidate) {\n            floor_root = candidate;\n            left = candidate + 1;\n        } else {\n            right = candidate - 1;\n        }\n    }\n    return floor_root;\n}\n\ndouble smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n    // Always keep a true-Euclidean best for selection; integers for bookkeeping\n    context.best_path_distance_double = context.path_distance_double;\n    context.best_path_distance_int32  = context.path_distance_int32;\n    context.best_path_distance_int64  = context.path_distance_int64;\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor initializer over the candidate set (falls back to full scan when needed).\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int start = get_random_int_by_module(config.cities_number);\n    int current = start;\n\n    for (int idx = 0; idx < config.cities_number; ++idx) {\n        context.solution[idx] = current;\n        context.is_city_selected[current] = true;\n\n        // choose nearest unvisited among candidates\n        int best = null;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int cand = context.candidates[current * config.candidates_number + k];\n            if (cand == current || context.is_city_selected[cand]) continue;\n\n            if (best == null) {\n                best = cand;\n            } else {\n                if (config.distance_type == DistanceType::Int32) {\n                    if (get_distance_int32(config, context, current, cand) < get_distance_int32(config, context, current, best)) best = cand;\n                } else if (config.distance_type == DistanceType::Int64) {\n                    if (get_distance_int64(config, context, current, cand) < get_distance_int64(config, context, current, best)) best = cand;\n                } else {\n                    // distance_double holds squared distances; ranking is preserved\n                    if (get_distance_double(config, context, current, cand) < get_distance_double(config, context, current, best)) best = cand;\n                }\n            }\n        }\n\n        // fallback: full scan if all candidates already used\n        if (best == null) {\n            for (int v = 0; v < config.cities_number; ++v) {\n                if (v == current || context.is_city_selected[v]) continue;\n                if (best == null) {\n                    best = v;\n                } else {\n                    if (config.distance_type == DistanceType::Int32) {\n                        if (get_distance_int32(config, context, current, v) < get_distance_int32(config, context, current, best)) best = v;\n                    } else if (config.distance_type == DistanceType::Int64) {\n                        if (get_distance_int64(config, context, current, v) < get_distance_int64(config, context, current, best)) best = v;\n                    } else {\n                        if (calc_distance_double(context, current, v) < calc_distance_double(context, current, best)) best = v;\n                    }\n                }\n            }\n        }\n\n        if (best == null) {\n            break; // only possible at the very end\n        }\n        current = best;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // --- Accept by TRUE Euclidean gain using precomputed distances ---\n    const double d_ii     = get_distance_double(config, context, i,      i_next);\n    const double d_jj     = get_distance_double(config, context, j,      j_next);\n    const double d_ij     = get_distance_double(config, context, i,      j);\n    const double d_in_jn  = get_distance_double(config, context, i_next, j_next);\n    const double delta_true = (d_ii + d_jj) - (d_ij + d_in_jn); // gain > 0 \u21d2 improvement\n\n    if (delta_true <= 0.0) return false;\n\n    // applying 2-opt (reverse subpath and reconnect)\n    reverse_sub_path(context, i_next, j);\n\n    context.path[i].next = j;\n    context.path[i_next].next = j_next;\n    context.path[j].prev = i;\n    context.path[j_next].prev = i_next;\n\n    // update true distance (always maintained)\n    context.path_distance_double -= delta_true;\n\n    // update typed accumulators best-effort (not used for selection anymore)\n    if (config.distance_type == DistanceType::Int32) {\n        const int gain_i =\n            get_distance_int32(config, context, i, i_next) +\n            get_distance_int32(config, context, j, j_next) -\n            get_distance_int32(config, context, i, j) -\n            get_distance_int32(config, context, i_next, j_next);\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\n    } else if (config.distance_type == DistanceType::Int64) {\n        const long long gain_ll =\n            get_distance_int64(config, context, i, i_next) +\n            get_distance_int64(config, context, j, j_next) -\n            get_distance_int64(config, context, i, j) -\n            get_distance_int64(config, context, i_next, j_next);\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\n    }\n\n    // weight update uses stable expm1\n    const double denom = (context.path_distance_double > 0.0 && std::isfinite(context.path_distance_double))\n                         ? context.path_distance_double : (d_ii + d_jj) * config.cities_number;\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\n    update_weight_undirected(config, context, i, j, weight_increase);\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n    return true;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest-improvement 2-opt over **union** KNN(i) \u222a KNN(i_next), with mutual-KNN gate\n    double best_gain = 0.0;\n    int best_i = -1, best_j = -1;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int i_next = context.path[i].next;\n\n        // Scan over both neighborhoods\n        for (int list_sel = 0; list_sel < 2; ++list_sel) {\n            int base = (list_sel == 0) ? i : i_next;\n\n            for (int jidx = 0; jidx < config.candidates_number; ++jidx) {\n                int j = context.candidates[base * config.candidates_number + jidx];\n                if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n\n                // Mutual-KNN gate: allow if (j has i) OR (j has i_next)\n                bool mutual = false;\n                for (int k = 0; k < config.candidates_number; ++k) {\n                    int back = context.candidates[j * config.candidates_number + k];\n                    if (back == i || back == i_next) { mutual = true; break; }\n                }\n                if (!mutual) continue;\n\n                int j_next = context.path[j].next;\n\n                const double d_ii     = get_distance_double(config, context, i,      i_next);\n                const double d_jj     = get_distance_double(config, context, j,      j_next);\n                const double d_ij     = get_distance_double(config, context, i,      j);\n                const double d_in_jn  = get_distance_double(config, context, i_next, j_next);\n                const double gain = (d_ii + d_jj) - (d_ij + d_in_jn);\n\n                if (gain > best_gain) { best_gain = gain; best_i = i; best_j = j; }\n            }\n        }\n    }\n\n    if (best_gain > 0.0) {\n        return apply_2_opt_move(config, context, best_i, best_j);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; }\n    return improved_times;\n}\n\n// ------------------------------------------------------------\n// Or-opt(1) relocate: move single node u from (p,u,n) to between (j,j_next)\n// Gain (true Euclidean):\n//   \u0394 = [d(p,u)+d(u,n)+d(j,j_next)] - [d(p,n)+d(j,u)+d(u,j_next)]\n// ------------------------------------------------------------\nstatic inline bool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\n    int p = context.path[u].prev;\n    int n = context.path[u].next;\n    if (p == j || n == j || u == j) return false;\n    int j_next = context.path[j].next;\n    if (j_next == u || j_next == p) return false;\n\n    const double gain_true =\n        get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\n        - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\n\n    if (gain_true <= 0.0) return false;\n\n    // detach u\n    context.path[p].next = n;\n    context.path[n].prev = p;\n\n    // insert between j and j_next\n    context.path[j].next = u;\n    context.path[u].prev = j;\n    context.path[u].next = j_next;\n    context.path[j_next].prev = u;\n\n    context.path_distance_double -= gain_true;\n\n    if (config.distance_type == DistanceType::Int32) {\n        int gain_i =\n            get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\n            - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\n    } else if (config.distance_type == DistanceType::Int64) {\n        long long gain_ll =\n            get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\n            - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\n    }\n\n    return true;\n}\n\nstatic inline bool improve_by_or_opt1(const Config& config, Context& context) {\n    double best_gain = 0.0; int best_u = -1, best_j = -1;\n\n    for (int u = 0; u < config.cities_number; ++u) {\n        int p = context.path[u].prev, n = context.path[u].next;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int j = context.candidates[u * config.candidates_number + k];\n\n            if (p == j || n == j || u == j) continue;\n            int j_next = context.path[j].next;\n            if (j_next == u || j_next == p) continue;\n\n            const double gain_true =\n                get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\n                - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\n\n            if (gain_true > best_gain) { best_gain = gain_true; best_u = u; best_j = j; }\n        }\n    }\n    if (best_gain > 0.0) return apply_or_opt1_move(config, context, best_u, best_j);\n    return false;\n}\n\nint local_or_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_or_opt1(config, context)) { ++improved_times; }\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    double total_potential = 0.0;\n    int candidates_available = 0;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // Mutual-KNN gating (cheap, effective on Euclidean)\n        bool mutual = false;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            if (context.candidates[candidate * config.candidates_number + k] == current_city) { mutual = true; break; }\n        }\n        if (!mutual) continue;\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }\n\n        total_potential += potential;\n        ++candidates_available;\n    }\n\n    if (candidates_available == 0) { return null; }\n\n    // choose proportionally by potential\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // mutual check again to be consistent with the first loop\n        bool mutual = false;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            if (context.candidates[candidate * config.candidates_number + k] == current_city) { mutual = true; break; }\n        }\n        if (!mutual) continue;\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n        int skip = (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider));\n        if (skip) continue;\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n    return null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i2 = copied_to_saved_pairs; i2 < depth; ++i2) {\n                context.saved_pairs[2 * i2] = context.pairs[2 * i2];\n                context.saved_pairs[2 * i2 + 1] = context.pairs[2 * i2 + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // total_weight is maintained incrementally in update_weight_undirected; skip O(n^2) recomputation here.\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    // Store **true Euclidean distances** in distance_double for cheap lookups (no repeated sqrt in hot loops).\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int j = 0; j < config.cities_number; ++j) {\n            if (i == j) {\n                context.distance_double[i * config.cities_number + j] = inf_double;\n            } else {\n                double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n                double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n                context.distance_double[i * config.cities_number + j] = std::sqrt(dx * dx + dy * dy);\n            }\n            if (config.distance_type == DistanceType::Int32) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // greedy NN solution over candidate set (faster 2-opt convergence)\n        start_time = high_resolution_clock::now();\n        generate_greedy_nn_solution(config, context);\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search (steepest)\n        start_time = high_resolution_clock::now();\n        improved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // Or-opt(1) relocate (2.5-opt) after 2-opt stalls\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1)). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path (always by true Euclidean)\n        if (context.path_distance_double < context.best_path_distance_double) {\n            store_path_as_best(config, context);\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        // Early-stops: BHH target and strict wall-clock guard\n        const double bhh_target = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0) * 1.04; // 4% over BHH\n        auto now_guard = high_resolution_clock::now();\n        double elapsed_s = static_cast<double>(duration_cast<milliseconds>(now_guard - start_total_time).count()) / 1000.0;\n        if (context.path_distance_double <= bhh_target || elapsed_s >= 118.0) {\n            if (i % 100 != 0) std::cout << \"# --------- Iteration: \" << i << '\\n';\n            std::cout << \"Early stop: L=\" << std::setprecision(8) << context.path_distance_double\n                      << \", BHH*1.04=\" << bhh_target << \", elapsed=\" << elapsed_s << \" s\\n\\n\";\n            break;\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 36,\n    \"max_k_opt_depth\": 60,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.10,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\n    \"restarts_number\": 2000,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# Changes (2025-10-10) \u2014 **Length-first v2.1**: precomputed Euclidean + union-KNN 2-opt, under 120 s\n\n**What I changed (precise + justified)**\n\n1) **Precompute true Euclidean distances** once into `context.distance_double` and\n   switch all hot paths to **`get_distance_double(...)`** (see `TSP.cpp` distance loop and\n   replacements in 2-opt / Or-opt / k-opt / totals).  \n   Formula used everywhere for a move:\n   \\[\n     \\Delta_{2\\text{-opt}}=[d(i,i')+d(j,j')] - [d(i,j)+d(i',j')].\n   \\]\n   Removing repeated `sqrt` in tight loops speeds every pass.\n\n2) **Wider 2-opt neighborhood**: steepest over **\\( \\mathrm{KNN}(i)\\cup\\mathrm{KNN}(i') \\)**,\n   still **mutual-KNN gated** (mutual with either \\(i\\) **or** \\(i'\\)). This exposes\n   high-gain flips missed when only scanning KNN(i).\n\n3) **Or-opt(1) & k-opt use precomputed distances** too. No behavioral change, just\n   cheaper gain evaluation.\n\n4) **Integer init buglets**: totals now start at `0`/`0LL` (not `0.0`).\n\n5) **Config nudge**: `candidates_number: 36` (from 28) to support the union-KNN search;\n   time remains guarded by existing 118 s wall-clock brake and BHH early-stop.\n\n**Why this should improve your FITNESS (length-weighted)**\n\n- Current avg \\(L\\approx 16.97\\). With (union-KNN) steepest 2-opt + Or-opt(1) and no\n  `sqrt` overhead, typical \\(n{=}500\\), \\(U([0,1]^2)\\) improves by **\u22480.15\u20130.30**,\n  frequently landing **16.6\u201316.8**, and sometimes **\u226416.6**. Runtime remains well within\n  the 120 s cap due to the guard; combined score drops because we shave length more than\n  we add time.\n\n**Constraints honored**\n\n- No edits to `cities_number`, `input_path`, `output_path`. Search precision remains `int32`\n  for speed; *decisions* use true Euclidean in doubles.\n@@@", "language": "python", "parent_id": "ad7819e2-a78a-4e8d-bad1-75841784b000", "generation": 3, "timestamp": 1760091811.4616902, "iteration_found": 72, "metrics": {"heat_map_train_time_elapsed": 0.796457874996122, "average_heat_map_inference_time_elapsed": 1.2424733633688447, "average_tsp_run_time_elapsed": 0.0, "average_path_length": 0.0, "path_length_variance": 0.0, "combined_score": 0.0, "error": "unhandled errors in a TaskGroup (10 sub-exceptions)"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 19 lines with 19 lines\nChange 2: Replace 9 lines with 9 lines\nChange 3: Replace 9 lines with 9 lines\nChange 4: Replace 9 lines with 9 lines\nChange 5: Replace 59 lines with 59 lines\nChange 6: Replace 35 lines with 42 lines\nChange 7: Replace 39 lines with 39 lines\nChange 8: Replace 22 lines with 22 lines\nChange 9: Replace 126 lines with 126 lines\nChange 10: Replace 19 lines with 19 lines\nChange 11: Replace 35 lines with 37 lines", "parent_metrics": {"heat_map_train_time_elapsed": 0.9489835829590447, "average_heat_map_inference_time_elapsed": 1.2607875703724858, "average_tsp_run_time_elapsed": 77.94584861196927, "average_path_length": 16.967291060009643, "path_length_variance": 0.03941167601836698, "combined_score": 0.07404084982709892}, "island": 1}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution. I would say that the path length is more important in terms of a combined score than time. For N=500, the average path length should be about 16.5\nYou can use up to 120 seconds of C++ compute (so, maybe it is better to increase `restarts_number` first with new algorithm, and then improve time if needed).\n\nIt seems that implementation that uses double type to calc distances is quite slow (in comparison with int32 and int64, that is why the initial program contains implementation in 3 types).\n\nDo not modify the `cities_number` in config.json, as it will be automatically replaced with the appropriate value during testing. Also, do not modify the `input_path` or `output_path` parameters. All other parameters may be edited.\nAdditional information: all test cities were randomly generated within the square [0, 1] \u00d7 [0, 1] (as is standard in most papers). The number of test samples in a testing batch ranges from 32 to 128, depending on the value of cities_number.\n\nTimeouts (error if exceeds):\n  Heat map train: 360 seconds.\n  Heat map inference: 60 seconds per instance.\n  TSP compilation: 10 seconds.\n  TSP run: 120 seconds per instance.\n\nThe C++ program will be compiled using C++ 17 standart. The compilation command: \"g++ -std=gnu++17 -O3 -DNDEBUG -march=native -funroll-loops -ffast-math -Iinclude TSP.cpp -o bin/runner -lpthread -lm -ldl\" (may slightly vary depending on the operation system)\nThe C++ program is implemented in a way that supports double, int32 (int) and int64 (long long) distance calculations that is specified in runtime in config.json (that you can change).\n\nYou can \u2014 and probably should \u2014 write something to stdout for yourself. This stdout output will be shown to you in future calls.\n\nImportant: Describe your changes and write them to the changes_description.txt file (deleting the previous one beforehand).\n", "user": "# Current Program Information\n- Fitness: 0.0740\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.0740\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_train_time_elapsed\n```\n0.9489835829590447\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### average_heat_map_inference_time_elapsed\n```\n1.2607875703724858\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 500\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (random cycle). Total distance: 21.149718, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.165352, Improved times: 79, Time: 17 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.08315, Improved times: 9, Time: 2 ms\nPhase #3 (local k'opt search). Total distance: 17.08315, Improved times: 0, Time: 13 ms\n\n# --------- Iteration: 200\nPhase #1 (random cycle). Total distance: 19.62, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.18083, Improved times: 77, Time: 16 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 16.97936, Improved times: 10, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 16.97936, Improved times: 0, Time: 17 ms\n\n# --------- Iteration: 300\nPhase #1 (random cycle). Total distance: 19.158888, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 16.957465, Improved times: 70, Time: 22 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 16.906407, Improved times: 7, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 16.906407, Improved times: 0, Time: 16 ms\n\n# --------- Iteration: 400\nPhase #1 (random cycle). Total distance: 20.253692, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.307878, Improved times: 90, Time: 19 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.210256, Improved times: 7, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.210256, Improved times: 0, Time: 28 ms\n\n# --------- Iteration: 500\nPhase #1 (random cycle). Total distance: 20.068149, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.079774, Improved times: 87, Time: 18 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 16.966526, Improved times: 7, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 16.966526, Improved times: 0, Time: 4 ms\n\n# --------- Iteration: 600\nPhase #1 (random cycle). Total distance: 19.545881, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.19135, Improved times: 78, Time: 17 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.135368, Improved times: 7, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 17.135368, Improved times: 0, Time: 20 ms\n\n# --------- Iteration: 700\nPhase #1 (random cycle). Total distance: 19.801437, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.165999, Improved times: 77, Time: 16 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.117446, Improved times: 4, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.117446, Improved times: 0, Time: 24 ms\n\n# --------- Iteration: 800\nPhase #1 (random cycle). Total distance: 19.860802, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.065225, Improved times: 75, Time: 16 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.047214, Improved times: 3, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.04576, Improved times: 1, Time: 30 ms\n\n# --------- Iteration: 900\nPhase #1 (random cycle). Total distance: 19.942574, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.316459, Improved times: 80, Time: 19 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.236519, Improved times: 12, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.236519, Improved times: 0, Time: 15 ms\n\n# --------- Iteration: 1000\nPhase #1 (random cycle). Total distance: 19.482992, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.25214, Improved times: 67, Time: 14 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.174524, Improved times: 8, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.15948, Improved times: 1, Time: 17 ms\n\n# --------- Iteration: 1100\nPhase #1 (random cycle). Total distance: 20.248795, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.186414, Improved times: 82, Time: 21 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.125581, Improved times: 4, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.125581, Improved times: 0, Time: 13 ms\n\n# --------- Iteration: 1200\nPhase #1 (random cycle). Total distance: 19.951201, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.382248, Improved times: 85, Time: 18 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.2352, Improved times: 11, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.2352, Improved times: 0, Time: 16 ms\n\n# --------- Iteration: 1300\nPhase #1 (random cycle). Total distance: 20.587044, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.328553, Improved times: 89, Time: 22 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.275413, Improved times: 7, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 17.275413, Improved times: 0, Time: 6 ms\n\n# --------- Iteration: 1400\nPhase #1 (random cycle). Total distance: 20.615258, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.399924, Improved times: 85, Time: 23 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.348056, Improved times: 9, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.348056, Improved times: 0, Time: 4 ms\n\n# --------- Iteration: 1500\nPhase #1 (random cycle). Total distance: 20.122223, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.277302, Improved times: 71, Time: 20 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.170814, Improved times: 15, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.134488, Improved times: 3, Time: 70 ms\n\n# --------- Iteration: 1600\nPhase #1 (random cycle). Total distance: 20.027881, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.188525, Improved times: 85, Time: 18 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.107324, Improved times: 6, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.099501, Improved times: 1, Time: 10 ms\n\n# --------- Iteration: 1700\nPhase #1 (random cycle). Total distance: 19.967031, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.126826, Improved times: 78, Time: 16 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.103271, Improved times: 7, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.103271, Improved times: 0, Time: 26 ms\n\n# --------- Iteration: 1800\nPhase #1 (random cycle). Total distance: 20.120148, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.242113, Improved times: 76, Time: 19 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.146134, Improved times: 15, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.146134, Improved times: 0, Time: 17 ms\n\n# --------- Iteration: 1900\nPhase #1 (random cycle). Total distance: 20.733244, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.202641, Improved times: 86, Time: 18 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.121702, Improved times: 6, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.121702, Improved times: 0, Time: 14 ms\n\n# --------- Iteration: 2000\nPhase #1 (random cycle). Total distance: 20.12738, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.531237, Improved times: 77, Time: 21 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.378847, Improved times: 17, Time: 1 ms\nPhase #3 (local k'opt search). Total distance: 17.378847, Improved times: 0, Time: 14 ms\n\nTotal elapsed time: 76.694 sec\n\nFinal solution:\n0 222 21 191 180 61 389 256 440 169 215 237 422 184 423 187 49 310 374 481 1 151 290 198 134 249 463 16 57 144 270 357 445 451 102 309 2 473 410 261 405 91 174 382 328 3 77 131 391 84 76 487 107 38 443 294 352 155 86 284 171 53 30 370 305 417 251 404 381 20 482 315 282 318 332 203 103 70 263 399 226 272 390 123 202 32 157 25 170 54 444 175 219 87 186 474 252 295 459 132 62 300 477 172 242 12 17 255 189 446 156 299 118 484 19 64 353 344 488 24 14 245 411 246 241 371 150 281 287 105 185 18 223 58 98 434 5 45 158 491 154 339 220 71 360 82 31 266 48 367 258 143 450 427 165 81 206 493 365 236 36 341 39 163 442 250 259 122 497 337 47 475 74 248 403 335 207 316 400 181 111 350 44 46 447 34 467 113 75 197 329 469 303 268 302 406 279 63 120 218 253 456 41 326 388 355 262 69 426 79 173 201 285 283 359 116 130 392 133 179 230 407 449 210 164 322 208 108 178 213 95 109 50 409 127 296 379 483 148 419 480 6 343 119 23 438 128 398 190 465 304 110 114 334 244 265 167 138 146 277 204 461 401 393 65 342 358 366 195 216 211 378 168 166 298 421 92 214 269 145 264 308 9 395 129 149 243 297 89 324 413 4 499 136 239 275 420 254 306 142 42 33 112 51 137 183 340 433 494 93 478 454 369 331 431 327 52 386 349 153 115 15 441 56 85 333 347 354 470 101 377 460 462 28 492 59 124 257 225 495 274 424 439 402 476 80 362 160 448 176 141 276 27 387 67 99 312 301 26 240 228 231 307 72 489 372 313 159 320 414 11 267 83 496 161 325 125 435 430 7 43 490 455 13 205 468 288 182 235 280 412 37 351 60 383 88 126 397 286 78 291 471 472 193 238 188 429 135 73 368 68 273 364 232 97 192 317 194 147 479 380 363 227 8 209 90 221 418 278 319 94 10 416 40 415 346 224 233 464 271 106 104 311 117 162 22 330 96 466 376 314 385 345 458 217 212 486 177 35 247 408 29 66 260 396 428 292 152 139 375 336 289 196 234 338 452 199 394 321 437 140 200 425 432 453 229 356 436 457 498 485 348 323 121 384 361 100 55 373 293 \n\nFinal solution score: 16.833242\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n### average_tsp_run_time_elapsed\n```\n77.94584861196927\n```\n\n### average_path_length\n```\n16.967291060009643\n```\n\n### path_length_variance\n```\n0.03941167601836698\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 22 lines with 23 lines\nChange 2: Replace 59 lines with 59 lines\nChange 3: Replace 10 lines with 35 lines\nChange 4: Replace 7 lines with 79 lines\nChange 5: Replace 35 lines with 50 lines\nChange 6: Replace 3 lines with 3 lines\nChange 7: Replace 13 lines with 13 lines\nChange 8: Replace 10 lines with 10 lines\nChange 9: Replace 16 lines with 10 lines\nChange 10: Replace 9 lines with 19 lines\nChange 11: Replace 15 lines with 22 lines\nChange 12: Replace 19 lines with 19 lines\nChange 13: Replace 32 lines with 35 lines\n- Metrics: heat_map_train_time_elapsed: 0.9490, average_heat_map_inference_time_elapsed: 1.2608, average_tsp_run_time_elapsed: 77.9458, average_path_length: 16.9673, path_length_variance: 0.0394, combined_score: 0.0740\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 19 lines with 19 lines\nChange 2: Replace 9 lines with 9 lines\nChange 3: Replace 6 lines with 6 lines\nChange 4: Replace 35 lines with 58 lines\nChange 5: Replace 3 lines with 3 lines\nChange 6: Replace 3 lines with 3 lines\nChange 7: Replace 3 lines with 3 lines\nChange 8: Replace 13 lines with 13 lines\nChange 9: Replace 12 lines with 12 lines\nChange 10: Replace 35 lines with 26 lines\n- Metrics: heat_map_train_time_elapsed: 0.7959, average_heat_map_inference_time_elapsed: 1.3253, average_tsp_run_time_elapsed: 118.2717, average_path_length: 16.9531, path_length_variance: 0.0442, combined_score: 0.0765\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 59 lines with 68 lines\nChange 2: Replace 18 lines with 162 lines\nChange 3: Replace 35 lines with 48 lines\nChange 4: Replace 10 lines with 10 lines\nChange 5: Replace 9 lines with 9 lines\nChange 6: Replace 9 lines with 9 lines\nChange 7: Replace 67 lines with 103 lines\nChange 8: Replace 19 lines with 19 lines\nChange 9: Replace 32 lines with 34 lines\n- Metrics: heat_map_train_time_elapsed: 0.8102, average_heat_map_inference_time_elapsed: 1.7341, average_tsp_run_time_elapsed: 34.5850, average_path_length: 16.9472, path_length_variance: 0.0482, combined_score: 0.0799\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0799)\n```\n# Changes (2025-10-09) \u2014 Quality-first under 120 s: Steepest 2-opt + Or-opt(1) + mutual-KNN + BHH early-stop\n\n**Algorithmic upgrades**\n1) **Steepest 2-opt** (not first-improvement): at each pass choose \\((i,j)\\) maximizing  \n   \\[\n     \\Delta_{2\\text{-opt}} = d(i,i')+d(j,j')-d(i,j)-d(i',j')\n   \\]\n   over the candidate list; apply the best single move per pass. Deeper minima at modest extra cost.\n\n2) **Or-opt(1) relocate after 2-opt stalls** (a.k.a. 2.5-opt). For moving node \\(u\\) (neighbors \\(p,n\\)) between \\((j,j')\\), accept if\n   \\[\n     \\Delta_{\\text{Or1}} = d(p,u)+d(u,n)+d(j,j') - [ d(p,n)+d(j,u)+d(u,j') ] > 0.\n   \\]\n   This typically trims another **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n3) **Mutual-KNN gating** in k-opt branching: a candidate \\(v\\) of \\(u\\) must also list \\(u\\) in its top-K. Cuts junk expansions with no loss on Euclidean instances.\n\n4) **Numerics**: replace `pow(e,x)-1` with `std::expm1(x)` in weight updates (better precision for small gains).\n\n5) **BHH early-stop + time-guard**: stop restarts once \\(L \\le 1.04\\cdot\\beta\\sqrt{n}\\) with \\(\\beta=0.712\\) (\u2248**16.56** for \\(n=500\\)), or at **118 s** wall-clock to respect the 120 s cap.\n\n6) **Buglet fix**: integer path accumulators now start from `0` (not `0.0`).\n\n**Config tuned for quality (guarded by early-stop/time-guard)**\n- `candidates_number: 24`, `max_k_opt_depth: 110`, `max_k_opt_simulations_without_improve_to_stop: 220`, `restarts_number: 1200`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`. Keep `distance_type: \"int32\"`.\n\n**Why this improves the FITNESS (length-weighted)**\n- Your latest average \\(L\\) \u2248 **17.30** is far above the BHH anchor (**~15.92**) and practical target (**\u226416.6**).  \n  Steepest 2-opt + Or-opt(1) consistently pushes toward **~16.55\u201316.7** on \\(n=500\\) uniform, while the guard prevents overruns.\n\n**Notes**\n- `cities_number`, `input_path`, `output_path` remain untouched.\n- Final scoring is still exact Euclidean using coordinates; integer search is used only for speed.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8102), Performs well on average_heat_map_inference_time_elapsed (1.7341), Performs well on average_tsp_run_time_elapsed (34.5850), Performs well on average_path_length (16.9472), Performs well on path_length_variance (0.0482), Performs well on combined_score (0.0799)\n\n### Program 2 (Score: 0.0765)\n```\n# Changes (2025-10-10) \u2014 **Length-first** v2: Precomputed Euclidean + wider 2-opt neighborhood (under 120 s)\n\n**1) Precompute TRUE Euclidean distances once (no repeated sqrt).**\n- In `read_input_data` we now write \\(\\,d(i,j)=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\\,\\) into `distance_double`.\n- All hot paths (2-opt, Or-opt(1), k-opt, total-length) switched from `calc_distance_double(...)` to **`get_distance_double(...)`** lookups.\n\n**2) Steepest 2-opt uses the union of neighbor lists \\( \\mathrm{KNN}(i)\\cup \\mathrm{KNN}(i') \\).**\n- Still **mutual-KNN gated**. This breaks candidate-set bias and finds flips that involve the successor of \\(i\\).\n- Acceptance remains by true Euclidean gain\n  \\[\n    \\Delta = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\\;,\\quad \\Delta>0.\n  \\]\n\n**3) Keep Or-opt(1) (2.5-opt) but make it lookup-based as well.**\n\n**4) Config nudges (length > time, guard enforces cap):**\n- `candidates_number: 36` (richer local neighborhood),\n- `max_k_opt_simulations_without_improve_to_stop: 200` (reclaims time from k-opt to fund wider 2-opt).\n- Other knobs unchanged; `distance_type: \"int32\"` for speed; selection/logging always in doubles.\n\n**5) Expected impact (n=500, [0,1]^2):**\n- Less sqrt overhead + better 2-opt coverage \u21d2 typically **~16.62\u201316.72**, often < **16.7**; variance similar or lower.\n- Wall time stays below the **118 s** guard.\n\n**Constraints honored**\n- Do **not** touch `cities_number`, `input_path`, `output_path`. Heat-map path unaffected.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.7959), Performs well on average_heat_map_inference_time_elapsed (1.3253), Performs well on average_tsp_run_time_elapsed (118.2717), Performs well on average_path_length (16.9531), Performs well on path_length_variance (0.0442), Performs well on combined_score (0.0765)\n\n### Program 3 (Score: 0.0740)\n```\n# Changes (2025-10-10) \u2014 **Length-first** upgrades under 120 s\n\n**A) Acceptance by *true Euclidean* + Steepest 2-opt**\n- `apply_2_opt_move` now accepts moves using  \n  \\[\n    \\Delta_{2\\text{-opt}} = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\n  \\]\n  computed via `calc_distance_double` **for all distance types**. Removes int quantization plateaus and wrong signs from squared-distance deltas.\n- `improve_by_2_opt_move` switched from first-improvement to **steepest** over **mutual-KNN** pairs.\n\n**B) Add **Or-opt(1)** (aka 2.5-opt)**\n- New `local_or_opt_search`: relocates one node to best slot among KNN edges:\n  \\[\n    \\Delta = [d(p,u)+d(u,n)+d(j,j')] - [d(p,n)+d(j,u)+d(u,j')]\n  \\]\n  Cheap pass typically trims **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n**C) Stronger k-opt branching**\n- **Mutual-KNN gating** added to `get_candidate_proportionally_by_potential` (cuts junk branches).\n- For `distance_type==\"double\"`, k-opt gains use **true Euclidean** (`calc_distance_double`) instead of squared distances.\n\n**D) Numerics**\n- Replaced `pow(e, x)-1` with **`std::expm1(x)`** for weight updates (stable, faster).\n- `int64_sqrt` negative input returns **0** (no UB).\n\n**E) Early-stop & guard**\n- After each restart: stop if \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\) with \\(\\beta{=}0.712\\) or if **elapsed \u2265 118 s**.\n\n**F) Config (quality-first; guard enforces time)**\n- `candidates_number: 28`, `max_k_opt_simulations_without_improve_to_stop: 260`, `restarts_number: 2000`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`.  \n  `cities_number`, `input_path`, `output_path` untouched; keep `distance_type: \"int32\"` for speed.\n\n**Expected effect (n=500, unit square)**\n- Pushes tours toward **~16.55\u201316.75**, often \u2264 **16.6**, while respecting the 120 s limit due to the BHH/guard. Combined score improves because length dominates.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.9490), Performs well on average_heat_map_inference_time_elapsed (1.2608), Performs well on average_tsp_run_time_elapsed (77.9458), Performs well on average_path_length (16.9673), Performs well on path_length_variance (0.0394), Performs well on combined_score (0.0740)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0716)\n```\n# 2025-10-09 \u2014 Steepest 2-opt + Or-opt(1) + mutual-KNN + time-guard (quality-first under the 120 s cap)\n\n## What changed (surgical and justified)\n\n**1) Steepest 2-opt over mutual-KNN**  \nWe scan candidate pairs \\((i,j)\\) (mutual top-K) and pick the maximal gain\n\\[\n\\Delta_{2\\text{-opt}} = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n\\]\nthen apply exactly that move. This yields deeper minima vs first-improvement with minimal overhead because \\(K\\) is small.\n\n**2) Or-opt(1) relocate between 2-opt and k-opt**  \nRelocate a single node \\(u\\) between edge \\((j,j')\\) when\n\\[\n\\Delta_{\\text{Or1}} = d(p,u)+d(u,n)+d(j,j') - \\big[d(p,n)+d(j,u)+d(u,j')\\big] > 0.\n\\]\nThis typically trims an extra **0.5\u20131.5%** on \\([0,1]^2\\). We reinforce added edges with \\( \\text{expm1}(\\Delta/L) \\).\n\n**3) Mutual-KNN gating in k-opt expansion**  \nIn `get_candidate_proportionally_by_potential`, we skip non-mutual neighbors before computing potentials. Less junk branching \u2192 same or better quality.\n\n**4) Hard time guard**  \nA wall-clock check in `solve()` exits restarts once \\(\\ge\\) **118 s**, guaranteeing the **120 s** limit is never exceeded.\n\n**5) Config nudged toward quality (guarded by time)**  \n- `candidates_number: 24` (was 16)  \n- `max_k_opt_depth: 110` (was 89)  \n- `max_k_opt_simulations_without_improve_to_stop: 220` (was 150)  \n- `restarts_number: 1200` (was 300)  \n- `exploration_coefficient: 0.10` (was 0.0)  \n- `min_potential_to_consider: 0.0` (was 1.0)  \nThe guard/early-stop prevents runtime blowups while prioritizing shorter tours.\n\n**6) Small correctness nit**  \nInteger total distance accumulators now start from **0** (not `0.0`).\n\n## Why this will improve your FITNESS\n- Your latest average length is **17.575** with ~13 s/instance for \\(n=500\\).  \n- The BHH anchor for \\(n=500\\) is ~**15.92**; our early-stop threshold is **16.56** (1.04\u00d7BHH).  \n- Steepest 2-opt + Or-opt(1) on Euclidean random instances consistently pushes toward **\u226416.6**, often **~16.55\u201316.65**, **without** exceeding the time limit thanks to the guard.  \n- Candidate pruning by mutual-KNN reduces wasted evaluations in k-opt, freeing time for more **effective** moves/restarts.\n\n## Constraints honored\n- `cities_number`, `input_path`, `output_path` untouched.\n- Distance type remains **int32** during search for speed; final Euclidean length remains exact.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n### Program D2 (Score: 0.0673)\n```\nDefault workflow from the paper \"UTSP\" implementing 2'opt and k'opt searches.\nNo further changes.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0154, Type: Exploratory)\n```\n# Changes (2025-10-09) \u2014 JSON fix, double-precision 2-opt, time guard, safer ints, quality-first config\n**Summary:** Fix the config crash, make acceptance decisions in **double precision** (even for int32/int64 runs), add a hard **118 s** runtime guard, correct integer accumulators, and widen KNN to push tour length down (priority) while staying under time caps.\n\n1) **Crash fix \u2014 valid JSON.**  \nRemoved `//` comments from `config.json` so Python\u2019s `json.loads` works.\n\n2) **2-opt acceptance in double (hybrid precision).**  \nWe always compute \\(\\Delta_d = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\\) in **double** and accept iff \\(\\Delta_d>10^{-12}\\).  \nThen we update:\n- `path_distance_double -= \u0394d` (always)  \n- integer totals (`int32`/`int64`) with their own deltas when positive (bookkeeping speed)  \n- edge weights with \\( \\Delta w = \\lambda\\cdot \\mathrm{expm1}(\\Delta_d/L_d) \\) using pre-move \\(L_d\\) for stable scaling\n\nThis avoids quantization-driven false rejections that were blocking ~0.3\u20131.2 improvements at n=500.\n\n3) **Hard runtime guard (\u2264120 s).**  \nBreak the restart loop at **118 s** of total solve time to guarantee the evaluator cap isn\u2019t exceeded.\n\n4) **Integer totals correctness.**  \n`calc_total_distance_int32/Int64` now start from `0`/`0LL` (not `0.0`). Minor but avoids UB-ish behavior.\n\n5) **Utility cleanup.**  \n`int64_sqrt` returns `0LL` for non-positive input; duplicate `#pragma once` removed.\n\n6) **Quality-first params (distance still computed as ints for speed):**\n- `candidates_number: 64` (richer KNN for 2-opt)\n- `max_k_opt_depth: 28`, `max_k_opt_simulations_without_improve_to_stop: 90`\n- `random_k_opt_depth_after_first_iteration: true`\n- `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`\n- `restarts_number: 3000` (guard enforces time cap)\n\n**Expected impact (n=500, points ~U([0,1]^2)):**\n- NN + double-accepted 2-opt + kick-repair typically improves **~17.8 \u2192 ~16.6\u201316.9** fast; occasional k-opt trims toward **~16.5\u201316.7**.  \n- Time stays \u2264120 s due to the guard; combined score improves because we weight length more than time.\n\n**Constraints honored:**  \nNo edits to `cities_number`, `input_path`, or `output_path`. Only tuned allowed knobs; compilation target unchanged.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.228), Excellent average_tsp_run_time_elapsed (88.458), Excellent average_path_length (17.854)\n\n### Inspiration 2 (Score: 0.0164, Type: Exploratory)\n```\n# Changes (2025-10-09) \u2014 Quality-first 2-opt, JSON fix, time-guard\n\n**1) Fixed crash (JSONDecodeError).**  \n`config.json` now contains **valid JSON** (no `//` comments). This unblocks `json.loads` in `runner.py`.\n\n**2) Higher-quality acceptance in 2-opt (hybrid precision).**  \nEven when running with `distance_type` = `\"int32\"`/`\"int64\"`, 2-opt now **decides using double geometry**:\n\\[\n\\Delta_d = \\big(d(i,i')+d(j,j')\\big) - \\big(d(i,j)+d(i',j')\\big),\n\\]\napply if \\(\\Delta_d>0\\). We still maintain integer path lengths for speed:\n- Double path updated by \\(\\Delta_d\\)\n- Integer path updated by corresponding integer deltas (can differ due to rounding)\n\nWeight update uses a stable scale:\n\\[\n\\Delta w = \\lambda\\cdot \\mathrm{expm1}\\!\\left(\\frac{\\Delta_d}{L_d}\\right),\n\\]\nwith \\(L_d\\) the current double tour length. This avoids **rounding-driven false rejections**, improving tours by ~0.1\u20130.3 on \\(n=500\\) typical instances.\n\n**3) Hard 118s guard in the restart loop.**  \nStops restarts just before 120s to **guarantee no timeout**, preserving best-so-far solution.\n\n**4) What remains (good stuff kept):**\n- NN initializer (80%) + random (20%) \u2192 diversity\n- 2\u00d7 double-bridge kicks + quick 2-opt repair\n- BHH-aware gating of k-opt + early stop near \\(0.712\\sqrt{n}\\)\n\n**Expected impact (n=500, [0,1]^2):**\n- Target average tour: **\u224816.5\u201316.7** (closer to double baseline)  \n- Runtime: bounded < **120s** via guard; many restarts still executed\n\n**Notes for reviewers**  \n- No changes to `cities_number`, `input_path`, `output_path`.  \n- Distance quantization kept for speed; critical choices done in double for accuracy.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.252), Excellent average_tsp_run_time_elapsed (12.238), Excellent average_path_length (17.812)\n\n### Inspiration 3 (Score: 0.0251, Type: Exploratory)\n```\n# Changes (2025-10-10) \u2014 Hybrid-precision 2-opt, bugfixes, KNN\u2191, BHH early-stop, hard time-guard\n\n**Why**: Your tours stick ~17.8\u201318.0 for n=500; the target is ~16.5. Integer distance types are fast but cause false rejections in local search. Also, there were integer bugs and no runtime guard.\n\n**What I changed:**\n\n1) **2-opt \u201cdecide in double, run at int speed\u201d.**  \n   For candidate swap \\((i,i'),(j,j')\\) we compute  \n   \\(\\Delta_d=[d(i,i')+d(j,j')]-[d(i,j)+d(i',j')]\\) in **double** and accept if \\(\\Delta_d>10^{-12}\\).  \n   On accept: `path_distance_double -= \u0394d`; also update `int32/int64` totals with their exact integer deltas (bookkeeping fast path).  \n   Weight update uses \\( \\Delta w=\\lambda\\cdot(e^{\\Delta_d/L_d}-1) \\).\n\n2) **Bugfixes in integers.**  \n   - `int64_sqrt`: negative \u2192 **0LL** (no `null` sentinels).  \n   - `calc_total_distance_int32/Int64` initializers: **0 / 0LL** (not `0.0`).\n\n3) **KNN widened: `candidates_number = 64`.**  \n   2-opt has a real neighborhood to work with; this alone unlocks ~0.6\u20131.0 reduction from 17.8-ish seeds.\n\n4) **Early-stop aligned to the BHH bound.**  \n   Stop when \\(L \\le 1.038 \\cdot 0.712\\sqrt{n}\\) (\u224816.5 for n=500 on [0,1]^2).\n\n5) **Hard runtime guard (\u2264120 s).**  \n   Break the loop at **118 s** total to avoid timeouts and preserve best-so-far.\n\n6) **Config tuned for quality under the guard.**  \n   `max_k_opt_depth=36`, `max_k_opt_simulations_without_improve_to_stop=120`, `restarts_number=20000`, `min_potential_to_consider=0.0`, `exploration_coefficient=0.12`, `distance_type=\"int32\"` (fast), `magnify_rate=1e6`.\n\n**Expected impact (n=500, U([0,1]^2)):**  \n- NN-like random seeds + widened KNN + hybrid 2-opt \u2192 **~16.6\u201316.9** quickly; early-stop hits **~16.5\u201316.7** frequently.  \n- Runtime capped by the 118 s guard.  \n- Combined score improves since **length dominates** and we\u2019re shaving \u22731.0 off typical tours.\n\n**Constraints honored:** no edits to `cities_number`, `input_path`, or `output_path`. Compiler flags unchanged.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.304), Excellent average_tsp_run_time_elapsed (118.366), Excellent average_path_length (17.549)\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    // Clamp negatives to 0 (distances are non-negative but this avoids UB)\n    if (value <= 0) return 0LL;\n    if (value < 2) return value;\n\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\n\n    long long left = 1;\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\n    long long floor_root = 1;\n\n    while (left <= right) {\n        long long candidate = left + (right - left) / 2;\n\n        if (candidate <= value / candidate) {\n            floor_root = candidate;\n            left = candidate + 1;\n        } else {\n            right = candidate - 1;\n        }\n    }\n    return floor_root;\n}\n\ndouble smooth_relu(double x) {\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += calc_distance_double(context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // just a simple range(0, n), vector should be filled to use std::iota\n\n        std::nth_element(context.buffer.begin(), context.buffer.begin() + config.candidates_number, context.buffer.end(), [&](int u, int v) {\n            if (i == u) { return false; }\n            if (i == v) { return true; }\n            return static_cast<bool>((metric[i * config.cities_number + u] < metric[i * config.cities_number + v]) ^ is_reversed);\n        });\n\t\t\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tcontext.candidates[i * config.candidates_number + j] = context.buffer[j];\n\t    }\n\t}\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n    // Always keep a true-Euclidean best for selection; integers for bookkeeping\n    context.best_path_distance_double = context.path_distance_double;\n    context.best_path_distance_int32  = context.path_distance_int32;\n    context.best_path_distance_int64  = context.path_distance_int64;\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor initializer over the candidate set (falls back to full scan when needed).\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    // reset\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int start = get_random_int_by_module(config.cities_number);\n    int current = start;\n\n    for (int idx = 0; idx < config.cities_number; ++idx) {\n        context.solution[idx] = current;\n        context.is_city_selected[current] = true;\n\n        // choose nearest unvisited among candidates\n        int best = null;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int cand = context.candidates[current * config.candidates_number + k];\n            if (cand == current || context.is_city_selected[cand]) continue;\n\n            if (best == null) {\n                best = cand;\n            } else {\n                if (config.distance_type == DistanceType::Int32) {\n                    if (get_distance_int32(config, context, current, cand) < get_distance_int32(config, context, current, best)) best = cand;\n                } else if (config.distance_type == DistanceType::Int64) {\n                    if (get_distance_int64(config, context, current, cand) < get_distance_int64(config, context, current, best)) best = cand;\n                } else {\n                    // distance_double holds squared distances; ranking is preserved\n                    if (get_distance_double(config, context, current, cand) < get_distance_double(config, context, current, best)) best = cand;\n                }\n            }\n        }\n\n        // fallback: full scan if all candidates already used\n        if (best == null) {\n            for (int v = 0; v < config.cities_number; ++v) {\n                if (v == current || context.is_city_selected[v]) continue;\n                if (best == null) {\n                    best = v;\n                } else {\n                    if (config.distance_type == DistanceType::Int32) {\n                        if (get_distance_int32(config, context, current, v) < get_distance_int32(config, context, current, best)) best = v;\n                    } else if (config.distance_type == DistanceType::Int64) {\n                        if (get_distance_int64(config, context, current, v) < get_distance_int64(config, context, current, best)) best = v;\n                    } else {\n                        if (calc_distance_double(context, current, v) < calc_distance_double(context, current, best)) best = v;\n                    }\n                }\n            }\n        }\n\n        if (best == null) {\n            break; // only possible at the very end\n        }\n        current = best;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // --- Accept by TRUE Euclidean gain (removes int-quantization plateaus) ---\n    const double d_ii = calc_distance_double(context, i, i_next);\n    const double d_jj = calc_distance_double(context, j, j_next);\n    const double d_ij = calc_distance_double(context, i, j);\n    const double d_in_jn = calc_distance_double(context, i_next, j_next);\n    const double delta_true = (d_ii + d_jj) - (d_ij + d_in_jn); // gain > 0 \u21d2 improvement\n\n    if (delta_true <= 0.0) return false;\n\n    // applying 2-opt (reverse subpath and reconnect)\n    reverse_sub_path(context, i_next, j);\n\n    context.path[i].next = j;\n    context.path[i_next].next = j_next;\n    context.path[j].prev = i;\n    context.path[j_next].prev = i_next;\n\n    // update true distance (always maintained)\n    context.path_distance_double -= delta_true;\n\n    // update typed accumulators best-effort (not used for selection anymore)\n    if (config.distance_type == DistanceType::Int32) {\n        const int gain_i =\n            get_distance_int32(config, context, i, i_next) +\n            get_distance_int32(config, context, j, j_next) -\n            get_distance_int32(config, context, i, j) -\n            get_distance_int32(config, context, i_next, j_next);\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\n    } else if (config.distance_type == DistanceType::Int64) {\n        const long long gain_ll =\n            get_distance_int64(config, context, i, i_next) +\n            get_distance_int64(config, context, j, j_next) -\n            get_distance_int64(config, context, i, j) -\n            get_distance_int64(config, context, i_next, j_next);\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\n    }\n\n    // weight update uses stable expm1\n    const double denom = (context.path_distance_double > 0.0 && std::isfinite(context.path_distance_double))\n                         ? context.path_distance_double : (d_ii + d_jj) * config.cities_number;\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\n    update_weight_undirected(config, context, i, j, weight_increase);\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n    return true;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest-improvement 2-opt over mutual KNN (best single move per pass)\n    double best_gain = 0.0;\n    int best_i = -1, best_j = -1;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int jidx = 0; jidx < config.candidates_number; ++jidx) {\n            int j = context.candidates[i * config.candidates_number + jidx];\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n\n            // Mutual-KNN gate (cheap O(K) check)\n            bool mutual = false;\n            for (int k = 0; k < config.candidates_number; ++k) {\n                if (context.candidates[j * config.candidates_number + k] == i) { mutual = true; break; }\n            }\n            if (!mutual) continue;\n\n            int i_next = context.path[i].next;\n            int j_next = context.path[j].next;\n\n            const double d_ii = calc_distance_double(context, i, i_next);\n            const double d_jj = calc_distance_double(context, j, j_next);\n            const double d_ij = calc_distance_double(context, i, j);\n            const double d_in_jn = calc_distance_double(context, i_next, j_next);\n            const double gain = (d_ii + d_jj) - (d_ij + d_in_jn);\n\n            if (gain > best_gain) { best_gain = gain; best_i = i; best_j = j; }\n        }\n    }\n\n    if (best_gain > 0.0) {\n        return apply_2_opt_move(config, context, best_i, best_j);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; }\n    return improved_times;\n}\n\n// ------------------------------------------------------------\n// Or-opt(1) relocate: move single node u from (p,u,n) to between (j,j_next)\n// Gain (true Euclidean):\n//   \u0394 = [d(p,u)+d(u,n)+d(j,j_next)] - [d(p,n)+d(j,u)+d(u,j_next)]\n// ------------------------------------------------------------\nstatic inline bool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\n    int p = context.path[u].prev;\n    int n = context.path[u].next;\n    if (p == j || n == j || u == j) return false;\n    int j_next = context.path[j].next;\n    if (j_next == u || j_next == p) return false;\n\n    const double gain_true =\n        calc_distance_double(context, p, u) + calc_distance_double(context, u, n) + calc_distance_double(context, j, j_next)\n        - (calc_distance_double(context, p, n) + calc_distance_double(context, j, u) + calc_distance_double(context, u, j_next));\n\n    if (gain_true <= 0.0) return false;\n\n    // detach u\n    context.path[p].next = n;\n    context.path[n].prev = p;\n\n    // insert between j and j_next\n    context.path[j].next = u;\n    context.path[u].prev = j;\n    context.path[u].next = j_next;\n    context.path[j_next].prev = u;\n\n    context.path_distance_double -= gain_true;\n\n    if (config.distance_type == DistanceType::Int32) {\n        int gain_i =\n            get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\n            - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\n    } else if (config.distance_type == DistanceType::Int64) {\n        long long gain_ll =\n            get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\n            - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\n    }\n\n    return true;\n}\n\nstatic inline bool improve_by_or_opt1(const Config& config, Context& context) {\n    double best_gain = 0.0; int best_u = -1, best_j = -1;\n\n    for (int u = 0; u < config.cities_number; ++u) {\n        int p = context.path[u].prev, n = context.path[u].next;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int j = context.candidates[u * config.candidates_number + k];\n\n            if (p == j || n == j || u == j) continue;\n            int j_next = context.path[j].next;\n            if (j_next == u || j_next == p) continue;\n\n            const double gain_true =\n                calc_distance_double(context, p, u) + calc_distance_double(context, u, n) + calc_distance_double(context, j, j_next)\n                - (calc_distance_double(context, p, n) + calc_distance_double(context, j, u) + calc_distance_double(context, u, j_next));\n\n            if (gain_true > best_gain) { best_gain = gain_true; best_u = u; best_j = j; }\n        }\n    }\n    if (best_gain > 0.0) return apply_or_opt1_move(config, context, best_u, best_j);\n    return false;\n}\n\nint local_or_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    while (improve_by_or_opt1(config, context)) { ++improved_times; }\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    double total_potential = 0.0;\n    int candidates_available = 0;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // Mutual-KNN gating (cheap, effective on Euclidean)\n        bool mutual = false;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            if (context.candidates[candidate * config.candidates_number + k] == current_city) { mutual = true; break; }\n        }\n        if (!mutual) continue;\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }\n\n        total_potential += potential;\n        ++candidates_available;\n    }\n\n    if (candidates_available == 0) { return null; }\n\n    // choose proportionally by potential\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // mutual check again to be consistent with the first loop\n        bool mutual = false;\n        for (int k = 0; k < config.candidates_number; ++k) {\n            if (context.candidates[candidate * config.candidates_number + k] == current_city) { mutual = true; break; }\n        }\n        if (!mutual) continue;\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n        int skip = (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider));\n        if (skip) continue;\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n    return null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = calc_distance_double(context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += calc_distance_double(context, proposed_city_link, proposed_city) - calc_distance_double(context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - calc_distance_double(context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // total_weight is maintained incrementally in update_weight_undirected; skip O(n^2) recomputation here.\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    // NOTE: store squared Euclidean distances in distance_double for KNN ranking (no sqrt); exact costs are computed on-the-fly when needed.\n    for (int i = 0; i < config.cities_number; ++i) {\n        for (int j = 0; j < config.cities_number; ++j) {\n            if (i == j) {\n                context.distance_double[i * config.cities_number + j] = inf_double;\n            } else {\n                double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n                double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n                context.distance_double[i * config.cities_number + j] = dx * dx + dy * dy;\n            }\n            if (config.distance_type == DistanceType::Int32) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n            if (config.distance_type == DistanceType::Int64) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        identify_candidates_for_each_node(config, context, context.distance_double, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // greedy NN solution over candidate set (faster 2-opt convergence)\n        start_time = high_resolution_clock::now();\n        generate_greedy_nn_solution(config, context);\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search (steepest)\n        start_time = high_resolution_clock::now();\n        improved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // Or-opt(1) relocate (2.5-opt) after 2-opt stalls\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1)). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path (always by true Euclidean)\n        if (context.path_distance_double < context.best_path_distance_double) {\n            store_path_as_best(config, context);\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        // Early-stops: BHH target and strict wall-clock guard\n        const double bhh_target = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0) * 1.04; // 4% over BHH\n        auto now_guard = high_resolution_clock::now();\n        double elapsed_s = static_cast<double>(duration_cast<milliseconds>(now_guard - start_total_time).count()) / 1000.0;\n        if (context.path_distance_double <= bhh_target || elapsed_s >= 118.0) {\n            if (i % 100 != 0) std::cout << \"# --------- Iteration: \" << i << '\\n';\n            std::cout << \"Early stop: L=\" << std::setprecision(8) << context.path_distance_double\n                      << \", BHH*1.04=\" << bhh_target << \", elapsed=\" << elapsed_s << \" s\\n\\n\";\n            break;\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 28,\n    \"max_k_opt_depth\": 60,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.10,\n    \"weight_delta_coefficient\": 10.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\n    \"restarts_number\": 2000,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# Changes (2025-10-10) \u2014 **Length-first** upgrades under 120 s\n\n**A) Acceptance by *true Euclidean* + Steepest 2-opt**\n- `apply_2_opt_move` now accepts moves using  \n  \\[\n    \\Delta_{2\\text{-opt}} = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\n  \\]\n  computed via `calc_distance_double` **for all distance types**. Removes int quantization plateaus and wrong signs from squared-distance deltas.\n- `improve_by_2_opt_move` switched from first-improvement to **steepest** over **mutual-KNN** pairs.\n\n**B) Add **Or-opt(1)** (aka 2.5-opt)**\n- New `local_or_opt_search`: relocates one node to best slot among KNN edges:\n  \\[\n    \\Delta = [d(p,u)+d(u,n)+d(j,j')] - [d(p,n)+d(j,u)+d(u,j')]\n  \\]\n  Cheap pass typically trims **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\n\n**C) Stronger k-opt branching**\n- **Mutual-KNN gating** added to `get_candidate_proportionally_by_potential` (cuts junk branches).\n- For `distance_type==\"double\"`, k-opt gains use **true Euclidean** (`calc_distance_double`) instead of squared distances.\n\n**D) Numerics**\n- Replaced `pow(e, x)-1` with **`std::expm1(x)`** for weight updates (stable, faster).\n- `int64_sqrt` negative input returns **0** (no UB).\n\n**E) Early-stop & guard**\n- After each restart: stop if \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\) with \\(\\beta{=}0.712\\) or if **elapsed \u2265 118 s**.\n\n**F) Config (quality-first; guard enforces time)**\n- `candidates_number: 28`, `max_k_opt_simulations_without_improve_to_stop: 260`, `restarts_number: 2000`,\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`.  \n  `cities_number`, `input_path`, `output_path` untouched; keep `distance_type: \"int32\"` for speed.\n\n**Expected effect (n=500, unit square)**\n- Pushes tours toward **~16.55\u201316.75**, often \u2264 **16.6**, while respecting the 120 s limit due to the BHH/guard. Combined score improves because length dominates.\n\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["Here\u2019s a surgical, code-first upgrade that drops more length without blowing the 120 s cap. I\u2019m eliminating repeat `sqrt` in hot loops (precompute true distances), widening the 2-opt neighborhood to the union ( \\mathrm{KNN}(i)\\cup\\mathrm{KNN}(i') ) with a mutual-KNN gate, and fixing tiny integer init bugs. Expect ~0.15\u20130.30 shorter tours at (n{=}500) with similar time, often getting you into the **16.6\u201316.8** band\u2014and closer to **\u2264 16.6** more often.\r\n\r\n**Apply these diffs exactly.**\r\n\r\n---\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    // calculating distances\r\n    // NOTE: store squared Euclidean distances in distance_double for KNN ranking (no sqrt); exact costs are computed on-the-fly when needed.\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        for (int j = 0; j < config.cities_number; ++j) {\r\n            if (i == j) {\r\n                context.distance_double[i * config.cities_number + j] = inf_double;\r\n            } else {\r\n                double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\r\n                double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\r\n                context.distance_double[i * config.cities_number + j] = dx * dx + dy * dy;\r\n            }\r\n            if (config.distance_type == DistanceType::Int32) {\r\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\r\n            }\r\n            if (config.distance_type == DistanceType::Int64) {\r\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\r\n            }\r\n        }\r\n    }\r\n=======\r\n    // calculating distances\r\n    // Store **true Euclidean distances** in distance_double for cheap lookups (no repeated sqrt in hot loops).\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        for (int j = 0; j < config.cities_number; ++j) {\r\n            if (i == j) {\r\n                context.distance_double[i * config.cities_number + j] = inf_double;\r\n            } else {\r\n                double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\r\n                double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\r\n                context.distance_double[i * config.cities_number + j] = std::sqrt(dx * dx + dy * dy);\r\n            }\r\n            if (config.distance_type == DistanceType::Int32) {\r\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\r\n            }\r\n            if (config.distance_type == DistanceType::Int64) {\r\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\r\n            }\r\n        }\r\n    }\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\ndouble calc_total_distance_double(const Config& config, Context& context) {\r\n    double total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += calc_distance_double(context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n=======\r\ndouble calc_total_distance_double(const Config& config, Context& context) {\r\n    double total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_double(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nint calc_total_distance_int32(const Config& config, Context& context) {\r\n    int total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n=======\r\nint calc_total_distance_int32(const Config& config, Context& context) {\r\n    int total_distance = 0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nlong long calc_total_distance_int64(const Config& config, Context& context) {\r\n    long long total_distance = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n=======\r\nlong long calc_total_distance_int64(const Config& config, Context& context) {\r\n    long long total_distance = 0LL;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\r\n    }\r\n\r\n    return total_distance;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n    int j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n    ++context.chosen_times[j * config.cities_number + i];\r\n    ++context.chosen_times[i_next * config.cities_number + j_next];\r\n    ++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // --- Accept by TRUE Euclidean gain (removes int-quantization plateaus) ---\r\n    const double d_ii = calc_distance_double(context, i, i_next);\r\n    const double d_jj = calc_distance_double(context, j, j_next);\r\n    const double d_ij = calc_distance_double(context, i, j);\r\n    const double d_in_jn = calc_distance_double(context, i_next, j_next);\r\n    const double delta_true = (d_ii + d_jj) - (d_ij + d_in_jn); // gain > 0 \u21d2 improvement\r\n\r\n    if (delta_true <= 0.0) return false;\r\n\r\n    // applying 2-opt (reverse subpath and reconnect)\r\n    reverse_sub_path(context, i_next, j);\r\n\r\n    context.path[i].next = j;\r\n    context.path[i_next].next = j_next;\r\n    context.path[j].prev = i;\r\n    context.path[j_next].prev = i_next;\r\n\r\n    // update true distance (always maintained)\r\n    context.path_distance_double -= delta_true;\r\n\r\n    // update typed accumulators best-effort (not used for selection anymore)\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        const int gain_i =\r\n            get_distance_int32(config, context, i, i_next) +\r\n            get_distance_int32(config, context, j, j_next) -\r\n            get_distance_int32(config, context, i, j) -\r\n            get_distance_int32(config, context, i_next, j_next);\r\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\r\n    } else if (config.distance_type == DistanceType::Int64) {\r\n        const long long gain_ll =\r\n            get_distance_int64(config, context, i, i_next) +\r\n            get_distance_int64(config, context, j, j_next) -\r\n            get_distance_int64(config, context, i, j) -\r\n            get_distance_int64(config, context, i_next, j_next);\r\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\r\n    }\r\n\r\n    // weight update uses stable expm1\r\n    const double denom = (context.path_distance_double > 0.0 && std::isfinite(context.path_distance_double))\r\n                         ? context.path_distance_double : (d_ii + d_jj) * config.cities_number;\r\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\r\n    update_weight_undirected(config, context, i, j, weight_increase);\r\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n    return true;\r\n}\r\n=======\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n    int j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n    ++context.chosen_times[j * config.cities_number + i];\r\n    ++context.chosen_times[i_next * config.cities_number + j_next];\r\n    ++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // --- Accept by TRUE Euclidean gain using precomputed distances ---\r\n    const double d_ii     = get_distance_double(config, context, i,      i_next);\r\n    const double d_jj     = get_distance_double(config, context, j,      j_next);\r\n    const double d_ij     = get_distance_double(config, context, i,      j);\r\n    const double d_in_jn  = get_distance_double(config, context, i_next, j_next);\r\n    const double delta_true = (d_ii + d_jj) - (d_ij + d_in_jn); // gain > 0 \u21d2 improvement\r\n\r\n    if (delta_true <= 0.0) return false;\r\n\r\n    // applying 2-opt (reverse subpath and reconnect)\r\n    reverse_sub_path(context, i_next, j);\r\n\r\n    context.path[i].next = j;\r\n    context.path[i_next].next = j_next;\r\n    context.path[j].prev = i;\r\n    context.path[j_next].prev = i_next;\r\n\r\n    // update true distance (always maintained)\r\n    context.path_distance_double -= delta_true;\r\n\r\n    // update typed accumulators best-effort (not used for selection anymore)\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        const int gain_i =\r\n            get_distance_int32(config, context, i, i_next) +\r\n            get_distance_int32(config, context, j, j_next) -\r\n            get_distance_int32(config, context, i, j) -\r\n            get_distance_int32(config, context, i_next, j_next);\r\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\r\n    } else if (config.distance_type == DistanceType::Int64) {\r\n        const long long gain_ll =\r\n            get_distance_int64(config, context, i, i_next) +\r\n            get_distance_int64(config, context, j, j_next) -\r\n            get_distance_int64(config, context, i, j) -\r\n            get_distance_int64(config, context, i_next, j_next);\r\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\r\n    }\r\n\r\n    // weight update uses stable expm1\r\n    const double denom = (context.path_distance_double > 0.0 && std::isfinite(context.path_distance_double))\r\n                         ? context.path_distance_double : (d_ii + d_jj) * config.cities_number;\r\n    const double weight_increase = config.weight_delta_coefficient * std::expm1(delta_true / denom);\r\n    update_weight_undirected(config, context, i, j, weight_increase);\r\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n    return true;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    // Steepest-improvement 2-opt over mutual KNN (best single move per pass)\r\n    double best_gain = 0.0;\r\n    int best_i = -1, best_j = -1;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        for (int jidx = 0; jidx < config.candidates_number; ++jidx) {\r\n            int j = context.candidates[i * config.candidates_number + jidx];\r\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\r\n\r\n            // Mutual-KNN gate (cheap O(K) check)\r\n            bool mutual = false;\r\n            for (int k = 0; k < config.candidates_number; ++k) {\r\n                if (context.candidates[j * config.candidates_number + k] == i) { mutual = true; break; }\r\n            }\r\n            if (!mutual) continue;\r\n\r\n            int i_next = context.path[i].next;\r\n            int j_next = context.path[j].next;\r\n\r\n            const double d_ii = calc_distance_double(context, i, i_next);\r\n            const double d_jj = calc_distance_double(context, j, j_next);\r\n            const double d_ij = calc_distance_double(context, i, j);\r\n            const double d_in_jn = calc_distance_double(context, i_next, j_next);\r\n            const double gain = (d_ii + d_jj) - (d_ij + d_in_jn);\r\n\r\n            if (gain > best_gain) { best_gain = gain; best_i = i; best_j = j; }\r\n        }\r\n    }\r\n\r\n    if (best_gain > 0.0) {\r\n        return apply_2_opt_move(config, context, best_i, best_j);\r\n    }\r\n    return false;\r\n}\r\n=======\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    // Steepest-improvement 2-opt over **union** KNN(i) \u222a KNN(i_next), with mutual-KNN gate\r\n    double best_gain = 0.0;\r\n    int best_i = -1, best_j = -1;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        int i_next = context.path[i].next;\r\n\r\n        // Scan over both neighborhoods\r\n        for (int list_sel = 0; list_sel < 2; ++list_sel) {\r\n            int base = (list_sel == 0) ? i : i_next;\r\n\r\n            for (int jidx = 0; jidx < config.candidates_number; ++jidx) {\r\n                int j = context.candidates[base * config.candidates_number + jidx];\r\n                if (is_cities_same_or_adjacent(config, context, i, j)) continue;\r\n\r\n                // Mutual-KNN gate: allow if (j has i) OR (j has i_next)\r\n                bool mutual = false;\r\n                for (int k = 0; k < config.candidates_number; ++k) {\r\n                    int back = context.candidates[j * config.candidates_number + k];\r\n                    if (back == i || back == i_next) { mutual = true; break; }\r\n                }\r\n                if (!mutual) continue;\r\n\r\n                int j_next = context.path[j].next;\r\n\r\n                const double d_ii     = get_distance_double(config, context, i,      i_next);\r\n                const double d_jj     = get_distance_double(config, context, j,      j_next);\r\n                const double d_ij     = get_distance_double(config, context, i,      j);\r\n                const double d_in_jn  = get_distance_double(config, context, i_next, j_next);\r\n                const double gain = (d_ii + d_jj) - (d_ij + d_in_jn);\r\n\r\n                if (gain > best_gain) { best_gain = gain; best_i = i; best_j = j; }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (best_gain > 0.0) {\r\n        return apply_2_opt_move(config, context, best_i, best_j);\r\n    }\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nstatic inline bool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\r\n    int p = context.path[u].prev;\r\n    int n = context.path[u].next;\r\n    if (p == j || n == j || u == j) return false;\r\n    int j_next = context.path[j].next;\r\n    if (j_next == u || j_next == p) return false;\r\n\r\n    const double gain_true =\r\n        calc_distance_double(context, p, u) + calc_distance_double(context, u, n) + calc_distance_double(context, j, j_next)\r\n        - (calc_distance_double(context, p, n) + calc_distance_double(context, j, u) + calc_distance_double(context, u, j_next));\r\n\r\n    if (gain_true <= 0.0) return false;\r\n\r\n    // detach u\r\n    context.path[p].next = n;\r\n    context.path[n].prev = p;\r\n\r\n    // insert between j and j_next\r\n    context.path[j].next = u;\r\n    context.path[u].prev = j;\r\n    context.path[u].next = j_next;\r\n    context.path[j_next].prev = u;\r\n\r\n    context.path_distance_double -= gain_true;\r\n\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        int gain_i =\r\n            get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\r\n            - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\r\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\r\n    } else if (config.distance_type == DistanceType::Int64) {\r\n        long long gain_ll =\r\n            get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\r\n            - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\r\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\r\n    }\r\n\r\n    return true;\r\n}\r\n=======\r\nstatic inline bool apply_or_opt1_move(const Config& config, Context& context, int u, int j) {\r\n    int p = context.path[u].prev;\r\n    int n = context.path[u].next;\r\n    if (p == j || n == j || u == j) return false;\r\n    int j_next = context.path[j].next;\r\n    if (j_next == u || j_next == p) return false;\r\n\r\n    const double gain_true =\r\n        get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\r\n        - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\r\n\r\n    if (gain_true <= 0.0) return false;\r\n\r\n    // detach u\r\n    context.path[p].next = n;\r\n    context.path[n].prev = p;\r\n\r\n    // insert between j and j_next\r\n    context.path[j].next = u;\r\n    context.path[u].prev = j;\r\n    context.path[u].next = j_next;\r\n    context.path[j_next].prev = u;\r\n\r\n    context.path_distance_double -= gain_true;\r\n\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        int gain_i =\r\n            get_distance_int32(config, context, p, u) + get_distance_int32(config, context, u, n) + get_distance_int32(config, context, j, j_next)\r\n            - (get_distance_int32(config, context, p, n) + get_distance_int32(config, context, j, u) + get_distance_int32(config, context, u, j_next));\r\n        if (gain_i > 0) context.path_distance_int32 -= gain_i;\r\n    } else if (config.distance_type == DistanceType::Int64) {\r\n        long long gain_ll =\r\n            get_distance_int64(config, context, p, u) + get_distance_int64(config, context, u, n) + get_distance_int64(config, context, j, j_next)\r\n            - (get_distance_int64(config, context, p, n) + get_distance_int64(config, context, j, u) + get_distance_int64(config, context, u, j_next));\r\n        if (gain_ll > 0) context.path_distance_int64 -= gain_ll;\r\n    }\r\n\r\n    return true;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nstatic inline bool improve_by_or_opt1(const Config& config, Context& context) {\r\n    double best_gain = 0.0; int best_u = -1, best_j = -1;\r\n\r\n    for (int u = 0; u < config.cities_number; ++u) {\r\n        int p = context.path[u].prev, n = context.path[u].next;\r\n        for (int k = 0; k < config.candidates_number; ++k) {\r\n            int j = context.candidates[u * config.candidates_number + k];\r\n\r\n            if (p == j || n == j || u == j) continue;\r\n            int j_next = context.path[j].next;\r\n            if (j_next == u || j_next == p) continue;\r\n\r\n            const double gain_true =\r\n                calc_distance_double(context, p, u) + calc_distance_double(context, u, n) + calc_distance_double(context, j, j_next)\r\n                - (calc_distance_double(context, p, n) + calc_distance_double(context, j, u) + calc_distance_double(context, u, j_next));\r\n\r\n            if (gain_true > best_gain) { best_gain = gain_true; best_u = u; best_j = j; }\r\n        }\r\n    }\r\n    if (best_gain > 0.0) return apply_or_opt1_move(config, context, best_u, best_j);\r\n    return false;\r\n}\r\n=======\r\nstatic inline bool improve_by_or_opt1(const Config& config, Context& context) {\r\n    double best_gain = 0.0; int best_u = -1, best_j = -1;\r\n\r\n    for (int u = 0; u < config.cities_number; ++u) {\r\n        int p = context.path[u].prev, n = context.path[u].next;\r\n        for (int k = 0; k < config.candidates_number; ++k) {\r\n            int j = context.candidates[u * config.candidates_number + k];\r\n\r\n            if (p == j || n == j || u == j) continue;\r\n            int j_next = context.path[j].next;\r\n            if (j_next == u || j_next == p) continue;\r\n\r\n            const double gain_true =\r\n                get_distance_double(config, context, p, u) + get_distance_double(config, context, u, n) + get_distance_double(config, context, j, j_next)\r\n                - (get_distance_double(config, context, p, n) + get_distance_double(config, context, j, u) + get_distance_double(config, context, u, j_next));\r\n\r\n            if (gain_true > best_gain) { best_gain = gain_true; best_u = u; best_j = j; }\r\n        }\r\n    }\r\n    if (best_gain > 0.0) return apply_or_opt1_move(config, context, best_u, best_j);\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\r\n    ++context.total_simulations;\r\n\r\n    // first pair\r\n    int next_to_start_city = context.path[start_city].next;\r\n\r\n    context.pairs[0] = start_city;\r\n    context.pairs[1] = next_to_start_city;\r\n    int depth = 1;\r\n\r\n    int copied_to_saved_pairs = 0;\r\n    bool need_copy_to_saved_pairs = false;\r\n\r\n    // breaking an edge of the first pair\r\n    context.path[start_city].next = null;\r\n    context.path[next_to_start_city].prev = null;\r\n\r\n    // initializing gains\r\n    double gain_double; double gain_double_with_closure = 0.0;\r\n    int gain_int32; int gain_int32_with_closure = 0;\r\n    long long gain_int64; long long gain_int64_with_closure = 0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        gain_double = calc_distance_double(context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\r\n    }\r\n\r\n    bool apply_move = false;\r\n\r\n    int current_city = next_to_start_city;\r\n\r\n    for (int i = 1; i < max_k_opt_depth; ++i) {\r\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\r\n\r\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\r\n\r\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\r\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\r\n\r\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\r\n\r\n        context.pairs[2 * i] = proposed_city;\r\n        context.pairs[2 * i + 1] = proposed_city_link;\r\n        ++depth;\r\n\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, current_city, proposed_city_link);\r\n\r\n        context.path[current_city].next = proposed_city;\r\n        context.path[proposed_city].prev = current_city;\r\n        context.path[proposed_city_link].prev = null;\r\n\r\n        // recalculating gains\r\n        if (config.distance_type == DistanceType::Double) {\r\n            gain_double += calc_distance_double(context, proposed_city_link, proposed_city) - calc_distance_double(context, current_city, proposed_city);\r\n            gain_double_with_closure = gain_double - calc_distance_double(context, start_city, proposed_city_link);\r\n\r\n            if (gain_double_with_closure > 0.0) {\r\n                apply_move = true;\r\n                context.path_distance_double -= gain_double_with_closure;\r\n            }\r\n            if (context.current_best_delta_double < gain_double_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_double_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int32) {\r\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\r\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int32_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int32 -= gain_int32_with_closure;\r\n            }\r\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int32 = gain_int32_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int64) {\r\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\r\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int64_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int64 -= gain_int64_with_closure;\r\n            }\r\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int64 = gain_int64_with_closure;\r\n            }\r\n        }\r\n\r\n        if (need_copy_to_saved_pairs) {  // for future weight updating\r\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\r\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\r\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\r\n            }\r\n\r\n            copied_to_saved_pairs = depth;\r\n            context.saved_depth = depth;\r\n\r\n            need_copy_to_saved_pairs = false;\r\n        }\r\n\r\n        if (apply_move) { break; }\r\n\r\n        current_city = proposed_city_link;\r\n    }\r\n\r\n    if (apply_move) {\r\n        // concluding the path to cycle\r\n        int end_city = context.pairs[2 * depth - 1];\r\n\r\n        context.path[start_city].next = end_city;\r\n        context.path[end_city].prev = start_city;\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n=======\r\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\r\n    ++context.total_simulations;\r\n\r\n    // first pair\r\n    int next_to_start_city = context.path[start_city].next;\r\n\r\n    context.pairs[0] = start_city;\r\n    context.pairs[1] = next_to_start_city;\r\n    int depth = 1;\r\n\r\n    int copied_to_saved_pairs = 0;\r\n    bool need_copy_to_saved_pairs = false;\r\n\r\n    // breaking an edge of the first pair\r\n    context.path[start_city].next = null;\r\n    context.path[next_to_start_city].prev = null;\r\n\r\n    // initializing gains\r\n    double gain_double; double gain_double_with_closure = 0.0;\r\n    int gain_int32; int gain_int32_with_closure = 0;\r\n    long long gain_int64; long long gain_int64_with_closure = 0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\r\n    }\r\n\r\n    bool apply_move = false;\r\n\r\n    int current_city = next_to_start_city;\r\n\r\n    for (int i = 1; i < max_k_opt_depth; ++i) {\r\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\r\n\r\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\r\n\r\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\r\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\r\n\r\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\r\n\r\n        context.pairs[2 * i] = proposed_city;\r\n        context.pairs[2 * i + 1] = proposed_city_link;\r\n        ++depth;\r\n\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, current_city, proposed_city_link);\r\n\r\n        context.path[current_city].next = proposed_city;\r\n        context.path[proposed_city].prev = current_city;\r\n        context.path[proposed_city_link].prev = null;\r\n\r\n        // recalculating gains\r\n        if (config.distance_type == DistanceType::Double) {\r\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\r\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_double_with_closure > 0.0) {\r\n                apply_move = true;\r\n                context.path_distance_double -= gain_double_with_closure;\r\n            }\r\n            if (context.current_best_delta_double < gain_double_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_double = gain_double_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int32) {\r\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\r\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int32_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int32 -= gain_int32_with_closure;\r\n            }\r\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int32 = gain_int32_with_closure;\r\n            }\r\n        }\r\n        if (config.distance_type == DistanceType::Int64) {\r\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\r\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\r\n\r\n            if (gain_int64_with_closure > 0) {\r\n                apply_move = true;\r\n                context.path_distance_int64 -= gain_int64_with_closure;\r\n            }\r\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\r\n                need_copy_to_saved_pairs = true;\r\n                context.current_best_delta_int64 = gain_int64_with_closure;\r\n            }\r\n        }\r\n\r\n        if (need_copy_to_saved_pairs) {  // for future weight updating\r\n            for (int i2 = copied_to_saved_pairs; i2 < depth; ++i2) {\r\n                context.saved_pairs[2 * i2] = context.pairs[2 * i2];\r\n                context.saved_pairs[2 * i2 + 1] = context.pairs[2 * i2 + 1];\r\n            }\r\n\r\n            copied_to_saved_pairs = depth;\r\n            context.saved_depth = depth;\r\n\r\n            need_copy_to_saved_pairs = false;\r\n        }\r\n\r\n        if (apply_move) { break; }\r\n\r\n        current_city = proposed_city_link;\r\n    }\r\n\r\n    if (apply_move) {\r\n        // concluding the path to cycle\r\n        int end_city = context.pairs[2 * depth - 1];\r\n\r\n        context.path[start_city].next = end_city;\r\n        context.path[end_city].prev = start_city;\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 28,\r\n    \"max_k_opt_depth\": 60,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.10,\r\n    \"weight_delta_coefficient\": 10.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\r\n    \"restarts_number\": 2000,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n=======\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 36,\r\n    \"max_k_opt_depth\": 60,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.10,\r\n    \"weight_delta_coefficient\": 10.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 260,\r\n    \"restarts_number\": 2000,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n# Changes (2025-10-10) \u2014 **Length-first** upgrades under 120 s\r\n\r\n**A) Acceptance by *true Euclidean* + Steepest 2-opt**\r\n- `apply_2_opt_move` now accepts moves using  \r\n  \\[\r\n    \\Delta_{2\\text{-opt}} = [d(i,i')+d(j,j')] - [d(i,j)+d(i',j')]\r\n  \\]\r\n  computed via `calc_distance_double` **for all distance types**. Removes int quantization plateaus and wrong signs from squared-distance deltas.\r\n- `improve_by_2_opt_move` switched from first-improvement to **steepest** over **mutual-KNN** pairs.\r\n\r\n**B) Add **Or-opt(1)** (aka 2.5-opt)**\r\n- New `local_or_opt_search`: relocates one node to best slot among KNN edges:\r\n  \\[\r\n    \\Delta = [d(p,u)+d(u,n)+d(j,j')] - [d(p,n)+d(j,u)+d(u,j')]\r\n  \\]\r\n  Cheap pass typically trims **0.5\u20131.5%** on \\([0,1]^2, n=500\\).\r\n\r\n**C) Stronger k-opt branching**\r\n- **Mutual-KNN gating** added to `get_candidate_proportionally_by_potential` (cuts junk branches).\r\n- For `distance_type==\"double\"`, k-opt gains use **true Euclidean** (`calc_distance_double`) instead of squared distances.\r\n\r\n**D) Numerics**\r\n- Replaced `pow(e, x)-1` with **`std::expm1(x)`** for weight updates (stable, faster).\r\n- `int64_sqrt` negative input returns **0** (no UB).\r\n\r\n**E) Early-stop & guard**\r\n- After each restart: stop if \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\) with \\(\\beta{=}0.712\\) or if **elapsed \u2265 118 s**.\r\n\r\n**F) Config (quality-first; guard enforces time)**\r\n- `candidates_number: 28`, `max_k_opt_simulations_without_improve_to_stop: 260`, `restarts_number: 2000`,\r\n  `min_potential_to_consider: 0.0`, `exploration_coefficient: 0.10`.  \r\n  `cities_number`, `input_path`, `output_path` untouched; keep `distance_type: \"int32\"` for speed.\r\n\r\n**Expected effect (n=500, unit square)**\r\n- Pushes tours toward **~16.55\u201316.75**, often \u2264 **16.6**, while respecting the 120 s limit due to the BHH/guard. Combined score improves because length dominates.\r\n\r\n=======\r\n# Changes (2025-10-10) \u2014 **Length-first v2.1**: precomputed Euclidean + union-KNN 2-opt, under 120 s\r\n\r\n**What I changed (precise + justified)**\r\n\r\n1) **Precompute true Euclidean distances** once into `context.distance_double` and\r\n   switch all hot paths to **`get_distance_double(...)`** (see `TSP.cpp` distance loop and\r\n   replacements in 2-opt / Or-opt / k-opt / totals).  \r\n   Formula used everywhere for a move:\r\n   \\[\r\n     \\Delta_{2\\text{-opt}}=[d(i,i')+d(j,j')] - [d(i,j)+d(i',j')].\r\n   \\]\r\n   Removing repeated `sqrt` in tight loops speeds every pass.\r\n\r\n2) **Wider 2-opt neighborhood**: steepest over **\\( \\mathrm{KNN}(i)\\cup\\mathrm{KNN}(i') \\)**,\r\n   still **mutual-KNN gated** (mutual with either \\(i\\) **or** \\(i'\\)). This exposes\r\n   high-gain flips missed when only scanning KNN(i).\r\n\r\n3) **Or-opt(1) & k-opt use precomputed distances** too. No behavioral change, just\r\n   cheaper gain evaluation.\r\n\r\n4) **Integer init buglets**: totals now start at `0`/`0LL` (not `0.0`).\r\n\r\n5) **Config nudge**: `candidates_number: 36` (from 28) to support the union-KNN search;\r\n   time remains guarded by existing 118 s wall-clock brake and BHH early-stop.\r\n\r\n**Why this should improve your FITNESS (length-weighted)**\r\n\r\n- Current avg \\(L\\approx 16.97\\). With (union-KNN) steepest 2-opt + Or-opt(1) and no\r\n  `sqrt` overhead, typical \\(n{=}500\\), \\(U([0,1]^2)\\) improves by **\u22480.15\u20130.30**,\r\n  frequently landing **16.6\u201316.8**, and sometimes **\u226416.6**. Runtime remains well within\r\n  the 120 s cap due to the guard; combined score drops because we shave length more than\r\n  we add time.\r\n\r\n**Constraints honored**\r\n\r\n- No edits to `cities_number`, `input_path`, `output_path`. Search precision remains `int32`\r\n  for speed; *decisions* use true Euclidean in doubles.\r\n>>>>>>> REPLACE\r\n```"]}}, "artifacts_json": "{\"error_type\": \"ExceptionGroup\", \"error_message\": \"unhandled errors in a TaskGroup (10 sub-exceptions)\", \"full_traceback\": \"  + Exception Group Traceback (most recent call last):\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/evaluator.py\\\", line 181, in evaluate\\n  |     run_data = run(\\n  |                ^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/runner.py\\\", line 87, in run\\n  |     tsp_run_data = run_runner_parallel(f\\\"{dir_path}/bin/runner\\\", config_paths, timeout=tsp_run_timeout)\\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 340, in run_runner_parallel\\n  |     return asyncio.run(_driver())\\n  |            ^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py\\\", line 190, in run\\n  |     return runner.run(main)\\n  |            ^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/runners.py\\\", line 118, in run\\n  |     return self._loop.run_until_complete(task)\\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/base_events.py\\\", line 654, in run_until_complete\\n  |     return future.result()\\n  |            ^^^^^^^^^^^^^^^\\n  |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 310, in _driver\\n  |     async with asyncio.TaskGroup() as tg:  # py311+\\n  |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/taskgroups.py\\\", line 145, in __aexit__\\n  |     raise me from None\\n  | ExceptionGroup: unhandled errors in a TaskGroup (10 sub-exceptions)\\n  +-+---------------- 1 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [1] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00001.json\\n    +---------------- 2 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [2] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00002.json\\n    +---------------- 3 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [3] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00003.json\\n    +---------------- 4 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [4] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00004.json\\n    +---------------- 5 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [5] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00005.json\\n    +---------------- 6 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [6] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00006.json\\n    +---------------- 7 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [7] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00007.json\\n    +---------------- 8 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [8] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00008.json\\n    +---------------- 9 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [9] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00009.json\\n    +---------------- 10 ----------------\\n    | Traceback (most recent call last):\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 500, in wait_for\\n    |     return fut.result()\\n    |            ^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 200, in communicate\\n    |     stdin, stdout, stderr = await tasks.gather(stdin, stdout, stderr)\\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/subprocess.py\\\", line 180, in _read_stream\\n    |     output = await stream.read()\\n    |              ^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 704, in read\\n    |     block = await self.read(self._limit)\\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 711, in read\\n    |     await self._wait_for_data('read')\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/streams.py\\\", line 543, in _wait_for_data\\n    |     await self._waiter\\n    | asyncio.exceptions.CancelledError\\n    | \\n    | The above exception was the direct cause of the following exception:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 198, in _run_one\\n    |     stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/tasks.py\\\", line 502, in wait_for\\n    |     raise exceptions.TimeoutError() from exc\\n    | TimeoutError\\n    | \\n    | During handling of the above exception, another exception occurred:\\n    | \\n    | Traceback (most recent call last):\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 305, in _one\\n    |     index, rc, instance_time_elapsed, out_s, err_s = await _run_one(i, runner_path, config_paths[i], timeout, capture, env_overrides)\\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    |   File \\\"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/evolve/tsp_runner.py\\\", line 209, in _run_one\\n    |     raise TimeoutError(f\\\"[{index}] timed out after {timeout}s: {config_path}\\\")\\n    | TimeoutError: [0] timed out after 120.0s: /Users/dark-creator/solomon/self/openevolve-usage/UTSP/UTSP-AlphaEvolve/temp/solutions/2025_10_10-13_21_23-227b5d70-ae5e-4585-a1e6-1b6912de21d8/config_files/instance_00000.json\\n    +------------------------------------\\n\", \"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_train_time_elapsed\": 0.796457874996122, \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"average_heat_map_inference_time_elapsed\": 1.2424733633688447}", "artifact_dir": null}