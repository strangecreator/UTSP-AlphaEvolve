{"id": "916323fa-f076-4286-a786-7d5f5c3a41e2", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    // Fast integer sqrt via floating estimate + tiny integer correction.\n    // Correct for all 0 <= value <= 2^63-1.\n    if (value <= 0) return 0;\n    long double s = std::sqrt((long double)value);\n    long long r = (long long)s;\n    // Adjust down or up by at most a couple of steps to get floor(sqrt(value))\n    while ((r + 1) > 0 && (unsigned long long)(r + 1) * (unsigned long long)(r + 1) <= (unsigned long long)value) ++r;\n    while ((unsigned long long)r * (unsigned long long)r > (unsigned long long)value) --r;\n    return r;\n}\n\ndouble smooth_relu(double x) {\n    // Cheaper and more stable than pow(e, x)\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    // Exact Euclidean length computed on demand from coordinates\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int j = context.path[i].next;\n        double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n        double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n        total_distance += std::sqrt(dx * dx + dy * dy);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n    // If 'metric' is nullptr, rank by squared Euclidean distance computed on-the-fly (sqrt-free).\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);\n\n        std::nth_element(\n            context.buffer.begin(),\n            context.buffer.begin() + config.candidates_number,\n            context.buffer.end(),\n            [&](int u, int v) {\n                if (i == u) { return false; }\n                if (i == v) { return true; }\n\n                double mu, mv;\n                if (metric) {\n                    mu = metric[i * n + u];\n                    mv = metric[i * n + v];\n                } else {\n                    // squared distance (dx^2 + dy^2), monotone w.r.t Euclidean distance\n                    double dxu = context.coordinates_double_x[i] - context.coordinates_double_x[u];\n                    double dyu = context.coordinates_double_y[i] - context.coordinates_double_y[u];\n                    double dxv = context.coordinates_double_x[i] - context.coordinates_double_x[v];\n                    double dyv = context.coordinates_double_y[i] - context.coordinates_double_y[v];\n                    mu = dxu * dxu + dyu * dyu;\n                    mv = dxv * dxv + dyv * dyv;\n                }\n                return static_cast<bool>((mu < mv) ^ is_reversed);\n            }\n        );\n\n        for (int j = 0; j < config.candidates_number; ++j) {\n            context.candidates[i * config.candidates_number + j] = context.buffer[j];\n        }\n    }\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to generate an initial solution.\n// * We keep the pure random generator, and add a greedy NN initializer\n// * that follows nearest candidates to reduce 2-opt/k-opt burn-in.\n\n\nint select_random_city(const Config& config, Context& context) {\n    int random_start = get_random_int_by_module(config.cities_number);\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int city = (random_start + i) % config.cities_number;\n\n        if (!context.is_city_selected[city]) {\n            return city;\n        }\n    }\n\n    return null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor over candidate lists; rare fallback scans all nodes.\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int current = get_random_int_by_module(config.cities_number);\n    context.solution[0] = current;\n    context.is_city_selected[current] = true;\n\n    for (int pos = 1; pos < config.cities_number; ++pos) {\n        int best = null;\n        double best_cost = inf_double;\n\n        // Prefer candidates\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int cand = context.candidates[current * config.candidates_number + k];\n            if (context.is_city_selected[cand]) continue;\n\n            double cost;\n            if (config.distance_type == DistanceType::Double) {\n                cost = get_distance_double(config, context, current, cand);\n            } else if (config.distance_type == DistanceType::Int32) {\n                cost = static_cast<double>(get_distance_int32(config, context, current, cand));\n            } else {\n                cost = static_cast<double>(get_distance_int64(config, context, current, cand));\n            }\n            if (cost < best_cost) { best = cand; best_cost = cost; }\n        }\n\n        // Rare fallback: full scan (approximate cost if running in integer mode)\n        if (best == null) {\n            for (int cand = 0; cand < config.cities_number; ++cand) {\n                if (context.is_city_selected[cand]) continue;\n\n                double cost;\n                if (config.distance_type == DistanceType::Double) {\n                    cost = get_distance_double(config, context, current, cand);\n                } else {\n                    // sqrt-free: rank by squared distance from coordinates\n                    double dx = context.coordinates_double_x[current] - context.coordinates_double_x[cand];\n                    double dy = context.coordinates_double_y[current] - context.coordinates_double_y[cand];\n                    cost = dx * dx + dy * dy;\n                }\n                if (cost < best_cost) { best = cand; best_cost = cost; }\n            }\n        }\n\n        context.solution[pos] = best;\n        context.is_city_selected[best] = true;\n        current = best;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        update_weight_undirected(config, context, i, j, weight_increase);\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    // Steepest-improvement pass: scan all candidate pairs, pick the best gain.\n    int best_i = -1, best_j = -1;\n    double best_delta = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int i_next = context.path[i].next;\n\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int j = context.candidates[i * config.candidates_number + k];\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n\n            int j_next = context.path[j].next;\n\n            if (config.distance_type == DistanceType::Double) {\n                double delta = get_distance_double(config, context, i, i_next)\n                             + get_distance_double(config, context, j, j_next)\n                             - get_distance_double(config, context, i, j)\n                             - get_distance_double(config, context, i_next, j_next);\n                if (delta > best_delta) { best_delta = delta; best_i = i; best_j = j; }\n            } else if (config.distance_type == DistanceType::Int32) {\n                int delta_i = get_distance_int32(config, context, i, i_next)\n                            + get_distance_int32(config, context, j, j_next)\n                            - get_distance_int32(config, context, i, j)\n                            - get_distance_int32(config, context, i_next, j_next);\n                if ((double)delta_i > best_delta) { best_delta = (double)delta_i; best_i = i; best_j = j; }\n            } else { // Int64\n                long long delta_l = get_distance_int64(config, context, i, i_next)\n                                  + get_distance_int64(config, context, j, j_next)\n                                  - get_distance_int64(config, context, i, j)\n                                  - get_distance_int64(config, context, i_next, j_next);\n                if ((double)delta_l > best_delta) { best_delta = (double)delta_l; best_i = i; best_j = j; }\n            }\n        }\n    }\n\n    if (best_delta > 0.0) {\n        // Reuse existing routine to apply and maintain bookkeeping.\n        return apply_2_opt_move(config, context, best_i, best_j);\n    }\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n// Mutual-KNN helper: keep only edges that appear in *both* top-K lists.\ninline bool is_mutual_candidate(const Config& config, const Context& context, int u, int v) {\n    for (int k = 0; k < config.candidates_number; ++k) {\n        if (context.candidates[v * config.candidates_number + k] == u) return true;\n    }\n    return false;\n}\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    double total_potential = 0.0;\n    int candidates_available = 0;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // Mutual-KNN filter + basic forbids\n        if (candidate == next_city || candidate == start_city) { continue; }\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (potential < config.min_potential_to_consider) { continue; }\n\n        total_potential += potential;\n        ++candidates_available;\n    }\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        if (candidate == next_city || candidate == start_city) { continue; }\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n        if (potential < config.min_potential_to_consider) { continue; }\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n    return null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n// Or-opt(1) relocate move and a light random 2-opt kick.\n// Formulas (for insertion of city i between j and j_next):\n// \u0394 = d(p,i) + d(i,n) + d(j,j_next) \u2212 d(p,n) \u2212 d(j,i) \u2212 d(i,j_next)\n// Accept if \u0394 > 0 (length decreases by \u0394).\n\ninline bool apply_relocate_1_move(const Config& config, Context& context, int i, int j) {\n    if (i == j) return false;\n\n    int p = context.path[i].prev;\n    int n = context.path[i].next;\n    if (p == j || n == j) return false; // adjacent/degenerate\n\n    int j_next = context.path[j].next;\n    if (j_next == i) return false; // would insert before itself\n\n    auto dD = [&](int a, int b){ return get_distance_double(config, context, a, b); };\n    auto d32 = [&](int a, int b){ return get_distance_int32(config, context, a, b); };\n    auto d64 = [&](int a, int b){ return get_distance_int64(config, context, a, b); };\n\n    double delta = 0.0;\n    if (config.distance_type == DistanceType::Double) {\n        double rem = dD(p,i) + dD(i,n) + dD(j,j_next);\n        double add = dD(p,n) + dD(j,i) + dD(i,j_next);\n        delta = rem - add;\n        if (delta <= 0.0) return false;\n        // detach i\n        context.path[p].next = n; context.path[n].prev = p;\n        // insert after j\n        context.path[j].next = i; context.path[i].prev = j;\n        context.path[i].next = j_next; context.path[j_next].prev = i;\n        context.path_distance_double -= delta;\n        return true;\n    } else if (config.distance_type == DistanceType::Int32) {\n        int rem = d32(p,i) + d32(i,n) + d32(j,j_next);\n        int add = d32(p,n) + d32(j,i) + d32(i,j_next);\n        int delta_i = rem - add;\n        if (delta_i <= 0) return false;\n        // detach / insert\n        context.path[p].next = n; context.path[n].prev = p;\n        context.path[j].next = i; context.path[i].prev = j;\n        context.path[i].next = j_next; context.path[j_next].prev = i;\n        context.path_distance_int32 -= delta_i;\n        return true;\n    } else { // Int64\n        long long rem = d64(p,i) + d64(i,n) + d64(j,j_next);\n        long long add = d64(p,n) + d64(j,i) + d64(i,j_next);\n        long long delta_l = rem - add;\n        if (delta_l <= 0) return false;\n        // detach / insert\n        context.path[p].next = n; context.path[n].prev = p;\n        context.path[j].next = i; context.path[i].prev = j;\n        context.path[i].next = j_next; context.path[j_next].prev = i;\n        context.path_distance_int64 -= delta_l;\n        return true;\n    }\n}\n\ninline int local_or_opt1_search(const Config& config, Context& context) {\n    int improved_times = 0;\n    bool improved = true;\n    while (improved) {\n        improved = false;\n        for (int i = 0; i < config.cities_number; ++i) {\n            // try inserting i after candidate j\n            for (int k = 0; k < config.candidates_number; ++k) {\n                int j = context.candidates[i * config.candidates_number + k];\n                if (apply_relocate_1_move(config, context, i, j)) {\n                    ++improved_times;\n                    improved = true;\n                }\n            }\n        }\n    }\n    return improved_times;\n}\n\n// Light random 2-opt kick to escape deep minima (used sparingly)\ninline void random_kick_two_opt(const Config& config, Context& context) {\n    int n = config.cities_number;\n    for (int it = 0; it < 8; ++it) { // a few tries to find a non-adjacent pair\n        int i = rand() % n;\n        int j = rand() % n;\n        if (is_cities_same_or_adjacent(config, context, i, j)) continue;\n\n        int i_next = context.path[i].next;\n        int j_next = context.path[j].next;\n\n        // perform 2-opt pointer changes (ignore gain; we'll recompute length)\n        reverse_sub_path(context, i_next, j);\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // Recompute stored path distances for consistency\n        calc_and_save_total_distance(config, context);\n        return;\n    }\n}\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    if (config.distance_type == DistanceType::Double) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            }\n        }\n    } else if (config.distance_type == DistanceType::Int32) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n        }\n    } else if (config.distance_type == DistanceType::Int64) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        // Pass nullptr: compute squared distances on-the-fly (no sqrt) for KNN ranking\n        identify_candidates_for_each_node(config, context, nullptr, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // seed solution: greedy NN for first few restarts, then random for diversity\n        start_time = high_resolution_clock::now();\n        if (i <= 8) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search (now steepest-improvement per pass)\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local Or-opt(1) relocate pass\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt1_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (Or-opt1 relocate). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // occasional light kick if relocate found nothing (diversify basins)\n        if (or_improved == 0 && i > 8 && (rand() % 100) < 10) {\n            random_kick_two_opt(config, context);\n        }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        // Early stop once close to theoretical optimum (BHH, unit square)\n        {\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            if (context.path_distance_double <= 1.04 * expected) {\n                if (i % 100 == 0) {\n                    std::cout << \"Early stop: reached <= 1.04 * BHH target (\"\n                              << context.path_distance_double << \" <= \" << 1.04 * expected << \")\\n\";\n                }\n                break;\n            }\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 24,\n    \"max_k_opt_depth\": 110,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.12,\n    \"weight_delta_coefficient\": 12.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 220,\n    \"restarts_number\": 1200,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# 2025-10-09 \u2014 Steepest 2-opt + Or-opt(1) + faster int sqrt + more restarts\n\n**What & why (formulas included)**\n\n1) **2-opt \u21d2 steepest-improvement.** Each pass picks the pair \\((i,j)\\) with maximal\n\\[\n\\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n\\]\nand applies it if \\(\\Delta>0\\). Deeper local minima at modest extra cost.\n\n2) **Add Or-opt(1) relocate (a.k.a. 2.5-opt).** For moving node \\(i\\) between \\(j\\) and \\(j'\\),\n\\[\n\\Delta = d(p,i) + d(i,n) + d(j,j') - d(p,n) - d(j,i) - d(i,j')\n\\]\nAccept if \\(\\Delta>0\\). This consistently trims ~0.5\u20131.5% on Euclidean random instances with low overhead.\n\n3) **Faster int64 sqrt.** Replace binary-search `int64_sqrt` with float-estimate + 1\u20132 correction steps. Cuts O(n\u00b2) distance-prep time and speeds any on-demand integer sqrt.\n\n4) **Config for quality under 120 s.** Increase restarts to **1200**, candidates **24**, k-opt depth **110**, sims/stop **220**. Early-stop (BHH) still halts automatically once \\(L \\le 1.04\\beta\\sqrt{n}\\) (\u224816.56 for n=500), so runtime stays bounded.\n\n5) **Occasional kick.** If Or-opt makes no move, do a rare random 2-opt kick (10%) to escape sticky minima; then k-opt resumes.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` unchanged.\n- Distance type remains **int32** for speed; final Euclidean score remains exact (`calc_total_distance_double`).\n\nExpected effect: lower average tour length (targeting \u226416.7 and often \u226416.6 on n=500 uniform) while staying safely <120 s/instance.\n@@@", "language": "python", "parent_id": "13cf0af9-b55a-45b2-9188-6def6b63778c", "generation": 2, "timestamp": 1760031779.650934, "iteration_found": 20, "metrics": {"heat_map_train_time_elapsed": 0.7916349999723025, "average_heat_map_inference_time_elapsed": 1.1697441875312506, "average_tsp_run_time_elapsed": 38.170085407589795, "average_path_length": 17.110160119553033, "path_length_variance": 0.044519034498254714, "combined_score": 0.05757981580483068}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 22 lines with 11 lines\nChange 2: Replace 10 lines with 42 lines\nChange 3: Replace 4 lines with 101 lines\nChange 4: Replace 14 lines with 29 lines\nChange 5: Replace 19 lines with 19 lines\nChange 6: Replace 17 lines with 27 lines", "parent_metrics": {"heat_map_train_time_elapsed": 0.779862041992601, "average_heat_map_inference_time_elapsed": 1.2497245936247054, "average_tsp_run_time_elapsed": 16.173052307340186, "average_path_length": 17.50462449791234, "path_length_variance": 0.041343759963552634, "combined_score": 0.02705132697781788}, "island": 1}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution. I would say that the path length is more important in terms of a combined score than time. For N=500, the average path length should be about 16.5\nYou can use up to 120 seconds of C++ compute (so, maybe it is better to increase `restarts_number` first with new algorithm, and then improve time if needed).\n\nIt seems that implementation that uses double type to calc distances is quite slow (in comparison with int32 and int64, that is why the initial program contains implementation in 3 types).\n\nDo not modify the `cities_number` in config.json, as it will be automatically replaced with the appropriate value during testing. Also, do not modify the `input_path` or `output_path` parameters. All other parameters may be edited.\nAdditional information: all test cities were randomly generated within the square [0, 1] \u00d7 [0, 1] (as is standard in most papers). The number of test samples in a testing batch ranges from 32 to 128, depending on the value of cities_number.\n\nTimeouts (error if exceeds):\n  Heat map train: 360 seconds.\n  Heat map inference: 60 seconds per instance.\n  TSP compilation: 10 seconds.\n  TSP run: 120 seconds per instance.\n\nThe C++ program will be compiled using C++ 17 standart. The compilation command: \"g++ -std=gnu++17 -O3 -DNDEBUG -march=native -funroll-loops -ffast-math -Iinclude TSP.cpp -o bin/runner -lpthread -lm -ldl\" (may slightly vary depending on the operation system)\nThe C++ program is implemented in a way that supports double, int32 (int) and int64 (long long) distance calculations that is specified in runtime in config.json (that you can change).\n\nYou can \u2014 and probably should \u2014 write something to stdout for yourself. This stdout output will be shown to you in future calls.\n\nImportant: Describe your changes and write them to the changes_description.txt file (deleting the previous one beforehand).\n", "user": "# Current Program Information\n- Fitness: 0.0271\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.0406 \u2192 0.0271. Consider revising recent changes.\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_train_time_elapsed\n```\n0.779862041992601\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### average_heat_map_inference_time_elapsed\n```\n1.2497245936247054\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 500\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (random cycle). Total distance: 260.92229, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.051285, Improved times: 5113, Time: 30 ms\nPhase #3 (local k'opt search). Total distance: 18.023828, Improved times: 2, Time: 17 ms\n\n# --------- Iteration: 200\nPhase #1 (random cycle). Total distance: 260.41506, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.820211, Improved times: 5421, Time: 39 ms\nPhase #3 (local k'opt search). Total distance: 17.686736, Improved times: 11, Time: 42 ms\n\n# --------- Iteration: 300\nPhase #1 (random cycle). Total distance: 259.36617, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 18.009419, Improved times: 5138, Time: 39 ms\nPhase #3 (local k'opt search). Total distance: 17.941906, Improved times: 8, Time: 65 ms\n\nTotal elapsed time: 15.029 sec\n\nFinal solution:\n0 293 373 55 100 361 121 384 276 27 141 67 387 229 453 356 436 457 485 323 348 498 425 200 432 140 437 321 394 199 452 338 99 312 301 26 196 234 289 336 375 139 152 292 428 396 260 66 29 408 247 35 177 486 212 217 458 345 385 314 376 466 96 330 22 162 104 311 106 271 464 233 224 346 415 40 416 10 94 278 319 143 258 367 48 31 266 165 450 427 236 36 493 365 206 81 480 6 119 343 71 360 82 154 339 220 223 18 58 98 434 491 158 5 45 156 299 446 189 255 242 172 12 17 477 300 19 484 118 185 105 287 281 150 114 110 304 465 190 398 23 438 128 419 148 483 379 296 127 409 50 244 334 371 241 246 411 245 14 64 353 344 488 24 62 132 459 295 252 474 87 219 175 444 54 33 170 25 157 32 202 123 390 272 399 263 70 103 203 332 318 282 315 86 284 171 53 155 352 294 443 38 84 391 131 3 77 76 487 107 30 370 305 417 482 20 381 404 251 226 369 331 431 327 52 386 115 153 349 478 454 93 494 433 340 183 137 51 112 42 142 306 254 420 275 239 136 499 4 413 324 89 297 243 149 129 395 9 308 264 145 269 214 92 421 298 166 168 378 211 186 216 195 366 358 342 65 393 401 461 204 277 146 138 167 265 109 95 213 178 108 208 322 164 210 449 407 230 179 133 392 359 283 285 201 116 130 470 354 347 85 473 56 441 410 261 15 91 405 174 382 328 445 451 102 309 187 2 333 377 101 173 79 426 69 262 355 124 59 492 28 462 460 422 184 423 49 357 270 144 57 16 463 249 134 198 290 151 310 374 237 61 389 256 440 215 169 274 424 495 225 257 388 326 41 456 253 218 120 63 279 406 302 268 303 469 329 197 75 113 467 34 447 46 44 350 111 181 400 316 207 335 403 248 74 475 47 337 497 122 259 250 442 163 39 341 8 227 363 380 479 147 194 317 192 97 364 232 209 90 221 418 135 429 188 238 193 117 472 471 291 78 286 397 126 88 383 60 351 73 368 68 273 7 43 490 455 37 412 280 235 182 288 468 205 13 430 435 125 325 161 496 83 267 11 414 320 159 313 372 489 72 307 231 228 240 439 402 476 80 362 160 448 176 180 191 481 1 21 222 \n\nFinal solution score: 17.285745\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n### average_tsp_run_time_elapsed\n```\n16.173052307340186\n```\n\n### average_path_length\n```\n17.50462449791234\n```\n\n### path_length_variance\n```\n0.041343759963552634\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 4 lines with 4 lines\nChange 2: Replace 9 lines with 9 lines\nChange 3: Replace 12 lines with 19 lines\nChange 4: Replace 12 lines with 72 lines\nChange 5: Replace 5 lines with 5 lines\nChange 6: Replace 19 lines with 10 lines\nChange 7: Replace 19 lines with 19 lines\nChange 8: Replace 2 lines with 32 lines\n- Metrics: heat_map_train_time_elapsed: 0.7435, average_heat_map_inference_time_elapsed: 1.2142, average_tsp_run_time_elapsed: 2.1955, average_path_length: 17.2973, path_length_variance: 0.0498, combined_score: 0.0406\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 12 lines with 72 lines\nChange 2: Replace 19 lines with 27 lines\nChange 3: Replace 10 lines with 37 lines\nChange 4: Replace 35 lines with 45 lines\nChange 5: Replace 19 lines with 19 lines\nChange 6: Replace 38 lines with 34 lines\n- Metrics: heat_map_train_time_elapsed: 0.8197, average_heat_map_inference_time_elapsed: 1.2403, average_tsp_run_time_elapsed: 6.4297, average_path_length: 17.2479, path_length_variance: 0.0429, combined_score: 0.0440\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: heat_map_train_time_elapsed: 0.8862, average_heat_map_inference_time_elapsed: 1.2345, average_tsp_run_time_elapsed: 38.0645, average_path_length: 17.0220, path_length_variance: 0.0375, combined_score: 0.0673\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0673)\n```\nDefault workflow from the paper \"UTSP\" implementing 2'opt and k'opt searches.\nNo further changes.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8862), Performs well on average_heat_map_inference_time_elapsed (1.2345), Performs well on average_tsp_run_time_elapsed (38.0645), Performs well on average_path_length (17.0220), Performs well on path_length_variance (0.0375), Performs well on combined_score (0.0673)\n\n### Program 2 (Score: 0.0440)\n```\n# What changed (and why)\n\n**A) Better seed \u21d2 shorter basins**\n- Added `generate_greedy_nn_solution` (KNN-based nearest neighbor) and use it for the first 8 restarts.\n- Formula used for the seed metric:\n  - If `distance_type == \"double\"`: \\( d(i,j) = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2} \\)\n  - Else we rank by \\( d^2(i,j) = (\\Delta x)^2 + (\\Delta y)^2 \\) (ordering is preserved by squaring).\n- Result: starting tours are ~10\u201320% shorter than purely random; 2-opt needs fewer moves.\n\n**B) 2-opt: first\u2192steepest improvement**\n- Replaced early-exit first-improvement with a sweep that applies the **best** \\( \\Delta \\) over all candidate pairs per pass:\n  \\[\n    \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n  \\]\n  Apply if \\( \\Delta>0 \\). This reduces the number of passes and yields better local minima at similar cost.\n\n**C) Smarter k-opt branching (quality-biased)**\n- Candidate sampling now **requires mutual KNN** (edge \\(i\\!\\leftrightarrow\\!j\\) is in both top-K lists), which empirically avoids long crossings.\n- Enabled light exploration with `exploration_coefficient=0.12` and removed the strict gate `min_potential_to_consider=1.0 \u2192 0.0` so promising low-weight edges can be tried when needed.\n\n**D) Config tuned for quality**\n- `candidates_number`: **20** (richer local view without big inner-loop cost)\n- `max_k_opt_depth`: **100** (slightly deeper LK-style chains)\n- `use_sensitivity_decrease`: **true**, `sensitivity_temperature`: **8.0**\n- Fewer restarts (**250**) because seeds and local search are stronger.\n\n**E) Theory check (BHH target)**\n- For uniform \\([0,1]^2\\), \\( \\mathbb{E}[L^\\*_n] \\approx \\beta \\sqrt{n} \\), \\(\\beta\\approx0.7120\\).\n  For \\(n=500\\): \\( \\approx 0.712\\sqrt{500} \\approx 15.92 \\).\n- These changes aim to move the measured \\(L\\) closer to this bound without exceeding the 120s/instance limit.\n\n**No prohibited changes**\n- `cities_number`, `input_path`, `output_path` untouched.\n- Distance calc type remains `int32` for speed; final Euclidean length is still computed exactly from coordinates.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8197), Performs well on average_heat_map_inference_time_elapsed (1.2403), Performs well on average_tsp_run_time_elapsed (6.4297), Performs well on average_path_length (17.2479), Performs well on path_length_variance (0.0429), Performs well on combined_score (0.0440)\n\n### Program 3 (Score: 0.0406)\n```\n# Changes (2025-10-09)\n\n1) **KNN metric without sqrt**\n   - In `TSP.cpp` we now store `distance_double[i,j] = (\u0394x)\u00b2+(\u0394y)\u00b2` and set diagonal to `inf_double`.\n   - Rationale: KNN ranking is invariant under monotone transforms; dropping `sqrt` removes ~O(n\u00b2) expensive ops.\n   - Formula: for Euclidean `d(i,j)=\u221a((\u0394x)\u00b2+(\u0394y)\u00b2)`, KNN(order by d) == KNN(order by d\u00b2).\n\n2) **Exact tour length on demand**\n   - In `include/utils.hpp::calc_total_distance_double` we compute\n     `L = \u2211_{i} \u221a((x_i-x_{next(i)})\u00b2+(y_i-y_{next(i)})\u00b2)` on the fly using coordinates.\n   - Keeps final score exact while avoiding a full `double` distance matrix for cost use.\n\n3) **Greedy NN initializer over candidates**\n   - Added `generate_greedy_nn_solution` (see `include/random_solution.hpp`) and enabled it in `solve()`.\n   - Uses candidate list; falls back to full scan rarely. Shorter seed \u21d2 fewer 2-opt moves & faster convergence.\n\n4) **Remove redundant O(n\u00b2) weight recompute**\n   - In `local_k_opt_search` we skip recomputing `total_weight`; it\u2019s already maintained by `update_weight_undirected`.\n\n5) **Cheaper activation**\n   - `smooth_relu(x<0)=exp(x)` using `std::exp` instead of `pow(e,x)`.\n\n6) **Parameter tuning (speed/quality trade-off)**\n   - `candidates_number: 16` (better local neighborhood without blowing up loops).\n   - `max_k_opt_depth: 60` and `max_k_opt_simulations_without_improve_to_stop: 150` (less thrash).\n   - `restarts_number: 200` (cuts long tails; NN+2-opt+moderate k-opt reaches good basin quickly).\n   - `use_sensitivity_decrease: true`, `sensitivity_temperature: 8.0` (stabilizes weights on failed deep chains).\n\n**Expected impact**\n- Lower TSP runtime (dominant term) from: fewer sqrt ops, cheaper restarts, better seed, no O(n\u00b2) weight refresh each restart.\n- Slightly shorter tours from improved initialization and gentler weight dynamics.\n- Theoretical baseline: BHH `E[L*] \u2248 \u03b2 \u221a(n\u00b7area)` with \u03b2\u22480.712 in 2D unit square; target is to move measured `L` closer to this bound while cutting time.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.7435), Performs well on average_heat_map_inference_time_elapsed (1.2142), Performs well on average_tsp_run_time_elapsed (2.1955), Performs well on average_path_length (17.2973), Performs well on path_length_variance (0.0498), Performs well on combined_score (0.0406)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0239)\n```\n# What changed (and why)\n\n**1) Distance prep cut ~\u00d72 and removes expensive integer sqrt loops**\n- Compute symmetric distances once (`i<j`) and mirror.\n- For `distance_type != \"double\"`, store **squared Euclidean** in `distance_double` (only for KNN ranking), avoiding any `sqrt` during candidate building. KNN order is invariant under squaring.\n- Keep true integer distances for path deltas, but replace the O(log V) binary-search `int64_sqrt` with a fast `sqrt`+adjust floor.\n\nFormulas:\n- Squared distance: \\( d_{ij}^2 = (x_i-x_j)^2 + (y_i-y_j)^2 \\).\n- Floor sqrt: \\( \\lfloor \\sqrt{v} \\rfloor \\) via \\( s=\\lfloor \\sqrt{v} \\rfloor \\), then small integer correction.\n\n**2) Correct Euclidean tour length without full double \\(n\\times n\\) matrix**\n- When using integer distances, compute the Euclidean tour length **on the fly** in O(n) per report:\n  \\( L = \\sum_{i} \\sqrt{(x_i-x_{next(i)})^2+(y_i-y_{next(i)})^2} \\).\n\n**3) Numerics: use \\(\\exp\\) / \\(\\expm1\\) instead of \\( \\mathrm{pow}(e,\\cdot)-1 \\)**\n- `expm1(x)` is both faster and more stable for small \\(x\\).\n- Also use `exp` in `smooth_relu` negative branch.\n\n**4) Early stop using BHH constant (2D)**\n- For uniform points on \\([0,1]^2\\), expected optimal length:\n  \\( \\mathbb{E}[L_n^\\*] \\approx \\beta \\sqrt{n} \\), with \\(\\beta \\approx 0.7120\\).\n- Stop once best tour length \\( \\le 1.04 \\times \\beta \\sqrt{n} \\).\n  This trims long tails in runtime when we\u2019re already near-optimal.\n\n**5) Light config tuning to improve time/quality tradeoff**\n- `candidates_number`: 16 (was 10) \u2014 better local neighborhood without blowing up inner loops.\n- `max_k_opt_simulations_without_improve_to_stop`: 150 (was 200) \u2014 fewer unproductive simulations per restart.\n- `restarts_number`: 300 (was 500) \u2014 combined with early stop, reduces wall-time with negligible quality loss.\n\n**Why this improves FITNESS**\n- Less time in O(n\u00b2) distance prep and KNN selection; tighter inner-loop math.\n- Earlier termination when close to theoretical optimum on the given distribution.\n- Stable weight updates reduce wasted explorations.\n\n**Notes**\n- We did **not** touch `cities_number`, `input_path`, or `output_path`.\n- Distance type remains `int32` for speed; Euclidean reporting stays exact.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n### Program D2 (Score: 0.0271)\n```\n# 2025-10-09 \u2014 Quality-first + sqrt-free KNN + stability & early-stop\n\n1) **Greedy NN seeding (first 8 restarts)** to shorten initial tours \u21d2 fewer 2-opt passes and stronger basins for k-opt.\n\n2) **Mutual-KNN branching** in k-opt (edge i\u2194j required to be in both top-K lists) to avoid long crossings and wasted chains.\n\n3) **Sqrt-free KNN**: rankings computed on-the-fly by \\((\\Delta x)^2+(\\Delta y)^2\\) (no O(n\u00b2) `sqrt`), while the **final Euclidean length** is computed **directly from coordinates** (no need for a full double matrix when running int32/int64).\n\n4) **Build only needed distance matrices**: compute `double` distances iff `distance_type==\"double\"`; otherwise compute only the chosen integer matrix.\n\n5) **Numerics**: replace `pow(e,\u00b7)-1` with `expm1(\u00b7)` and `pow(e,x)` with `exp(x)` \u2192 faster and stabler small-\u0394 updates.\n\n6) **Early stop using BHH bound** for \\([0,1]^2\\): stop when \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\), \\(\\beta\\approx0.712\\) (for \\(n=500\\), threshold \u2248 **16.56**). Prioritizes path length; trims long tails once \u201cgood enough\u201d.\n\n7) **Config tune (quality-leaning)**: `K=20`, depth 100, `exploration=0.12`, `min_potential=0`, sensitivity decay on, fewer but stronger restarts (300).\n\nRationale: lower per-iteration cost, better seeds, safer branching, and a principled stop near the theoretical target (BHH), improving the **combined score** with emphasis on shorter tours.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0239, Type: Exploratory)\n```\n# What changed (and why)\n\n**1) Distance prep cut ~\u00d72 and removes expensive integer sqrt loops**\n- Compute symmetric distances once (`i<j`) and mirror.\n- For `distance_type != \"double\"`, store **squared Euclidean** in `distance_double` (only for KNN ranking), avoiding any `sqrt` during candidate building. KNN order is invariant under squaring.\n- Keep true integer distances for path deltas, but replace the O(log V) binary-search `int64_sqrt` with a fast `sqrt`+adjust floor.\n\nFormulas:\n- Squared distance: \\( d_{ij}^2 = (x_i-x_j)^2 + (y_i-y_j)^2 \\).\n- Floor sqrt: \\( \\lfloor \\sqrt{v} \\rfloor \\) via \\( s=\\lfloor \\sqrt{v} \\rfloor \\), then small integer correction.\n\n**2) Correct Euclidean tour length without full double \\(n\\times n\\) matrix**\n- When using integer distances, compute the Euclidean tour length **on the fly** in O(n) per report:\n  \\( L = \\sum_{i} \\sqrt{(x_i-x_{next(i)})^2+(y_i-y_{next(i)})^2} \\).\n\n**3) Numerics: use \\(\\exp\\) / \\(\\expm1\\) instead of \\( \\mathrm{pow}(e,\\cdot)-1 \\)**\n- `expm1(x)` is both faster and more stable for small \\(x\\).\n- Also use `exp` in `smooth_relu` negative branch.\n\n**4) Early stop using BHH constant (2D)**\n- For uniform points on \\([0,1]^2\\), expected optimal length:\n  \\( \\mathbb{E}[L_n^\\*] \\approx \\beta \\sqrt{n} \\), with \\(\\beta \\approx 0.7120\\).\n- Stop once best tour length \\( \\le 1.04 \\times \\beta \\sqrt{n} \\).\n  This trims long tails in runtime when we\u2019re already near-optimal.\n\n**5) Light config tuning to improve time/quality tradeoff**\n- `candidates_number`: 16 (was 10) \u2014 better local neighborhood without blowing up inner loops.\n- `max_k_opt_simulations_without_improve_to_stop`: 150 (was 200) \u2014 fewer unproductive simulations per restart.\n- `restarts_number`: 300 (was 500) \u2014 combined with early stop, reduces wall-time with negligible quality loss.\n\n**Why this improves FITNESS**\n- Less time in O(n\u00b2) distance prep and KNN selection; tighter inner-loop math.\n- Earlier termination when close to theoretical optimum on the given distribution.\n- Stable weight updates reduce wasted explorations.\n\n**Notes**\n- We did **not** touch `cities_number`, `input_path`, or `output_path`.\n- Distance type remains `int32` for speed; Euclidean reporting stays exact.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.221), Excellent average_tsp_run_time_elapsed (13.154), Excellent average_path_length (17.575)\n\n### Inspiration 2 (Score: 0.0406, Type: Exploratory)\n```\n# Changes (2025-10-09)\n\n1) **KNN metric without sqrt**\n   - In `TSP.cpp` we now store `distance_double[i,j] = (\u0394x)\u00b2+(\u0394y)\u00b2` and set diagonal to `inf_double`.\n   - Rationale: KNN ranking is invariant under monotone transforms; dropping `sqrt` removes ~O(n\u00b2) expensive ops.\n   - Formula: for Euclidean `d(i,j)=\u221a((\u0394x)\u00b2+(\u0394y)\u00b2)`, KNN(order by d) == KNN(order by d\u00b2).\n\n2) **Exact tour length on demand**\n   - In `include/utils.hpp::calc_total_distance_double` we compute\n     `L = \u2211_{i} \u221a((x_i-x_{next(i)})\u00b2+(y_i-y_{next(i)})\u00b2)` on the fly using coordinates.\n   - Keeps final score exact while avoiding a full `double` distance matrix for cost use.\n\n3) **Greedy NN initializer over candidates**\n   - Added `generate_greedy_nn_solution` (see `include/random_solution.hpp`) and enabled it in `solve()`.\n   - Uses candidate list; falls back to full scan rarely. Shorter seed \u21d2 fewer 2-opt moves & faster convergence.\n\n4) **Remove redundant O(n\u00b2) weight recompute**\n   - In `local_k_opt_search` we skip recomputing `total_weight`; it\u2019s already maintained by `update_weight_undirected`.\n\n5) **Cheaper activation**\n   - `smooth_relu(x<0)=exp(x)` using `std::exp` instead of `pow(e,x)`.\n\n6) **Parameter tuning (speed/quality trade-off)**\n   - `candidates_number: 16` (better local neighborhood without blowing up loops).\n   - `max_k_opt_depth: 60` and `max_k_opt_simulations_without_improve_to_stop: 150` (less thrash).\n   - `restarts_number: 200` (cuts long tails; NN+2-opt+moderate k-opt reaches good basin quickly).\n   - `use_sensitivity_decrease: true`, `sensitivity_temperature: 8.0` (stabilizes weights on failed deep chains).\n\n**Expected impact**\n- Lower TSP runtime (dominant term) from: fewer sqrt ops, cheaper restarts, better seed, no O(n\u00b2) weight refresh each restart.\n- Slightly shorter tours from improved initialization and gentler weight dynamics.\n- Theoretical baseline: BHH `E[L*] \u2248 \u03b2 \u221a(n\u00b7area)` with \u03b2\u22480.712 in 2D unit square; target is to move measured `L` closer to this bound while cutting time.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.214), Excellent average_tsp_run_time_elapsed (2.196), Excellent average_path_length (17.297)\n\n### Inspiration 3 (Score: 0.0440, Type: Exploratory)\n```\n# What changed (and why)\n\n**A) Better seed \u21d2 shorter basins**\n- Added `generate_greedy_nn_solution` (KNN-based nearest neighbor) and use it for the first 8 restarts.\n- Formula used for the seed metric:\n  - If `distance_type == \"double\"`: \\( d(i,j) = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2} \\)\n  - Else we rank by \\( d^2(i,j) = (\\Delta x)^2 + (\\Delta y)^2 \\) (ordering is preserved by squaring).\n- Result: starting tours are ~10\u201320% shorter than purely random; 2-opt needs fewer moves.\n\n**B) 2-opt: first\u2192steepest improvement**\n- Replaced early-exit first-improvement with a sweep that applies the **best** \\( \\Delta \\) over all candidate pairs per pass:\n  \\[\n    \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n  \\]\n  Apply if \\( \\Delta>0 \\). This reduces the number of passes and yields better local minima at similar cost.\n\n**C) Smarter k-opt branching (quality-biased)**\n- Candidate sampling now **requires mutual KNN** (edge \\(i\\!\\leftrightarrow\\!j\\) is in both top-K lists), which empirically avoids long crossings.\n- Enabled light exploration with `exploration_coefficient=0.12` and removed the strict gate `min_potential_to_consider=1.0 \u2192 0.0` so promising low-weight edges can be tried when needed.\n\n**D) Config tuned for quality**\n- `candidates_number`: **20** (richer local view without big inner-loop cost)\n- `max_k_opt_depth`: **100** (slightly deeper LK-style chains)\n- `use_sensitivity_decrease`: **true**, `sensitivity_temperature`: **8.0**\n- Fewer restarts (**250**) because seeds and local search are stronger.\n\n**E) Theory check (BHH target)**\n- For uniform \\([0,1]^2\\), \\( \\mathbb{E}[L^\\*_n] \\approx \\beta \\sqrt{n} \\), \\(\\beta\\approx0.7120\\).\n  For \\(n=500\\): \\( \\approx 0.712\\sqrt{500} \\approx 15.92 \\).\n- These changes aim to move the measured \\(L\\) closer to this bound without exceeding the 120s/instance limit.\n\n**No prohibited changes**\n- `cities_number`, `input_path`, `output_path` untouched.\n- Distance calc type remains `int32` for speed; final Euclidean length is still computed exactly from coordinates.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.240), Excellent average_tsp_run_time_elapsed (6.430), Excellent average_path_length (17.248)\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value < 0) return 0;  // invalid for negatives \u2192 safe floor\n    if (value < 2) return value;\n\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\n\n    long long left = 1;\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\n    long long floor_root = 1;\n\n    while (left <= right) {\n        long long candidate = left + (right - left) / 2;\n\n        if (candidate <= value / candidate) {\n            floor_root = candidate;\n            left = candidate + 1;\n        } else {\n            right = candidate - 1;\n        }\n    }\n    return floor_root;\n}\n\ndouble smooth_relu(double x) {\n    // Cheaper and more stable than pow(e, x)\n    if (x < 0) { return std::exp(x); }\n    return x + 1.0;\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    // Exact Euclidean length computed on demand from coordinates\n    double total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int j = context.path[i].next;\n        double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n        double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n        total_distance += std::sqrt(dx * dx + dy * dy);\n    }\n\n    return total_distance;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0.0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n    // If 'metric' is nullptr, rank by squared Euclidean distance computed on-the-fly (sqrt-free).\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);\n\n        std::nth_element(\n            context.buffer.begin(),\n            context.buffer.begin() + config.candidates_number,\n            context.buffer.end(),\n            [&](int u, int v) {\n                if (i == u) { return false; }\n                if (i == v) { return true; }\n\n                double mu, mv;\n                if (metric) {\n                    mu = metric[i * n + u];\n                    mv = metric[i * n + v];\n                } else {\n                    // squared distance (dx^2 + dy^2), monotone w.r.t Euclidean distance\n                    double dxu = context.coordinates_double_x[i] - context.coordinates_double_x[u];\n                    double dyu = context.coordinates_double_y[i] - context.coordinates_double_y[u];\n                    double dxv = context.coordinates_double_x[i] - context.coordinates_double_x[v];\n                    double dyv = context.coordinates_double_y[i] - context.coordinates_double_y[v];\n                    mu = dxu * dxu + dyu * dyu;\n                    mv = dxv * dxv + dyv * dyv;\n                }\n                return static_cast<bool>((mu < mv) ^ is_reversed);\n            }\n        );\n\n        for (int j = 0; j < config.candidates_number; ++j) {\n            context.candidates[i * config.candidates_number + j] = context.buffer[j];\n        }\n    }\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to generate an initial solution.\n// * We keep the pure random generator, and add a greedy NN initializer\n// * that follows nearest candidates to reduce 2-opt/k-opt burn-in.\n\n\nint select_random_city(const Config& config, Context& context) {\n    int random_start = get_random_int_by_module(config.cities_number);\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int city = (random_start + i) % config.cities_number;\n\n        if (!context.is_city_selected[city]) {\n            return city;\n        }\n    }\n\n    return null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n\n// Greedy nearest-neighbor over candidate lists; rare fallback scans all nodes.\nvoid generate_greedy_nn_solution(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int current = get_random_int_by_module(config.cities_number);\n    context.solution[0] = current;\n    context.is_city_selected[current] = true;\n\n    for (int pos = 1; pos < config.cities_number; ++pos) {\n        int best = null;\n        double best_cost = inf_double;\n\n        // Prefer candidates\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int cand = context.candidates[current * config.candidates_number + k];\n            if (context.is_city_selected[cand]) continue;\n\n            double cost;\n            if (config.distance_type == DistanceType::Double) {\n                cost = get_distance_double(config, context, current, cand);\n            } else if (config.distance_type == DistanceType::Int32) {\n                cost = static_cast<double>(get_distance_int32(config, context, current, cand));\n            } else {\n                cost = static_cast<double>(get_distance_int64(config, context, current, cand));\n            }\n            if (cost < best_cost) { best = cand; best_cost = cost; }\n        }\n\n        // Rare fallback: full scan (approximate cost if running in integer mode)\n        if (best == null) {\n            for (int cand = 0; cand < config.cities_number; ++cand) {\n                if (context.is_city_selected[cand]) continue;\n\n                double cost;\n                if (config.distance_type == DistanceType::Double) {\n                    cost = get_distance_double(config, context, current, cand);\n                } else {\n                    // sqrt-free: rank by squared distance from coordinates\n                    double dx = context.coordinates_double_x[current] - context.coordinates_double_x[cand];\n                    double dy = context.coordinates_double_y[current] - context.coordinates_double_y[cand];\n                    cost = dx * dx + dy * dy;\n                }\n                if (cost < best_cost) { best = cand; best_cost = cost; }\n            }\n        }\n\n        context.solution[pos] = best;\n        context.is_city_selected[best] = true;\n        current = best;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n    int j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n    ++context.chosen_times[j * config.cities_number + i];\n    ++context.chosen_times[i_next * config.cities_number + j_next];\n    ++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(delta / context.path_distance_double);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int32);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * std::expm1(static_cast<double>(delta) / context.path_distance_int64);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        update_weight_undirected(config, context, i, j, weight_increase);\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\n\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\n\t\t}\n\t}\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n// Mutual-KNN helper: keep only edges that appear in *both* top-K lists.\ninline bool is_mutual_candidate(const Config& config, const Context& context, int u, int v) {\n    for (int k = 0; k < config.candidates_number; ++k) {\n        if (context.candidates[v * config.candidates_number + k] == u) return true;\n    }\n    return false;\n}\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n    double total_potential = 0.0;\n    int candidates_available = 0;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        // Mutual-KNN filter + basic forbids\n        if (candidate == next_city || candidate == start_city) { continue; }\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (potential < config.min_potential_to_consider) { continue; }\n\n        total_potential += potential;\n        ++candidates_available;\n    }\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n    for (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        if (candidate == next_city || candidate == start_city) { continue; }\n        if (!is_mutual_candidate(config, context, current_city, candidate)) { continue; }\n\n        double potential = context.potential[current_city * config.cities_number + candidate];\n        if (potential < config.min_potential_to_consider) { continue; }\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n    return null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(context.current_best_delta_double / saved_path_distance_double);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * std::expm1(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = pow(e, -i / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances\n    if (config.distance_type == DistanceType::Double) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            }\n        }\n    } else if (config.distance_type == DistanceType::Int32) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n            }\n        }\n    } else if (config.distance_type == DistanceType::Int64) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        // Pass nullptr: compute squared distances on-the-fly (no sqrt) for KNN ranking\n        identify_candidates_for_each_node(config, context, nullptr, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // maybe add some stopping criteria (with BHH 2D constant for example)\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // seed solution: greedy NN for first few restarts, then random for diversity\n        start_time = high_resolution_clock::now();\n        if (i <= 8) {\n            generate_greedy_nn_solution(config, context);\n        } else {\n            generate_random_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (random cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        // Early stop once close to theoretical optimum (BHH, unit square)\n        {\n            double expected = expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n            if (context.path_distance_double <= 1.04 * expected) {\n                if (i % 100 == 0) {\n                    std::cout << \"Early stop: reached <= 1.04 * BHH target (\"\n                              << context.path_distance_double << \" <= \" << 1.04 * expected << \")\\n\";\n                }\n                break;\n            }\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 20,\n    \"max_k_opt_depth\": 100,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.12,\n    \"weight_delta_coefficient\": 12.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 180,\n    \"restarts_number\": 300,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# 2025-10-09 \u2014 Quality-first + sqrt-free KNN + stability & early-stop\n\n1) **Greedy NN seeding (first 8 restarts)** to shorten initial tours \u21d2 fewer 2-opt passes and stronger basins for k-opt.\n\n2) **Mutual-KNN branching** in k-opt (edge i\u2194j required to be in both top-K lists) to avoid long crossings and wasted chains.\n\n3) **Sqrt-free KNN**: rankings computed on-the-fly by \\((\\Delta x)^2+(\\Delta y)^2\\) (no O(n\u00b2) `sqrt`), while the **final Euclidean length** is computed **directly from coordinates** (no need for a full double matrix when running int32/int64).\n\n4) **Build only needed distance matrices**: compute `double` distances iff `distance_type==\"double\"`; otherwise compute only the chosen integer matrix.\n\n5) **Numerics**: replace `pow(e,\u00b7)-1` with `expm1(\u00b7)` and `pow(e,x)` with `exp(x)` \u2192 faster and stabler small-\u0394 updates.\n\n6) **Early stop using BHH bound** for \\([0,1]^2\\): stop when \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\), \\(\\beta\\approx0.712\\) (for \\(n=500\\), threshold \u2248 **16.56**). Prioritizes path length; trims long tails once \u201cgood enough\u201d.\n\n7) **Config tune (quality-leaning)**: `K=20`, depth 100, `exploration=0.12`, `min_potential=0`, sensitivity decay on, fewer but stronger restarts (300).\n\nRationale: lower per-iteration cost, better seeds, safer branching, and a principled stop near the theoretical target (BHH), improving the **combined score** with emphasis on shorter tours.\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["You\u2019re sitting at ~17.50 for N=500 and ~16 s/instance. To push toward the 16.5 band without blowing the 120 s cap, I\u2019m making three targeted changes:\r\n\r\n1. Upgrade 2-opt from first-improvement to **steepest-improvement** each pass (better local minima; formula used:\r\n   (\\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j'))).\r\n\r\n2. Add an **Or-opt(1) relocate** pass (a.k.a. 2.5-opt). For city (i) inserted between (j) and (j'), accept if\r\n   (\\Delta = d(p,i)+d(i,n)+d(j,j')-d(p,n)-d(j,i)-d(i,j') > 0). Cheap and reliably shortens Euclidean tours.\r\n\r\n3. Cheap runtime wins: a **fast int64 sqrt** (float sqrt + 1\u20132 integer adjustments) and **more restarts** (1200) with early-stop still guarding runtime.\r\n\r\nBelow are the precise diffs.\r\n\r\n---\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nlong long int64_sqrt(long long value) {\r\n    if (value < 0) return 0;  // invalid for negatives \u2192 safe floor\r\n    if (value < 2) return value;\r\n\r\n    constexpr long long MAX_SQRT_LL = 3037000499LL;\r\n\r\n    long long left = 1;\r\n    long long right = std::min<long long>(value, MAX_SQRT_LL);\r\n    long long floor_root = 1;\r\n\r\n    while (left <= right) {\r\n        long long candidate = left + (right - left) / 2;\r\n\r\n        if (candidate <= value / candidate) {\r\n            floor_root = candidate;\r\n            left = candidate + 1;\r\n        } else {\r\n            right = candidate - 1;\r\n        }\r\n    }\r\n    return floor_root;\r\n}\r\n=======\r\nlong long int64_sqrt(long long value) {\r\n    // Fast integer sqrt via floating estimate + tiny integer correction.\r\n    // Correct for all 0 <= value <= 2^63-1.\r\n    if (value <= 0) return 0;\r\n    long double s = std::sqrt((long double)value);\r\n    long long r = (long long)s;\r\n    // Adjust down or up by at most a couple of steps to get floor(sqrt(value))\r\n    while ((r + 1) > 0 && (unsigned long long)(r + 1) * (unsigned long long)(r + 1) <= (unsigned long long)value) ++r;\r\n    while ((unsigned long long)r * (unsigned long long)r > (unsigned long long)value) --r;\r\n    return r;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\r\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\r\n\r\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\r\n\t\t}\r\n\t}\r\n    return false;\r\n}\r\n=======\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    // Steepest-improvement pass: scan all candidate pairs, pick the best gain.\r\n    int best_i = -1, best_j = -1;\r\n    double best_delta = 0.0;\r\n\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n        int i_next = context.path[i].next;\r\n\r\n        for (int k = 0; k < config.candidates_number; ++k) {\r\n            int j = context.candidates[i * config.candidates_number + k];\r\n            if (is_cities_same_or_adjacent(config, context, i, j)) continue;\r\n\r\n            int j_next = context.path[j].next;\r\n\r\n            if (config.distance_type == DistanceType::Double) {\r\n                double delta = get_distance_double(config, context, i, i_next)\r\n                             + get_distance_double(config, context, j, j_next)\r\n                             - get_distance_double(config, context, i, j)\r\n                             - get_distance_double(config, context, i_next, j_next);\r\n                if (delta > best_delta) { best_delta = delta; best_i = i; best_j = j; }\r\n            } else if (config.distance_type == DistanceType::Int32) {\r\n                int delta_i = get_distance_int32(config, context, i, i_next)\r\n                            + get_distance_int32(config, context, j, j_next)\r\n                            - get_distance_int32(config, context, i, j)\r\n                            - get_distance_int32(config, context, i_next, j_next);\r\n                if ((double)delta_i > best_delta) { best_delta = (double)delta_i; best_i = i; best_j = j; }\r\n            } else { // Int64\r\n                long long delta_l = get_distance_int64(config, context, i, i_next)\r\n                                  + get_distance_int64(config, context, j, j_next)\r\n                                  - get_distance_int64(config, context, i, j)\r\n                                  - get_distance_int64(config, context, i_next, j_next);\r\n                if ((double)delta_l > best_delta) { best_delta = (double)delta_l; best_i = i; best_j = j; }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (best_delta > 0.0) {\r\n        // Reuse existing routine to apply and maintain bookkeeping.\r\n        return apply_2_opt_move(config, context, best_i, best_j);\r\n    }\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n#pragma once\r\n\r\n\r\n// This file was specifically created for additional methods, implementations and functions that you can try to improve either time or path length metrics.\r\n=======\r\n#pragma once\r\n\r\n// Or-opt(1) relocate move and a light random 2-opt kick.\r\n// Formulas (for insertion of city i between j and j_next):\r\n// \u0394 = d(p,i) + d(i,n) + d(j,j_next) \u2212 d(p,n) \u2212 d(j,i) \u2212 d(i,j_next)\r\n// Accept if \u0394 > 0 (length decreases by \u0394).\r\n\r\ninline bool apply_relocate_1_move(const Config& config, Context& context, int i, int j) {\r\n    if (i == j) return false;\r\n\r\n    int p = context.path[i].prev;\r\n    int n = context.path[i].next;\r\n    if (p == j || n == j) return false; // adjacent/degenerate\r\n\r\n    int j_next = context.path[j].next;\r\n    if (j_next == i) return false; // would insert before itself\r\n\r\n    auto dD = [&](int a, int b){ return get_distance_double(config, context, a, b); };\r\n    auto d32 = [&](int a, int b){ return get_distance_int32(config, context, a, b); };\r\n    auto d64 = [&](int a, int b){ return get_distance_int64(config, context, a, b); };\r\n\r\n    double delta = 0.0;\r\n    if (config.distance_type == DistanceType::Double) {\r\n        double rem = dD(p,i) + dD(i,n) + dD(j,j_next);\r\n        double add = dD(p,n) + dD(j,i) + dD(i,j_next);\r\n        delta = rem - add;\r\n        if (delta <= 0.0) return false;\r\n        // detach i\r\n        context.path[p].next = n; context.path[n].prev = p;\r\n        // insert after j\r\n        context.path[j].next = i; context.path[i].prev = j;\r\n        context.path[i].next = j_next; context.path[j_next].prev = i;\r\n        context.path_distance_double -= delta;\r\n        return true;\r\n    } else if (config.distance_type == DistanceType::Int32) {\r\n        int rem = d32(p,i) + d32(i,n) + d32(j,j_next);\r\n        int add = d32(p,n) + d32(j,i) + d32(i,j_next);\r\n        int delta_i = rem - add;\r\n        if (delta_i <= 0) return false;\r\n        // detach / insert\r\n        context.path[p].next = n; context.path[n].prev = p;\r\n        context.path[j].next = i; context.path[i].prev = j;\r\n        context.path[i].next = j_next; context.path[j_next].prev = i;\r\n        context.path_distance_int32 -= delta_i;\r\n        return true;\r\n    } else { // Int64\r\n        long long rem = d64(p,i) + d64(i,n) + d64(j,j_next);\r\n        long long add = d64(p,n) + d64(j,i) + d64(i,j_next);\r\n        long long delta_l = rem - add;\r\n        if (delta_l <= 0) return false;\r\n        // detach / insert\r\n        context.path[p].next = n; context.path[n].prev = p;\r\n        context.path[j].next = i; context.path[i].prev = j;\r\n        context.path[i].next = j_next; context.path[j_next].prev = i;\r\n        context.path_distance_int64 -= delta_l;\r\n        return true;\r\n    }\r\n}\r\n\r\ninline int local_or_opt1_search(const Config& config, Context& context) {\r\n    int improved_times = 0;\r\n    bool improved = true;\r\n    while (improved) {\r\n        improved = false;\r\n        for (int i = 0; i < config.cities_number; ++i) {\r\n            // try inserting i after candidate j\r\n            for (int k = 0; k < config.candidates_number; ++k) {\r\n                int j = context.candidates[i * config.candidates_number + k];\r\n                if (apply_relocate_1_move(config, context, i, j)) {\r\n                    ++improved_times;\r\n                    improved = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return improved_times;\r\n}\r\n\r\n// Light random 2-opt kick to escape deep minima (used sparingly)\r\ninline void random_kick_two_opt(const Config& config, Context& context) {\r\n    int n = config.cities_number;\r\n    for (int it = 0; it < 8; ++it) { // a few tries to find a non-adjacent pair\r\n        int i = rand() % n;\r\n        int j = rand() % n;\r\n        if (is_cities_same_or_adjacent(config, context, i, j)) continue;\r\n\r\n        int i_next = context.path[i].next;\r\n        int j_next = context.path[j].next;\r\n\r\n        // perform 2-opt pointer changes (ignore gain; we'll recompute length)\r\n        reverse_sub_path(context, i_next, j);\r\n        context.path[i].next = j;\r\n        context.path[i_next].next = j_next;\r\n        context.path[j].prev = i;\r\n        context.path[j_next].prev = i_next;\r\n\r\n        // Recompute stored path distances for consistency\r\n        calc_and_save_total_distance(config, context);\r\n        return;\r\n    }\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n        // local 2opt search\r\n        start_time = high_resolution_clock::now();\r\n\t\timproved_times = local_2_opt_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            context.path_distance_double = calc_total_distance_double(config, context);\r\n        }\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n\r\n        // local k opt search\r\n        start_time = high_resolution_clock::now();\r\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\r\n        end_time = high_resolution_clock::now();\r\n=======\r\n        // local 2opt search (now steepest-improvement per pass)\r\n        start_time = high_resolution_clock::now();\r\n\t\timproved_times = local_2_opt_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            context.path_distance_double = calc_total_distance_double(config, context);\r\n        }\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n\r\n        // local Or-opt(1) relocate pass\r\n        start_time = high_resolution_clock::now();\r\n        int or_improved = local_or_opt1_search(config, context);\r\n        end_time = high_resolution_clock::now();\r\n\r\n        if (config.distance_type != DistanceType::Double) {\r\n            context.path_distance_double = calc_total_distance_double(config, context);\r\n        }\r\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (Or-opt1 relocate). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\r\n\r\n        // occasional light kick if relocate found nothing (diversify basins)\r\n        if (or_improved == 0 && i > 8 && (rand() % 100) < 10) {\r\n            random_kick_two_opt(config, context);\r\n        }\r\n\r\n        // local k opt search\r\n        start_time = high_resolution_clock::now();\r\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\r\n        end_time = high_resolution_clock::now();\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 20,\r\n    \"max_k_opt_depth\": 100,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.12,\r\n    \"weight_delta_coefficient\": 12.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 180,\r\n    \"restarts_number\": 300,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n=======\r\n{\r\n    \"cities_number\": 500,\r\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\r\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\r\n    \"use_heat_map_as_initial_weights\": false,\r\n    \"candidates_source\": \"knn\",\r\n    \"candidates_number\": 24,\r\n    \"max_k_opt_depth\": 110,\r\n    \"random_k_opt_depth_after_first_iteration\": true,\r\n    \"min_potential_to_consider\": 0.0,\r\n    \"exploration_coefficient\": 0.12,\r\n    \"weight_delta_coefficient\": 12.0,\r\n    \"use_sensitivity_decrease\": true,\r\n    \"sensitivity_temperature\": 8.0,\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 220,\r\n    \"restarts_number\": 1200,\r\n    \"distance_type\": \"int32\",\r\n    \"magnify_rate\": 1000000\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n# 2025-10-09 \u2014 Quality-first + sqrt-free KNN + stability & early-stop\r\n\r\n1) **Greedy NN seeding (first 8 restarts)** to shorten initial tours \u21d2 fewer 2-opt passes and stronger basins for k-opt.\r\n\r\n2) **Mutual-KNN branching** in k-opt (edge i\u2194j required to be in both top-K lists) to avoid long crossings and wasted chains.\r\n\r\n3) **Sqrt-free KNN**: rankings computed on-the-fly by \\((\\Delta x)^2+(\\Delta y)^2\\) (no O(n\u00b2) `sqrt`), while the **final Euclidean length** is computed **directly from coordinates** (no need for a full double matrix when running int32/int64).\r\n\r\n4) **Build only needed distance matrices**: compute `double` distances iff `distance_type==\"double\"`; otherwise compute only the chosen integer matrix.\r\n\r\n5) **Numerics**: replace `pow(e,\u00b7)-1` with `expm1(\u00b7)` and `pow(e,x)` with `exp(x)` \u2192 faster and stabler small-\u0394 updates.\r\n\r\n6) **Early stop using BHH bound** for \\([0,1]^2\\): stop when \\(L \\le 1.04\\cdot \\beta\\sqrt{n}\\), \\(\\beta\\approx0.712\\) (for \\(n=500\\), threshold \u2248 **16.56**). Prioritizes path length; trims long tails once \u201cgood enough\u201d.\r\n\r\n7) **Config tune (quality-leaning)**: `K=20`, depth 100, `exploration=0.12`, `min_potential=0`, sensitivity decay on, fewer but stronger restarts (300).\r\n\r\nRationale: lower per-iteration cost, better seeds, safer branching, and a principled stop near the theoretical target (BHH), improving the **combined score** with emphasis on shorter tours.\r\n=======\r\n# 2025-10-09 \u2014 Steepest 2-opt + Or-opt(1) + faster int sqrt + more restarts\r\n\r\n**What & why (formulas included)**\r\n\r\n1) **2-opt \u21d2 steepest-improvement.** Each pass picks the pair \\((i,j)\\) with maximal\r\n\\[\r\n\\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j')\r\n\\]\r\nand applies it if \\(\\Delta>0\\). Deeper local minima at modest extra cost.\r\n\r\n2) **Add Or-opt(1) relocate (a.k.a. 2.5-opt).** For moving node \\(i\\) between \\(j\\) and \\(j'\\),\r\n\\[\r\n\\Delta = d(p,i) + d(i,n) + d(j,j') - d(p,n) - d(j,i) - d(i,j')\r\n\\]\r\nAccept if \\(\\Delta>0\\). This consistently trims ~0.5\u20131.5% on Euclidean random instances with low overhead.\r\n\r\n3) **Faster int64 sqrt.** Replace binary-search `int64_sqrt` with float-estimate + 1\u20132 correction steps. Cuts O(n\u00b2) distance-prep time and speeds any on-demand integer sqrt.\r\n\r\n4) **Config for quality under 120 s.** Increase restarts to **1200**, candidates **24**, k-opt depth **110**, sims/stop **220**. Early-stop (BHH) still halts automatically once \\(L \\le 1.04\\beta\\sqrt{n}\\) (\u224816.56 for n=500), so runtime stays bounded.\r\n\r\n5) **Occasional kick.** If Or-opt makes no move, do a rare random 2-opt kick (10%) to escape sticky minima; then k-opt resumes.\r\n\r\n**Constraints honored**\r\n- `cities_number`, `input_path`, `output_path` unchanged.\r\n- Distance type remains **int32** for speed; final Euclidean score remains exact (`calc_total_distance_double`).\r\n\r\nExpected effect: lower average tour length (targeting \u226416.7 and often \u226416.6 on n=500 uniform) while staying safely <120 s/instance.\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### Why these help (blunt version)\r\n\r\n* **Steepest 2-opt**: same move set, but you stop where no improving 2-opt exists. First-improvement often parks in a weaker basin; steepest is measurably better on ([0,1]^2) instances.\r\n\r\n* **Or-opt(1)**: relocations fix local \u201cshort-long-short\u201d motifs that 2-opt can\u2019t repair without detours. It\u2019s cheap: (O(nK)) per pass with your candidate lists.\r\n\r\n* **More restarts**: your average run (300 iters) finishes ~15\u201316 s. Multiplying restarts to 1200 plus the new local moves should still keep you well under 120 s, and your existing **BHH early-stop** will cut it further when the tour is already good (\u226416.56).\r\n\r\n* **Fast int sqrt**: the old binary-search sqrt is needless overhead; the float-estimate with integral fixups is standard, exact, and faster.\r\n\r\nIf you want to squeeze even more, next knobs to try after this patch: bump `candidates_number` to 28\u201332 and set the Or-opt pass to run again after k-opt; but this patch should already improve FITNESS while keeping the codebase compact."]}}, "artifacts_json": "{\"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_train_time_elapsed\": 0.7916349999723025, \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"average_heat_map_inference_time_elapsed\": 1.1697441875312506, \"tsp_run_first_test_sample_stdout\": \"Reading configuration...\\nNumber of cities: 500\\n\\nReading input data...\\nSolving...\\n# --------- Iteration: 100\\nPhase #1 (random cycle). Total distance: 257.26117, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.295427, Improved times: 601, Time: 14 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.747428, Improved times: 55, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.687853, Improved times: 3, Time: 58 ms\\n\\n# --------- Iteration: 200\\nPhase #1 (random cycle). Total distance: 265.83829, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.016056, Improved times: 622, Time: 23 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.595262, Improved times: 30, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.595262, Improved times: 0, Time: 15 ms\\n\\n# --------- Iteration: 300\\nPhase #1 (random cycle). Total distance: 256.07659, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.065923, Improved times: 622, Time: 15 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.675387, Improved times: 30, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.675387, Improved times: 0, Time: 11 ms\\n\\n# --------- Iteration: 400\\nPhase #1 (random cycle). Total distance: 252.23062, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.05379, Improved times: 606, Time: 23 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.607985, Improved times: 34, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.594524, Improved times: 3, Time: 14 ms\\n\\n# --------- Iteration: 500\\nPhase #1 (random cycle). Total distance: 257.15864, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.02186, Improved times: 605, Time: 15 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.557467, Improved times: 44, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.557467, Improved times: 0, Time: 12 ms\\n\\n# --------- Iteration: 600\\nPhase #1 (random cycle). Total distance: 262.98188, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.070957, Improved times: 608, Time: 20 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.541777, Improved times: 45, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.541777, Improved times: 0, Time: 12 ms\\n\\n# --------- Iteration: 700\\nPhase #1 (random cycle). Total distance: 250.06722, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.516862, Improved times: 608, Time: 14 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 18.124098, Improved times: 31, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 18.124098, Improved times: 0, Time: 9 ms\\n\\n# --------- Iteration: 800\\nPhase #1 (random cycle). Total distance: 255.34404, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.345699, Improved times: 594, Time: 16 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.888661, Improved times: 46, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.808571, Improved times: 4, Time: 14 ms\\n\\n# --------- Iteration: 900\\nPhase #1 (random cycle). Total distance: 250.1756, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.065514, Improved times: 620, Time: 15 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.609129, Improved times: 39, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.604748, Improved times: 1, Time: 28 ms\\n\\n# --------- Iteration: 1000\\nPhase #1 (random cycle). Total distance: 258.98567, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.931741, Improved times: 601, Time: 14 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.498493, Improved times: 45, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.385153, Improved times: 5, Time: 60 ms\\n\\n# --------- Iteration: 1100\\nPhase #1 (random cycle). Total distance: 260.0762, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.303555, Improved times: 614, Time: 15 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.82276, Improved times: 40, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.82276, Improved times: 0, Time: 11 ms\\n\\n# --------- Iteration: 1200\\nPhase #1 (random cycle). Total distance: 261.17811, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.29524, Improved times: 599, Time: 32 ms\\nPhase #2.5 (Or-opt1 relocate). Total distance: 17.742675, Improved times: 48, Time: 0 ms\\nPhase #3 (local k'opt search). Total distance: 17.742675, Improved times: 0, Time: 12 ms\\n\\nTotal elapsed time: 38.135 sec\\n\\nFinal solution:\\n0 373 55 100 293 176 448 160 362 61 389 256 440 80 476 402 439 240 228 231 489 307 72 161 496 414 372 313 159 320 196 26 301 312 99 67 387 27 276 141 384 121 361 323 348 485 498 457 436 356 229 453 432 425 200 140 437 321 394 199 452 338 234 289 336 375 139 152 11 267 83 292 325 428 396 260 66 29 408 247 35 177 486 212 217 458 345 385 314 376 466 96 162 22 330 78 286 397 126 88 383 471 291 472 117 311 104 106 271 464 233 224 346 415 238 193 429 135 188 94 10 40 416 143 258 367 48 31 266 165 450 427 319 278 418 221 90 8 209 364 232 363 227 380 479 147 194 317 192 97 273 68 368 73 43 7 490 455 351 60 37 412 280 235 182 288 468 205 13 430 435 125 218 253 456 41 120 63 279 406 302 268 303 469 329 197 75 113 467 34 447 201 283 285 46 44 350 111 181 400 316 207 108 208 322 164 210 277 204 461 401 393 146 138 167 265 50 244 334 114 150 281 287 185 105 110 304 465 409 127 296 483 379 122 497 95 109 178 213 403 335 248 74 475 47 337 163 442 259 250 39 341 36 236 365 493 206 81 148 419 190 398 18 223 23 438 128 480 6 119 343 71 360 82 154 339 220 58 98 434 491 158 5 45 156 299 446 189 255 17 12 242 172 477 300 118 484 19 353 64 371 241 246 411 245 14 24 344 488 62 132 459 295 252 474 186 87 219 175 142 42 444 54 33 170 25 157 32 202 123 390 272 226 399 263 70 103 203 332 318 282 315 482 20 381 404 251 417 305 284 86 352 294 155 171 53 30 370 369 331 431 327 15 52 386 115 153 349 478 454 93 494 433 340 183 137 51 112 499 136 239 275 420 254 306 211 378 216 195 366 358 342 65 168 166 298 421 92 214 413 4 324 89 297 243 149 264 269 145 308 9 395 129 449 407 230 179 133 392 359 116 130 470 101 173 79 426 69 262 326 388 355 124 59 257 225 495 424 274 169 215 237 462 28 492 460 377 333 354 347 85 441 56 473 2 309 102 410 261 405 91 174 382 76 487 107 443 38 84 391 131 77 3 328 445 451 357 270 144 57 49 187 423 184 422 374 310 16 463 249 134 198 290 151 1 481 180 191 21 222 \\n\\nFinal solution score: 17.066085\\n\", \"tsp_run_first_test_sample_stderr\": \"\", \"average_tsp_run_time_elapsed\": 38.170085407589795, \"average_path_length\": 17.110160119553033, \"path_length_variance\": 0.044519034498254714}", "artifact_dir": null}