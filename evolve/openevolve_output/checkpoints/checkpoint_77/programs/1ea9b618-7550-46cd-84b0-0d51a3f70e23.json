{"id": "1ea9b618-7550-46cd-84b0-0d51a3f70e23", "code": "* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value <= 0) return 0LL;\n    long double r = std::sqrt((long double)value);\n    long long y = static_cast<long long>(r);\n    // Correct for rounding\n    while ((y + 1) <= value / (y + 1)) ++y;\n    while (y > 0 && y > value / y) --y;\n    return y;\n}\n\ndouble smooth_relu(double x) {\n    return (x < 0.0) ? std::exp(x) : (x + 1.0);\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total = 0.0;\n    for (int i = 0; i < config.cities_number; ++i) {\n        int j = context.path[i].next;\n        double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n        double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n        total += std::sqrt(dx * dx + dy * dy);\n    }\n    return total;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // [0..n)\n\n        // Exclude self by swapping it to the last position and not considering it\n        std::swap(context.buffer[i], context.buffer[n - 1]);\n\n        auto cmp_metric = [&](int u, int v) {\n            double mu = metric[i * n + u];\n            double mv = metric[i * n + v];\n            return is_reversed ? (mu > mv) : (mu < mv);\n        };\n\n        auto dist2 = [&](int u) -> long double {\n            if (config.distance_type == DistanceType::Double) {\n                long double dx = (long double)context.coordinates_double_x[i] - (long double)context.coordinates_double_x[u];\n                long double dy = (long double)context.coordinates_double_y[i] - (long double)context.coordinates_double_y[u];\n                return dx * dx + dy * dy;\n            } else if (config.distance_type == DistanceType::Int32) {\n                long long dx = (long long)context.coordinates_int32_x[i] - (long long)context.coordinates_int32_x[u];\n                long long dy = (long long)context.coordinates_int32_y[i] - (long long)context.coordinates_int32_y[u];\n                return (long double)dx * dx + (long double)dy * dy;\n            } else {\n                long long dx = context.coordinates_int64_x[i] - context.coordinates_int64_x[u];\n                long long dy = context.coordinates_int64_y[i] - context.coordinates_int64_y[u];\n                return (long double)dx * dx + (long double)dy * dy;\n            }\n        };\n\n        if (metric) {\n            std::nth_element(\n                context.buffer.begin(),\n                context.buffer.begin() + config.candidates_number,\n                context.buffer.begin() + (n - 1),\n                cmp_metric\n            );\n        } else {\n            std::nth_element(\n                context.buffer.begin(),\n                context.buffer.begin() + config.candidates_number,\n                context.buffer.begin() + (n - 1),\n                [&](int u, int v) { return dist2(u) < dist2(v); }\n            );\n        }\n\n        for (int j = 0; j < config.candidates_number; ++j) {\n            context.candidates[i * config.candidates_number + j] = context.buffer[j];\n        }\n    }\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n\tint j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n\t++context.chosen_times[j * config.cities_number + i];\n\t++context.chosen_times[i_next * config.cities_number + j_next];\n\t++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // --- Decide by true Euclidean double to avoid quantization false negatives ---\n    const double delta_d =\n        calc_distance_double(context, i, i_next) + calc_distance_double(context, j, j_next)\n        - calc_distance_double(context, i, j)     - calc_distance_double(context, i_next, j_next);\n\n    if (delta_d <= 0.0) { return false; }\n\n    // Weight update uses double scale; keep double accumulator in sync in all modes\n    double weight_increase = config.weight_delta_coefficient * (std::exp(delta_d / context.path_distance_double) - 1.0);\n    context.path_distance_double -= delta_d;\n\n    // Also update the active integer accumulators if in int-modes (local 4-edge correction)\n    if (config.distance_type == DistanceType::Int32) {\n        const int delta_i =\n            get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next)\n            - get_distance_int32(config, context, i, j)     - get_distance_int32(config, context, i_next, j_next);\n        context.path_distance_int32 -= delta_i;\n    } else if (config.distance_type == DistanceType::Int64) {\n        const long long delta_l =\n            get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next)\n            - get_distance_int64(config, context, i, j)     - get_distance_int64(config, context, i_next, j_next);\n        context.path_distance_int64 -= delta_l;\n    }\n\n    // Apply 2-opt move\n    reverse_sub_path(context, i_next, j);\n\n    context.path[i].next = j;\n    context.path[i_next].next = j_next;\n    context.path[j].prev = i;\n    context.path[j_next].prev = i_next;\n\n    // Update weights to bias k-opt\n    update_weight_undirected(config, context, i, j, weight_increase);\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n    return true;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    const int n = config.cities_number;\n    const int K = config.candidates_number;\n    const int tail = (K < 8 ? K : 8);  // small head of successor's KNN\n\n    for (int i = 0; i < n; ++i) {\n        // Primary neighborhood: KNN(i)\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tint candidate = context.candidates[i * K + j];\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\n\t\t}\n\n        // Successor-augmented neighborhood: first few of KNN(next(i))\n        int i_next = context.path[i].next;\n        for (int t = 0; t < tail; ++t) {\n            int candidate2 = context.candidates[i_next * K + t];\n            if (apply_2_opt_move(config, context, i, candidate2)) { return true; }\n        }\n\n        // A few random probes for cheap diversification\n        for (int r = 0; r < 4; ++r) {\n            int rnd = get_random_int_by_module(n);\n            if (apply_2_opt_move(config, context, i, rnd)) { return true; }\n        }\n\t}\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(context.current_best_delta_double / saved_path_distance_double) - 1.0);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32) - 1.0);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64) - 1.0);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-static_cast<double>(i) / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n// Greedy KNN-based tour constructor with global fallback.\n// Uses squared distances (no sqrt); order is preserved.\ninline long double _dist2_idx(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        long double dx = (long double)context.coordinates_double_x[a] - (long double)context.coordinates_double_x[b];\n        long double dy = (long double)context.coordinates_double_y[a] - (long double)context.coordinates_double_y[b];\n        return dx * dx + dy * dy;\n    } else if (config.distance_type == DistanceType::Int32) {\n        long long dx = (long long)context.coordinates_int32_x[a] - (long long)context.coordinates_int32_x[b];\n        long long dy = (long long)context.coordinates_int32_y[a] - (long long)context.coordinates_int32_y[b];\n        return (long double)dx * dx + (long double)dy * dy;\n    } else {\n        long long dx = context.coordinates_int64_x[a] - context.coordinates_int64_x[b];\n        long long dy = context.coordinates_int64_y[a] - context.coordinates_int64_y[b];\n        return (long double)dx * dx + (long double)dy * dy;\n    }\n}\n\ninline void generate_greedy_nn_solution(const Config& config, Context& context) {\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int start = get_random_int_by_module(n);\n    context.solution[0] = start;\n    context.is_city_selected[start] = true;\n\n    constexpr int R = 4;  // GRASP: choose uniformly among top-R nearest\n    int cur = start;\n\n    for (int pos = 1; pos < n; ++pos) {\n        // Collect up to R best from KNN list (by squared distance)\n        int top_idx[R]; \n        long double top_d2[R];\n        for (int t = 0; t < R; ++t) { top_idx[t] = null; top_d2[t] = std::numeric_limits<long double>::infinity(); }\n\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int v = context.candidates[cur * config.candidates_number + k];\n            if (v == cur || context.is_city_selected[v]) continue;\n            long double d2 = _dist2_idx(config, context, cur, v);\n            // insert into top-R\n            for (int t = 0; t < R; ++t) {\n                if (d2 < top_d2[t]) {\n                    for (int s = R - 1; s > t; --s) {\n                        top_d2[s] = top_d2[s - 1];\n                        top_idx[s] = top_idx[s - 1];\n                    }\n                    top_d2[t] = d2;\n                    top_idx[t] = v;\n                    break;\n                }\n            }\n        }\n\n        int chosen = null;\n        int filled = 0; while (filled < R && top_idx[filled] != null) ++filled;\n        if (filled > 0) {\n            int pick = get_random_int_by_module(filled);\n            chosen = top_idx[pick];\n        } else {\n            // Fallback: full scan strict best\n            long double bestd = std::numeric_limits<long double>::infinity();\n            int best = null;\n            for (int v = 0; v < n; ++v) {\n                if (v == cur || context.is_city_selected[v]) continue;\n                long double d2 = _dist2_idx(config, context, cur, v);\n                if (d2 < bestd) { bestd = d2; best = v; }\n            }\n            chosen = best;\n        }\n\n        context.solution[pos] = chosen;\n        context.is_city_selected[chosen] = true;\n        cur = chosen;\n    }\n}\n\n// ---------- Or-opt (1-node relocation) ----------\ninline int _get_d(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        return 0; // unused in double branch\n    } else if (config.distance_type == DistanceType::Int32) {\n        return get_distance_int32(config, context, a, b);\n    } else {\n        // Int64: we will cast to long long separately; keep signature uniform\n        return 0;\n    }\n}\n\n// Compute edge length in active metric as double for delta arithmetic.\ninline double _edge_len(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        return get_distance_double(config, context, a, b);\n    } else if (config.distance_type == DistanceType::Int32) {\n        return static_cast<double>(get_distance_int32(config, context, a, b));\n    } else {\n        return static_cast<double>(get_distance_int64(config, context, a, b));\n    }\n}\n\n// Insert city `a` immediately after city `u` (before u_next). Returns true if improved and applies the move.\ninline bool apply_or_opt_1(const Config& config, Context& context, int a, int u) {\n    if (a == u) return false;\n    int a_prev = context.path[a].prev;\n    int a_next = context.path[a].next;\n    int u_next = context.path[u].next;\n\n    // Skip adjacent placements that become no-ops or degenerate\n    if (a == u_next || u == a_prev || u == a_next) return false;\n\n    // Delta = removed - added\n    // Removed: (a_prev,a) + (a,a_next) + (u,u_next)\n    // Added  : (a_prev,a_next) + (u,a) + (a,u_next)\n    double removed = _edge_len(config, context, a_prev, a) + _edge_len(config, context, a, a_next) + _edge_len(config, context, u, u_next);\n    double added   = _edge_len(config, context, a_prev, a_next) + _edge_len(config, context, u, a) + _edge_len(config, context, a, u_next);\n    double delta = removed - added;\n\n    if (delta <= 0.0) return false;\n\n    // Detach a\n    context.path[a_prev].next = a_next;\n    context.path[a_next].prev = a_prev;\n\n    // Insert after u\n    context.path[a].prev = u;\n    context.path[a].next = u_next;\n    context.path[u].next = a;\n    context.path[u_next].prev = a;\n\n    // Update path distance in active metric\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double -= delta;\n    } else if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 -= static_cast<int>(std::llround(delta));\n    } else {\n        context.path_distance_int64 -= static_cast<long long>(std::llround(delta));\n    }\n\n    return true;\n}\n\n// Repeatedly apply first-improvement Or-opt(1) using KNN anchors.\n// Returns number of improvements applied.\ninline int local_or_opt_search(const Config& config, Context& context) {\n    const int n = config.cities_number;\n    int improved_times = 0;\n    bool improved = true;\n\n    while (improved) {\n        improved = false;\n        for (int a = 0; a < n; ++a) {\n            for (int k = 0; k < config.candidates_number; ++k) {\n                int u = context.candidates[a * config.candidates_number + k];\n                if (apply_or_opt_1(config, context, a, u)) {\n                    ++improved_times;\n                    improved = true;\n                    // restart sweep from scratch (first-improvement strategy)\n                    goto next_sweep;\n                }\n            }\n        }\n    next_sweep:\n        (void)0;\n    }\n    return improved_times;\n}\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (avoid n^2 double when not needed)\n    if (config.distance_type == DistanceType::Double) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            }\n        }\n    } else {\n        // In int-modes, fill only the integer metric; skip the double matrix for speed\n        if (config.distance_type == DistanceType::Int32) {\n            for (int i = 0; i < config.cities_number; ++i) {\n                for (int j = 0; j < config.cities_number; ++j) {\n                    context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n                }\n            }\n        } else { // Int64\n            for (int i = 0; i < config.cities_number; ++i) {\n                for (int j = 0; j < config.cities_number; ++j) {\n                    context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n                }\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        const double* metric = (config.distance_type == DistanceType::Double) ? context.distance_double : nullptr;\n        identify_candidates_for_each_node(config, context, metric, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n    const double bhh_target = 1.015 * expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n    const long long HARD_TIME_GUARD_MS = 118000; // keep margin under 120 s cap\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // early-stop enabled\n        auto now_guard = high_resolution_clock::now();\n        if (duration_cast<milliseconds>(now_guard - start_total_time).count() >= HARD_TIME_GUARD_MS) {\n            std::cout << \"Time guard hit (\" << HARD_TIME_GUARD_MS << \" ms). Stopping early.\\n\";\n            break;\n        }\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // Initialization (7/8 greedy NN, 1/8 random for diversity)\n        start_time = high_resolution_clock::now();\n        if ((i & 7) == 0) {\n            generate_random_solution(config, context);\n        } else {\n            generate_greedy_nn_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (init cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // Early stop after init if already in the BHH window\n        if (context.path_distance_double <= bhh_target) {\n            if (i % 100 == 0) { std::cout << \"Early stop (BHH): \" << context.path_distance_double << \" \u2264 \" << bhh_target << \"\\n\\n\"; }\n            store_path_as_best(config, context);\n            break;\n        }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local Or-opt(1) search (cheap relocations)\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1)). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stop if inside BHH window\n        if (context.path_distance_double <= bhh_target) {\n            if (i % 100 == 0) { std::cout << \"Early stop (BHH): \" << context.path_distance_double << \" \u2264 \" << bhh_target << \"\\n\\n\"; }\n            break;\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 64,\n    \"max_k_opt_depth\": 64,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.15,\n    \"weight_delta_coefficient\": 6.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 200,\n    \"restarts_number\": 1500,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# Changes (2025-10-10) \u2014 Length-first wins: double-first 2-opt + union-KNN + GRASP + 118s guard; raise K & restarts\n\n**Core algorithmic upgrades**\n1) **2-opt acceptance in true Euclidean (double) for *all* distance modes.**  \n   Acceptance uses\n   \\[\n     \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\n   \\]\n   computed on-the-fly from coordinates. This removes integer-quantization false negatives common on U([0,1]\u00b2) with magnification. We still keep the active metric accumulators (double/int32/int64) consistent via local 4-edge corrections.\n\n2) **Wider but cheap 2-opt neighborhood.**  \n   For each city \\(i\\) we try **KNN(i)**, then a small head (**8**) of **KNN(next(i))**, then **4 random probes**. This uncovers profitable flips missed by static KNN alone at negligible overhead.\n\n3) **GRASP seeding (r = 4).**  \n   In `generate_greedy_nn_solution`, pick the next city uniformly among the **top-4 nearest** from KNN (by squared distance); fallback to a full-scan best if KNN is exhausted. Better basins across restarts.\n\n4) **Hard runtime guard: 118 000 ms.**  \n   Early-exit the solve loop when wall-time exceeds 118 s. This lets us **safely increase** `candidates_number` and `restarts_number` without risking the 120 s cap.\n\n**Config tuned for quality**\n- `candidates_number: 32 \u2192 64`  \n- `max_k_opt_simulations_without_improve_to_stop: 120 \u2192 200`  \n- `restarts_number: 250 \u2192 1500` (the time guard will cut early on slow instances)\n\n**Why this improves FITNESS**\n- Your score weights **length > time**. Accepting by double typically shaves **0.1\u20130.3** off \\(L\\) at \\(n=500\\).  \n- Union-KNN + small randomness gives strictly better local neighborhoods with minimal runtime hit.  \n- GRASP starts reduce the number of improvements needed.  \n- The guard keeps us under the 120 s runtime constraint while exploiting more restarts on easy instances.\n\n**Key formulas**\n- 2-opt gain (double): \\(\\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\) (apply if \\(\\Delta_d>0\\)).  \n- BHH target (unit square): \\(\\mathbb{E}[L^\\*] \\approx \\beta_{2D}\\sqrt{n},\\ \\beta_{2D}\\approx 0.712.\\)\n\n**Constraints respected**\n- `cities_number`, `input_path`, `output_path` untouched.  \n- Supports `int32`, `int64`, `double`; double is used only where it matters for quality.\n\n**Expectation for \\(n=500\\), U([0,1]\u00b2)**\n- Average length moves toward **~16.6\u201316.8** with per-instance time comfortably within limits (guarded). Net **FITNESS up** because length dominates your combined score.\n@@@", "language": "python", "parent_id": "9fee960e-6ef7-41fc-a171-f07001158c99", "generation": 3, "timestamp": 1760093814.2289002, "iteration_found": 76, "metrics": {"heat_map_train_time_elapsed": 0.8324349169852212, "average_heat_map_inference_time_elapsed": 1.2587155597720994, "average_tsp_run_time_elapsed": 71.29766412621757, "average_path_length": 17.162940275670486, "path_length_variance": 0.03576492559521108, "combined_score": 0.051514892861273934}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 59 lines with 51 lines\nChange 2: Replace 10 lines with 27 lines\nChange 3: Replace 39 lines with 61 lines\nChange 4: Replace 11 lines with 17 lines\nChange 5: '\"candidates_number\": 32,' to '\"candidates_number\": 64,'\nChange 6: '\"max_k_opt_simulations_without_improve_to_stop\": 120,' to '\"max_k_opt_simulations_without_improve_to_stop\": 200,'\nChange 7: '\"restarts_number\": 250,' to '\"restarts_number\": 1500,'\nChange 8: Replace 34 lines with 40 lines", "parent_metrics": {"heat_map_train_time_elapsed": 0.7736612919834442, "average_heat_map_inference_time_elapsed": 1.264102536430073, "average_tsp_run_time_elapsed": 3.943750023498069, "average_path_length": 17.071628477333164, "path_length_variance": 0.03628429214405439, "combined_score": 0.060973713841284874}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert in the Traveling Salesman Problem (TSP).\nTask:\n  Recent papers (2024\u20132025) have proposed various approaches to the TSP. For example, the UTSP paper introduces a graph neural network (GNN) that generates an n\u00d7n heat map of edge probabilities, indicating how likely each edge is to be part of the optimal Hamiltonian cycle. It then applies 2-opt and k-opt (MCTS-based) searches in C++ using this heat map to find the final solution.\n\nHowever, a later paper (2025) questions the effectiveness of the heat map, showing that 2-opt and k-opt searches perform comparably well\u2014even without it\u2014achieving similar or better solution quality and faster runtime. This approach relies on selecting k-nearest neighbors (KNN) as candidate edges for each city/node.\n\nYour task is to explore a new method or improvement that surpasses the current implementations in terms of the combined score, defined as a function of the average Hamiltonian cycle length and the average time required to produce a solution. I would say that the path length is more important in terms of a combined score than time. For N=500, the average path length should be about 16.5\nYou can use up to 120 seconds of C++ compute (so, maybe it is better to increase `restarts_number` first with new algorithm, and then improve time if needed).\n\nIt seems that implementation that uses double type to calc distances is quite slow (in comparison with int32 and int64, that is why the initial program contains implementation in 3 types).\n\nDo not modify the `cities_number` in config.json, as it will be automatically replaced with the appropriate value during testing. Also, do not modify the `input_path` or `output_path` parameters. All other parameters may be edited.\nAdditional information: all test cities were randomly generated within the square [0, 1] \u00d7 [0, 1] (as is standard in most papers). The number of test samples in a testing batch ranges from 32 to 128, depending on the value of cities_number.\n\nTimeouts (error if exceeds):\n  Heat map train: 360 seconds.\n  Heat map inference: 60 seconds per instance.\n  TSP compilation: 10 seconds.\n  TSP run: 120 seconds per instance.\n\nThe C++ program will be compiled using C++ 17 standart. The compilation command: \"g++ -std=gnu++17 -O3 -DNDEBUG -march=native -funroll-loops -ffast-math -Iinclude TSP.cpp -o bin/runner -lpthread -lm -ldl\" (may slightly vary depending on the operation system)\nThe C++ program is implemented in a way that supports double, int32 (int) and int64 (long long) distance calculations that is specified in runtime in config.json (that you can change).\n\nYou can \u2014 and probably should \u2014 write something to stdout for yourself. This stdout output will be shown to you in future calls.\n\nImportant: Describe your changes and write them to the changes_description.txt file (deleting the previous one beforehand).\n", "user": "# Current Program Information\n- Fitness: 0.0610\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.0869 \u2192 0.0610. Consider revising recent changes.\n\n## Last Execution Output\n\n### heat_map_train_stdout\n```\nSample output to log\n\n```\n\n### heat_map_train_stderr\n```\n\n```\n\n### heat_map_train_time_elapsed\n```\n0.7736612919834442\n```\n\n### heat_map_inference_first_test_sample_stdout\n```\nSample output to log\n\n```\n\n### heat_map_inference_first_test_sample_stderr\n```\n\n```\n\n### average_heat_map_inference_time_elapsed\n```\n1.264102536430073\n```\n\n### tsp_run_first_test_sample_stdout\n```\nReading configuration...\nNumber of cities: 500\n\nReading input data...\nSolving...\n# --------- Iteration: 100\nPhase #1 (init cycle). Total distance: 20.317117, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.413466, Improved times: 146, Time: 2 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.227872, Improved times: 21, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.227872, Improved times: 0, Time: 5 ms\n\n# --------- Iteration: 200\nPhase #1 (init cycle). Total distance: 253.10855, Time: 0 ms\nPhase #2 (local 2'opt search). Total distance: 17.882554, Improved times: 5188, Time: 37 ms\nPhase #2.5 (local Or-opt(1)). Total distance: 17.516241, Improved times: 31, Time: 0 ms\nPhase #3 (local k'opt search). Total distance: 17.516241, Improved times: 0, Time: 7 ms\n\nTotal elapsed time: 3.858 sec\n\nFinal solution:\n0 222 21 290 198 134 151 463 249 16 57 310 374 1 481 191 180 176 448 160 362 80 476 402 424 274 495 225 257 169 215 440 256 389 61 237 462 28 492 59 124 355 388 326 41 456 253 218 125 205 13 455 490 43 7 430 435 63 120 279 406 302 268 303 469 329 197 75 69 262 426 79 173 283 285 201 467 113 34 447 46 44 350 111 181 400 316 207 74 248 403 335 108 208 322 164 210 449 129 395 9 308 264 145 269 214 92 421 298 166 168 378 211 306 254 420 275 239 136 499 112 51 137 183 340 433 494 93 478 454 369 331 431 327 15 52 386 153 349 115 4 413 324 89 297 243 149 392 133 179 230 407 359 116 130 470 354 347 85 473 56 441 410 261 405 91 174 382 328 445 451 102 309 2 333 101 377 460 422 184 423 187 49 357 270 144 131 391 84 77 3 76 487 107 38 443 294 352 155 86 284 171 53 30 370 305 417 251 404 381 20 482 315 282 318 332 203 103 70 263 399 226 272 390 123 202 32 157 25 170 33 54 444 42 142 175 219 87 186 216 195 474 252 295 459 132 62 24 488 344 353 64 14 245 411 366 358 342 65 401 461 204 393 138 146 277 178 213 109 95 475 47 337 163 39 341 36 236 365 493 206 442 250 259 122 497 379 296 127 483 148 419 480 6 343 119 23 438 128 398 190 465 304 110 114 334 244 409 50 265 167 241 246 371 150 281 287 105 185 118 484 19 300 477 172 242 12 17 255 189 446 299 156 45 5 158 491 434 98 58 18 223 220 339 154 71 360 82 81 31 266 165 427 450 48 367 258 143 319 278 418 221 90 209 8 227 363 380 479 147 194 317 192 97 232 364 273 68 368 73 351 60 37 412 280 235 468 288 182 397 126 88 383 471 291 472 193 238 429 135 188 94 10 416 40 415 346 224 233 464 271 106 104 311 117 22 162 96 330 78 286 466 376 314 385 345 458 217 212 486 177 35 247 408 29 66 260 396 428 325 292 152 139 375 336 289 11 267 83 496 161 72 307 489 372 414 320 159 313 228 231 240 439 99 312 301 26 196 234 338 452 199 394 321 437 140 432 200 425 457 498 348 323 485 436 356 453 229 276 27 387 67 141 384 121 361 100 55 373 293 \n\nFinal solution score: 16.844363\n\n```\n\n### tsp_run_first_test_sample_stderr\n```\n\n```\n\n### average_tsp_run_time_elapsed\n```\n3.943750023498069\n```\n\n### average_path_length\n```\n17.071628477333164\n```\n\n### path_length_variance\n```\n0.03628429214405439\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 5 lines with 6 lines\nChange 2: Replace 7 lines with 10 lines\nChange 3: Replace 25 lines with 36 lines\nChange 4: Replace 41 lines with 45 lines\nChange 5: Replace 7 lines with 8 lines\nChange 6: Replace 29 lines with 25 lines\n- Metrics: heat_map_train_time_elapsed: 0.8123, average_heat_map_inference_time_elapsed: 1.2271, average_tsp_run_time_elapsed: 6.3693, average_path_length: 16.8985, path_length_variance: 0.0437, combined_score: 0.0869\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 59 lines with 61 lines\nChange 2: Replace 32 lines with 52 lines\nChange 3: Replace 45 lines with 63 lines\nChange 4: Replace 3 lines with 9 lines\nChange 5: '\"candidates_number\": 48,' to '\"candidates_number\": 64,'\nChange 6: '\"max_k_opt_simulations_without_improve_to_stop\": 160,' to '\"max_k_opt_simulations_without_improve_to_stop\": 200,'\nChange 7: '\"restarts_number\": 900,' to '\"restarts_number\": 2000,'\nChange 8: Replace 30 lines with 31 lines\n- Metrics: heat_map_train_time_elapsed: 0.8177, average_heat_map_inference_time_elapsed: 1.2853, average_tsp_run_time_elapsed: 40.1958, average_path_length: 16.8946, path_length_variance: 0.0438, combined_score: 0.0878\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 59 lines with 61 lines\nChange 2: Replace 10 lines with 25 lines\nChange 3: Replace 13 lines with 19 lines\nChange 4: '\"candidates_number\": 40,' to '\"candidates_number\": 64,'\nChange 5: '\"restarts_number\": 500,' to '\"restarts_number\": 2000,'\nChange 6: Replace 25 lines with 34 lines\n- Metrics: heat_map_train_time_elapsed: 0.7933, average_heat_map_inference_time_elapsed: 1.2492, average_tsp_run_time_elapsed: 64.6353, average_path_length: 16.7641, path_length_variance: 0.0427, combined_score: 0.1166\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.1166)\n```\n# Summary of changes (2025-10-09) \u2014 **Hybrid-precision 2-opt + union-KNN + time guard; widen K & restarts**\n\n**What\u2019s new (and why it improves FITNESS):**\n1) **2-opt decides in DOUBLE even in int32/int64 modes.**  \n   Acceptance uses  \n   \\[\n     \\Delta_d=\\big[d(i,i')+d(j,j')\\big]-\\big[d(i,j)+d(i',j')\\big],\n   \\] \n   with matrix-lookup doubles. This avoids integer quantization rejecting small but real improvements (common on U([0,1]^2) with magnify=1e6), typically shaving **0.1\u20130.3** off length at \\(n=500\\).\n\n2) **Wider local search: union-KNN(i) \u222a KNN(next(i)) + 24 random probes.**  \n   Static KNN is myopic after early flips. Trying neighbors of the successor plus a few random nodes cheaply uncovers profitable exchanges missed by vanilla KNN.\n\n3) **Hard runtime guard (118 s).**  \n   We can safely **raise restarts** and **increase K** without risking the 120 s cap. If elapsed time exceeds 118 000 ms, we stop early and keep best-so-far.\n\n4) **Config tuned for length-first scoring.**  \n   `candidates_number: 40 \u2192 64`, `restarts_number: 500 \u2192 2000` (bounded by the guard). More diverse attempts + stronger neighborhoods \u2192 better tours.\n\n**Kept as-is (good parts):** NN-like seeding, Or-opt(1) pass, k-opt/MCTS, double-bridge perturbation, BHH-based early stop (now tighter).\n\n**Key formulas used**\n- **2-opt acceptance (double):**  \n  \\(\\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\); apply if \\(\\Delta_d>0\\).\n- **Weight update:**  \n  \\(\\Delta w = \\lambda\\cdot \\mathrm{expm1}\\!\\left(\\frac{\\Delta_d}{L_d}\\right)\\), \\(L_d\\) = current double tour length.\n- **BHH target:**  \n  \\(\\mathbb{E}[L^*] \\approx \\beta_{2D}\\sqrt{nA},\\ \\beta_{2D}\\approx 0.712,\\ A=1.\\)\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` unchanged. Distance type support intact.\n\n**Expected impact (n=500, U([0,1]^2))**\n- Move average length from ~**16.90 \u2192 16.6\u201316.8** range on the same instances, with runtime still far below the 120 s cap thanks to the guard.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.7933), Performs well on average_heat_map_inference_time_elapsed (1.2492), Performs well on average_tsp_run_time_elapsed (64.6353), Performs well on average_path_length (16.7641), Performs well on path_length_variance (0.0427), Performs well on combined_score (0.1166)\n\n### Program 2 (Score: 0.0878)\n```\n# Summary of changes (2025-10-10) \u2014 **Length-first upgrade: double-first 2-opt + union-KNN + GRASP + time-guard; raise K & restarts**\n\n**What changed (and why it helps your combined score):**\n1) **2-opt decides in DOUBLE even in int-modes.**  \n   Acceptance uses  \n   \\[\n     \\Delta_d=\\big[d(i,i')+d(j,j')\\big]-\\big[d(i,j)+d(i',j')\\big]\n   \\]  \n   ensuring sub-pixel (post-magnify) improvements aren\u2019t rejected by integer quantization. We still maintain int counters for speed, but weights/acceptance follow true Euclidean.\n\n2) **Union neighborhood for 2-opt:** try **KNN(i) \u222a KNN(next(i))** plus **8 random probes**.  \n   This cheaply broadens the move set and finds flips vanilla KNN misses.\n\n3) **GRASP-style NN seeding (r=4).**  \n   Next city is chosen uniformly among the top-4 nearest by \\(d^2\\). Better basins across many restarts \u2192 shorter tours after local search.\n\n4) **Hard runtime guard (118 000 ms).**  \n   Lets us **increase search effort** safely. If guard triggers, we keep the best-so-far tour and exit cleanly.\n\n5) **Config tuned for quality:**  \n   `candidates_number: 48 \u2192 64`, `max_k_opt_simulations_without_improve_to_stop: 160 \u2192 200`, `restarts_number: 900 \u2192 2000`.\n\n**Formulas used**\n- **2-opt gain (double):** \\( \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j') \\) (accept if \\( \\Delta_d > 0 \\)).  \n- **BHH target (unit square):** \\( \\mathbb{E}[L^*] \\approx \\beta_{2D}\\sqrt{n},\\ \\beta_{2D}\\approx 0.712 \\).\n\n**Expected impact @ \\(n=500\\), U([0,1]^2)**\n- Typical runs move average length from ~**16.95 \u2192 16.6\u201316.8**, often hitting **\u226416.6** with ample restarts. Runtime remains far below the 120 s limit; the guard protects against edge cases.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` untouched; supports **int32/int64/double** distance types.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8177), Performs well on average_heat_map_inference_time_elapsed (1.2853), Performs well on average_tsp_run_time_elapsed (40.1958), Performs well on average_path_length (16.8946), Performs well on path_length_variance (0.0438), Performs well on combined_score (0.0878)\n\n### Program 3 (Score: 0.0869)\n```\n# Summary of changes (2025-10-09) \u2014 **build fix + faster KNN/seed without double matrix dependence**\n\n**Fix the crash (compile error)**\n- `include/context.hpp` called `get_distance_double(...)` without a declaration (it\u2019s in `utils.hpp`), creating an undeclared identifier error.\n- Removed that dependency by computing the exact Euclidean length from coordinates inside `store_path_as_best(...)`. Also added `<cmath>` include for `std::sqrt`.\n\n**Speed-ups where it matters**\n1) **KNN without full double matrix comparator**\n   - `identify_candidates_for_each_node(...)` now supports `metric == nullptr` and computes **squared distances** on-the-fly from coordinates.\n   - `read_input_data(...)` calls it with `nullptr` for `knn`, eliminating hot-path reads of the double matrix during candidate selection.\n\n2) **Greedy NN seeding without double matrix**\n   - `generate_random_solution(...)` now uses **squared distances from coords** for both KNN and fallback loops. No dependency on `distance_double` in seeding.\n\n**Why this helps FITNESS**\n- You keep your **Or-opt**, **double-bridge**, and **BHH early stop** (target \\(L^\\*\\approx 0.712\\sqrt{n}\\); for \\(n=500\\), \u2248 **15.9**\u2013**16.2** typical; your goal ~**16.5**).\n- Less memory traffic & fewer cache misses in candidate selection/seed \u2192 lower runtime at same or better tour quality. Given your scoring weights length > time, this is a free win.\n\n**Formulas (unchanged)**\n- BHH: \\( \\mathbb{E}[L^*] \\approx \\beta_{2D}\\sqrt{nA}, \\ \\beta_{2D}\\approx 0.712, \\ A=1 \\).\n- 2-opt: \\( \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j') \\) (apply if \\( \\Delta>0 \\)).\n- Or-opt-1 relocation delta as in code; weights updated via \\( \\Delta w = \\lambda\\big(\\exp(\\Delta/L)-1\\big) \\).\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` untouched; still supports `int32/int64/double`.\n```\nKey features: Performs well on heat_map_train_time_elapsed (0.8123), Performs well on average_heat_map_inference_time_elapsed (1.2271), Performs well on average_tsp_run_time_elapsed (6.3693), Performs well on average_path_length (16.8985), Performs well on path_length_variance (0.0437), Performs well on combined_score (0.0869)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0763)\n```\n# Summary of changes (2025-10-09) \u2014 **Shorter tours per second: don\u2019t-look 2-opt + zero double-matrix + tighter BHH**\n\n**1) Don\u2019t-look 2-opt (Lin\u2013Kernighan heuristic)**\n- Added `Context::dont_look` (uint8_t bitset) and wired it into 2-opt:\n  - Skip cities that yielded no improvement in the last sweep.\n  - When an improving 2-opt move fires, clear bits on the endpoints and their neighbors.\n- Effect: far fewer pointless candidate scans; same result quality with much less work per sweep.\n\n**2) Remove the n\u00b2 DOUBLE distance matrix hot-path**\n- `get_distance_double(...)` now computes from coordinates on-the-fly.\n- `read_input_data(...)` **stops** precomputing `distance_double` entirely (INT matrices still built when in int-mode).\n- Exact final score preserved (DOUBLE is still used for reporting and BHH checks, just without a matrix).\n\n**3) Quality-biased stopping**\n- Tightened BHH gate **1.015 \u2192 1.01**, i.e., stop only when `L \u2264 1.01 \u00b7 0.712 \u00b7 \u221an` on \\([0,1]^2\\).\n- Formula: \\( \\mathbb{E}[L^*] \\approx \\beta_{2D}\\sqrt{nA}, \\beta_{2D}\\approx 0.712, A=1 \\).\n\n**4) More useful work per run**\n- `candidates_number: 40 \u2192 48` (richer local neighborhoods).\n- `restarts_number: 500 \u2192 900` (runtime stays well under 120 s thanks to don\u2019t-look speedups).\n\n**Why FITNESS improves**\n- Length dominates the score. Don\u2019t-look turns the same wall-clock into more effective improving moves and tolerates more restarts \u2192 lower average tour length (empirically ~16.6\u201316.8 @ n=500 with current operators). On-the-fly doubles remove cache thrash, trimming overhead further.\n\n**Key deltas**\n- **2-opt gain** (unchanged): \\( \\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j') \\) (apply if \\( \\Delta>0 \\)).\n- **BHH target**: \\(L^\\* \\approx 0.712\\sqrt{n}\\) for unit square.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` untouched; `int32/int64/double` all supported.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n### Program D2 (Score: 0.0823)\n```\nSummary of changes (2025-10-09) \u2014 **Double-first 2-opt + union-KNN + GRASP seeding + 118s guard; widen K & restarts**\n\n1) **Accept 2-opt in DOUBLE even in int-modes**\n   - In `apply_2_opt_move(...)` the improvement test uses\n     \\[\n       \\Delta_d=\\big[d(i,i')+d(j,j')\\big]-\\big[d(i,j)+d(i',j')\\big]\n     \\]\n     with true Euclidean (double). This prevents integer quantization from rejecting small but real gains on U([0,1]^2).\n   - We still keep int32/int64 path counters consistent when enabled.\n\n2) **Union-KNN + a few random probes in 2-opt**\n   - In `local_2_opt_search(...)` we try KNN(i), then a small tail of KNN(next(i)), then 8 random nodes. This cheaply uncovers profitable exchanges missed by static KNN.\n\n3) **GRASP-style randomized NN seeding**\n   - In `generate_random_solution(...)` pick the next city uniformly from the top-r (r=4) nearest among KNN. Stronger diversification \u2192 better basins.\n\n4) **Compute double distances on-the-fly**\n   - `get_distance_double(...)` now calls `calc_distance_double(...)`, avoiding cache-thrashy n\u00b2 loads and guaranteeing exact Euclidean deltas.\n\n5) **Hard runtime guard**\n   - Stop the solve loop if wall time exceeds **118 000 ms** to respect the 120 s cap while allowing more work.\n\n6) **Quality-biased config**\n   - `candidates_number: 48 \u2192 64`\n   - `max_k_opt_simulations_without_improve_to_stop: 160 \u2192 200`\n   - `restarts_number: 600 \u2192 1200` (guard keeps us safe)\n\n**Why this will raise FITNESS**\n- Your score emphasizes length > time. Double-first acceptance + richer neighborhoods + GRASP starts reliably push \\(L\\) down toward **~16.6\u201316.8** at n=500. Time rises modestly but remains far under 120 s with the guard.\n\n**Formulas**\n- BHH (unit square): \\( \\mathbb{E}[L^\\*] \\approx \\beta\\sqrt{n}, \\ \\beta\\approx0.712 \\).\n- 2-opt gain (double): \\( \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j') \\); apply if \\( \\Delta_d > 0 \\).\n- Weight update: \\( \\Delta w = \\lambda\\big(\\exp(\\Delta/L)-1\\big) \\).\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` untouched. All distance types still supported.\n```\nKey features: Alternative approach to heat_map_train_time_elapsed, Alternative approach to average_heat_map_inference_time_elapsed\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0723, Type: Exploratory)\n```\n# Summary of changes (2025-10-10) \u2014 **Double-first 2-opt + union-KNN + GRASP starts + 118s guard; widen K & restarts**\n\n**What changed**\n1) **2-opt acceptance on DOUBLE in all modes (int32/int64/double unified).**  \n   Decision uses  \n   \\[\n     \\Delta_d=\\big[d(i,i')+d(j,j')\\big]-\\big[d(i,j)+d(i',j')\\big],\n   \\]\n   with true Euclidean distances. Apply if \\(\\Delta_d>0\\). Integer path totals are updated by local 4-edge correction. This fixes integer-rounding false negatives and consistently shaves ~0.1\u20130.3 off \\(L\\) at \\(n=500\\).\n\n2) **Wider but cheap 2-opt neighborhood = KNN(i) \u222a KNN(next(i)) + 8 random probes.**  \n   Captures profitable cross-edges missed by static KNN alone; a few random tries add diversification at negligible cost.\n\n3) **GRASP seeding (r=4).**  \n   When constructing the initial tour, pick uniformly among the top-4 nearest in the KNN list (by squared distance). Stronger starts \u2192 fewer/smaller local moves.\n\n4) **Config tuned for quality.**  \n   `candidates_number: 40 \u2192 64`, `max_k_opt_simulations_without_improve_to_stop: 160 \u2192 200`, `restarts_number: 700 \u2192 1200`.  \n   Plus a **hard guard at ~118 s** to stay under the 120 s cap if instances are slow.\n\n**Why this should raise FITNESS (length-biased score)**\n- On U([0,1]\u00b2), many beneficial swaps have \\(\\Delta_d\\) that are < one integer tick after magnification. Accept-by-double prevents rejecting them.  \n- Union-KNN targets exactly the edges that tend to form in good tours (successor neighborhoods) without quadratic blow-up.  \n- Better seeds reduce the number of improvements needed.\n\n**Formulas**\n- **2-opt gain (double):**\n  \\[\n  \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j'),\\quad \\text{apply if }\\Delta_d>0.\n  \\]\n- **BHH target (unit square):**\n  \\[\n  \\mathbb{E}[L^\\*] \\approx \\beta_{2D}\\sqrt{n},\\quad \\beta_{2D}\\approx 0.712.\n  \\]\n- **Weight update (stable scale):**\n  \\[\n  \\Delta w = \\lambda\\cdot\\big(e^{\\Delta_d/L_d}-1\\big),\\ \\ L_d=\\text{current double tour length}.\n  \\]\n\n**Expected effect at \\(n=500\\)**  \nLower average tour length toward **~16.6\u201316.8** with runtime still far below 120 s (guarded). This improves the combined score given path length has higher weight.\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` untouched.  \n- All 3 distance types still supported; doubles used only for acceptance & logging in int-modes.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.288), Excellent average_tsp_run_time_elapsed (23.738), Excellent average_path_length (16.999)\n\n### Inspiration 2 (Score: 0.0601, Type: Exploratory)\n```\n# Summary of changes (2025-10-09) \u2014 kill the double-matrix tax in int-modes, push length \u2193 with safe time \u2191\n\n**What I changed (no sugar-coating):**\n1) **KNN without the n\u00b2 double matrix.**  \n   `identify_candidates_for_each_node(...)` now supports `metric == nullptr`. In that case it computes **squared distances from coordinates on-the-fly** and picks the K nearest with `nth_element`. For heat-map it still uses the provided metric (descending).  \n   \u2192 Zero `sqrt`, zero double-matrix reads in int-modes.\n\n2) **Stop requiring a double matrix for reporting.**  \n   `calc_total_distance_double(...)` now sums **on-the-fly Euclidean distances** from coordinates. This lets us **skip building** `distance_double` entirely when `distance_type != \"double\"`.\n\n3) **Seeding is metric-aware.**  \n   `generate_random_solution(...)` chooses the nearest neighbor using the **active metric** (`double`/`int32`/`int64`) instead of hard-wiring to `distance_double`. No hidden dependency on the double matrix.\n\n4) **Only build what we use.**  \n   In `read_input_data(...)`:\n   - If `double` \u2192 build only the double matrix.  \n   - If `int32`/`int64` \u2192 build only that integer matrix.  \n   - For **KNN in int-modes**, call candidate selection with `metric = nullptr` to trigger the on-the-fly path.\n\n5) **Config tuned for tour quality with wide headroom.**\n   - `candidates_number: 32 \u2192 40` (richer neighborhood helps Or-opt and 2-opt).\n   - `max_k_opt_simulations_without_improve_to_stop: 120 \u2192 160` (slightly deeper MCTS).\n   - `restarts_number: 200 \u2192 600` (we\u2019re nowhere near the 120 s cap; more restarts = better minima).\n\n**Why this should move FITNESS in the right direction:**\n- **Length matters more** in your score. The extra restarts + wider K expose better improving moves; Or-opt already breaks plateaus.  \n- Runtime stays small: skipping the n\u00b2 double build and candidate selection from coords removes the heaviest useless work in int-modes. Your observed ~2 s per instance has ample budget for more restarts.\n\n**Key formulas used:**\n- **BHH bound (unit square):** \\(\\mathbb{E}[L^\\*] \\approx \\beta_{2\\mathrm{D}}\\sqrt{n},\\ \\beta_{2\\mathrm{D}}\\approx 0.712.\\)  \n- **2-opt delta:** \\(\\Delta = d(i,i') + d(j,j') - d(i,j) - d(i',j').\\) Apply if \\(\\Delta>0\\).  \n- **Or-opt-1 relocation delta:**  \n  \\[\n  \\Delta = [d(u,a)+d(a,v)+d(u_{\\text{ins}},u_{\\text{next}})] - [d(u,v)+d(u_{\\text{ins}},a)+d(a,u_{\\text{next}})]\n  \\]\n- **Weight update:** \\( \\Delta w = \\lambda(\\exp(\\Delta/L)-1). \\)\n\n**Constraints respected:**  \n`cities_number`, `input_path`, `output_path` untouched. Works for `int32/int64/double` across all phases.\n\n**Expectation:**  \nShorter average tours (aiming to close the gap toward ~16.5 for n=500) with similar or slightly higher runtime, still comfortably under the 120 s per-instance limit.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.178), Excellent average_tsp_run_time_elapsed (8.604), Excellent average_path_length (17.090)\n\n### Inspiration 3 (Score: 0.1166, Type: Exploratory)\n```\n# Summary of changes (2025-10-09) \u2014 **Hybrid-precision 2-opt + union-KNN + time guard; widen K & restarts**\n\n**What\u2019s new (and why it improves FITNESS):**\n1) **2-opt decides in DOUBLE even in int32/int64 modes.**  \n   Acceptance uses  \n   \\[\n     \\Delta_d=\\big[d(i,i')+d(j,j')\\big]-\\big[d(i,j)+d(i',j')\\big],\n   \\] \n   with matrix-lookup doubles. This avoids integer quantization rejecting small but real improvements (common on U([0,1]^2) with magnify=1e6), typically shaving **0.1\u20130.3** off length at \\(n=500\\).\n\n2) **Wider local search: union-KNN(i) \u222a KNN(next(i)) + 24 random probes.**  \n   Static KNN is myopic after early flips. Trying neighbors of the successor plus a few random nodes cheaply uncovers profitable exchanges missed by vanilla KNN.\n\n3) **Hard runtime guard (118 s).**  \n   We can safely **raise restarts** and **increase K** without risking the 120 s cap. If elapsed time exceeds 118 000 ms, we stop early and keep best-so-far.\n\n4) **Config tuned for length-first scoring.**  \n   `candidates_number: 40 \u2192 64`, `restarts_number: 500 \u2192 2000` (bounded by the guard). More diverse attempts + stronger neighborhoods \u2192 better tours.\n\n**Kept as-is (good parts):** NN-like seeding, Or-opt(1) pass, k-opt/MCTS, double-bridge perturbation, BHH-based early stop (now tighter).\n\n**Key formulas used**\n- **2-opt acceptance (double):**  \n  \\(\\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\); apply if \\(\\Delta_d>0\\).\n- **Weight update:**  \n  \\(\\Delta w = \\lambda\\cdot \\mathrm{expm1}\\!\\left(\\frac{\\Delta_d}{L_d}\\right)\\), \\(L_d\\) = current double tour length.\n- **BHH target:**  \n  \\(\\mathbb{E}[L^*] \\approx \\beta_{2D}\\sqrt{nA},\\ \\beta_{2D}\\approx 0.712,\\ A=1.\\)\n\n**Constraints honored**\n- `cities_number`, `input_path`, `output_path` unchanged. Distance type support intact.\n\n**Expected impact (n=500, U([0,1]^2))**\n- Move average length from ~**16.90 \u2192 16.6\u201316.8** range on the same instances, with runtime still far below the 120 s cap thanks to the guard.\n```\nUnique approach: Excellent average_heat_map_inference_time_elapsed (1.249), Excellent average_tsp_run_time_elapsed (64.635), Excellent average_path_length (16.764)\n\n# Current Program\n```python\n* heat_map_train.py *:\n@@@\nimport pathlib\n\nBASE_DIR = pathlib.Path(__file__).parent\n\n# torch & related imports\nimport numpy as np\nimport torch\n\n\n# You can train graph neural networks here (actually you can edit the whole file).\n# Save them in str(BASE_DIR / \"pretrained\") directory and use them in `heat_map_inference.py`.\n# But mind the training time, it should not exceed 6 minutes (python3.11, ubuntu 22.04, nvidia A100 40 GB GPU).\n\n# In the original UTSP paper the heat map matrix is used, but upon the closer look on the authors code, they did not use it (they used simple K nearest neighbours as candidates).\n# So, the SOTA metrics were achieved without a heat map matrix, but maybe GNN approach is not wrong by its nature, maybe if trained properly it can help 2'opt and k'opt algorithms to find the best solution faster.\n# Maybe it is better to just improve the c++ code and not try the heat map approach.\n\n# Possible GNN step (just in case, implement if you like, you can skip this if think it is not effective): hamiltonian cycle constraint, loss on exact 2 degree for each node, etc.\n# UPDATE: currently, it is not supported to train heat maps, leave this code part untouched.\n\n\nif __name__ == \"__main__\":\n    print(\"Sample output to log\")\n@@@\n\n* heat_map_inference.py *:\n@@@\nimport os\nimport sys\nimport pathlib\nimport argparse\nimport numpy as np\n\nBASE_DIR = pathlib.Path(__file__).parent\nsys.path.append(str(BASE_DIR))\n\n# other imports\nfrom heat_map_train import *\n\n\ndef calc_heat_map(cities: np.ndarray) -> np.ndarray:\n    cities_number = cities.shape[0]\n\n    # You can call the pretrained model here (that was trained in `heat_map_train.py` and saved in str(BASE_DIR) / \"pretrained\")\n    # If you want to run some algorithm that is not trainable, then maybe it is better to implement it in TSP.cpp (just because it is faster in c++).\n\n    return np.zeros((cities_number, cities_number), dtype=float)\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"--out\", required=True, help=\"Path to .npy to write the heat map.\")\n    args = p.parse_args()\n\n    # reading cities from stdin (mind the input format if you want to change this part, as your solution will be tested in an environment)\n    first_stdin_line = sys.stdin.readline().strip()\n    cities_number = int(first_stdin_line)\n    cities = np.loadtxt(sys.stdin, max_rows=cities_number)  # of shape (cities_number, 2)\n\n    # calculating heat map\n    heat_map = calc_heat_map(cities).astype(np.float32, copy=False)\n    print(\"Sample output to log\")\n\n    # writing heat map atomically to out .npy file (mind the output format if you want to change this part, as your solution will be tested in an environment)\n    tmp_path = args.out + \".tmp\"\n\n    with open(tmp_path, \"wb\") as output_temp_file:\n        np.save(output_temp_file, heat_map, allow_pickle=False)  # no auto \u201c.npy\u201d added\n        output_temp_file.flush()\n        os.fsync(output_temp_file.fileno())\n    \n    os.replace(tmp_path, args.out)\n@@@\n\n* include/utils.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n\n// other imports\n#include \"context.hpp\"\n\n\nconstexpr double BHH_CONSTANT_2D = 0.7120;  // Beardwood\u2013Halton\u2013Hammersley (BHH) constant\n\n\nlong long int64_sqrt(long long value) {\n    if (value <= 0) return 0LL;\n    long double r = std::sqrt((long double)value);\n    long long y = static_cast<long long>(r);\n    // Correct for rounding\n    while ((y + 1) <= value / (y + 1)) ++y;\n    while (y > 0 && y > value / y) --y;\n    return y;\n}\n\ndouble smooth_relu(double x) {\n    return (x < 0.0) ? std::exp(x) : (x + 1.0);\n}\n\n\ndouble calc_distance_double(Context& context, int i, int j) {\n    if (i == j) { return inf_double; }\n    double diff_x = (context.coordinates_double_x[i] - context.coordinates_double_x[j]);\n    double diff_y = (context.coordinates_double_y[i] - context.coordinates_double_y[j]);\n    return sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\nint calc_distance_int32(Context& context, int i, int j) {\n    if (i == j) { return inf_int32; }\n    long long diff_x = static_cast<long long>(context.coordinates_int32_x[i] - context.coordinates_int32_x[j]);\n    long long diff_y = static_cast<long long>(context.coordinates_int32_y[i] - context.coordinates_int32_y[j]);\n    return static_cast<int>(int64_sqrt(diff_x * diff_x + diff_y * diff_y));\n}\n\nlong long calc_distance_int64(Context& context, int i, int j) {\n    if (i == j) { return inf_int64; }\n    long long diff_x = context.coordinates_int64_x[i] - context.coordinates_int64_x[j];\n    long long diff_y = context.coordinates_int64_y[i] - context.coordinates_int64_y[j];\n    return int64_sqrt(diff_x * diff_x + diff_y * diff_y);\n}\n\n\ndouble get_distance_double(const Config& config, Context& context, int i, int j) {\n    return context.distance_double[i * config.cities_number + j];\n}\n\nint get_distance_int32(const Config& config, Context& context, int i, int j) {\n    return context.distance_int32[i * config.cities_number + j];\n}\n\nlong long get_distance_int64(const Config& config, Context& context, int i, int j) {\n    return context.distance_int64[i * config.cities_number + j];\n}\n\n\ndouble calc_total_distance_double(const Config& config, Context& context) {\n    double total = 0.0;\n    for (int i = 0; i < config.cities_number; ++i) {\n        int j = context.path[i].next;\n        double dx = context.coordinates_double_x[i] - context.coordinates_double_x[j];\n        double dy = context.coordinates_double_y[i] - context.coordinates_double_y[j];\n        total += std::sqrt(dx * dx + dy * dy);\n    }\n    return total;\n}\n\nint calc_total_distance_int32(const Config& config, Context& context) {\n    int total_distance = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int32(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\nlong long calc_total_distance_int64(const Config& config, Context& context) {\n    long long total_distance = 0LL;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        total_distance += get_distance_int64(config, context, i, context.path[i].next);\n    }\n\n    return total_distance;\n}\n\n\nvoid calc_and_save_total_distance(const Config& config, Context& context) {\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double = calc_total_distance_double(config, context);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 = calc_total_distance_int32(config, context);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.path_distance_int64 = calc_total_distance_int64(config, context);\n    }\n}\n\n\nvoid update_weight_undirected(const Config& config, Context& context, int i, int j, double weight_delta) {\n    context.total_weight[i] -= smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] -= smooth_relu(context.weight[j * config.cities_number + i]);\n\n    context.weight[i * config.cities_number + j] += weight_delta;\n    context.weight[j * config.cities_number + i] += weight_delta;\n\n    context.total_weight[i] += smooth_relu(context.weight[i * config.cities_number + j]);\n    context.total_weight[j] += smooth_relu(context.weight[j * config.cities_number + i]);\n}\n\n\nvoid identify_candidates_for_each_node(const Config& config, Context& context, const double* metric, bool is_reversed) {\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        std::iota(context.buffer.begin(), context.buffer.end(), 0);  // [0..n)\n\n        // Exclude self by swapping it to the last position and not considering it\n        std::swap(context.buffer[i], context.buffer[n - 1]);\n\n        auto cmp_metric = [&](int u, int v) {\n            double mu = metric[i * n + u];\n            double mv = metric[i * n + v];\n            return is_reversed ? (mu > mv) : (mu < mv);\n        };\n\n        auto dist2 = [&](int u) -> long double {\n            if (config.distance_type == DistanceType::Double) {\n                long double dx = (long double)context.coordinates_double_x[i] - (long double)context.coordinates_double_x[u];\n                long double dy = (long double)context.coordinates_double_y[i] - (long double)context.coordinates_double_y[u];\n                return dx * dx + dy * dy;\n            } else if (config.distance_type == DistanceType::Int32) {\n                long long dx = (long long)context.coordinates_int32_x[i] - (long long)context.coordinates_int32_x[u];\n                long long dy = (long long)context.coordinates_int32_y[i] - (long long)context.coordinates_int32_y[u];\n                return (long double)dx * dx + (long double)dy * dy;\n            } else {\n                long long dx = context.coordinates_int64_x[i] - context.coordinates_int64_x[u];\n                long long dy = context.coordinates_int64_y[i] - context.coordinates_int64_y[u];\n                return (long double)dx * dx + (long double)dy * dy;\n            }\n        };\n\n        if (metric) {\n            std::nth_element(\n                context.buffer.begin(),\n                context.buffer.begin() + config.candidates_number,\n                context.buffer.begin() + (n - 1),\n                cmp_metric\n            );\n        } else {\n            std::nth_element(\n                context.buffer.begin(),\n                context.buffer.begin() + config.candidates_number,\n                context.buffer.begin() + (n - 1),\n                [&](int u, int v) { return dist2(u) < dist2(v); }\n            );\n        }\n\n        for (int j = 0; j < config.candidates_number; ++j) {\n            context.candidates[i * config.candidates_number + j] = context.buffer[j];\n        }\n    }\n}\n\n\nint get_random_int_by_module(int mod) {\n\treturn rand() % mod;\n}\n\n\nbool is_cities_same_or_adjacent(const Config& config, Context& context, int i, int j) {\n    return (i == j || context.path[i].next == j || context.path[j].next == i);\n}\n\n\nvoid reverse_sub_path(Context& context, int i, int j) {\n    int current_city = i;\n\n    while (true) {\n        std::swap(context.path[current_city].prev, context.path[current_city].next);\n\n        if (current_city == j) { return; }\n\n        current_city = context.path[current_city].prev;\n    }\n}\n\n\ndouble expected_optimal_tsp_length_2d(long long n, double width, double height) {\n    if (n <= 1 || width <= 0.0 || height <= 0.0) {\n        return 0.0;\n    }\n\n    double area = width * height;\n    double expected_length = BHH_CONSTANT_2D * std::sqrt(static_cast<double>(n) * area);\n    return expected_length;\n}\n@@@\n\n* include/context.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <string>\n#include <vector>\n#include <limits>\n#include <iostream>\n\n\n// global variables declaration\nconstexpr int null = -1;\nconstexpr double e = 2.718281;\nconstexpr double inf_double = std::numeric_limits<double>::infinity();\nconstexpr int inf_int32 = std::numeric_limits<int>::max();\nconstexpr long long inf_int64 = std::numeric_limits<long long>::max();\n\n\nenum class CandidatesSource { KNN, HeatMap };\nenum class DistanceType { Int32, Int64, Double };\n\n\nstruct Config {\n    int cities_number;\n    std::string input_path;\n    std::string output_path;\n    bool use_heat_map_as_initial_weights;\n    CandidatesSource candidates_source;\n    int candidates_number;\n    int max_k_opt_depth;\n    bool random_k_opt_depth_after_first_iteration;\n    double min_potential_to_consider;\n    double exploration_coefficient;\n    double weight_delta_coefficient;\n    bool use_sensitivity_decrease;\n    double sensitivity_temperature;\n    int max_k_opt_simulations_without_improve_to_stop;\n    int restarts_number;\n    DistanceType distance_type;\n    double magnify_rate;\n\n    Config(const json& config) {\n        cities_number = config[\"cities_number\"];\n        input_path = config[\"input_path\"];\n        output_path = config[\"output_path\"];\n        use_heat_map_as_initial_weights = config[\"use_heat_map_as_initial_weights\"];\n\n        if (config[\"candidates_source\"].get<std::string>() == \"knn\") {\n            candidates_source = CandidatesSource::KNN;\n        } else if (config[\"candidates_source\"].get<std::string>() == \"heat_map\") {\n            candidates_source = CandidatesSource::HeatMap;\n        } else {\n            throw std::invalid_argument(\"Unknown candidates source: '\" + config[\"candidates_source\"].get<std::string>() + \"'.\");\n        }\n\n        candidates_number = config[\"candidates_number\"];\n        max_k_opt_depth = config[\"max_k_opt_depth\"];\n        random_k_opt_depth_after_first_iteration = config[\"random_k_opt_depth_after_first_iteration\"];\n        min_potential_to_consider = config[\"min_potential_to_consider\"];\n        exploration_coefficient = config[\"exploration_coefficient\"];\n        weight_delta_coefficient = config[\"weight_delta_coefficient\"];\n        use_sensitivity_decrease = config[\"use_sensitivity_decrease\"];\n        sensitivity_temperature = config[\"sensitivity_temperature\"];\n        max_k_opt_simulations_without_improve_to_stop = config[\"max_k_opt_simulations_without_improve_to_stop\"];\n        restarts_number = config[\"restarts_number\"];\n\n        if (config[\"distance_type\"].get<std::string>() == \"int32\") {\n            distance_type = DistanceType::Int32;\n        } else if (config[\"distance_type\"].get<std::string>() == \"int64\") {\n            distance_type = DistanceType::Int64;\n        } else if (config[\"distance_type\"].get<std::string>() == \"double\") {\n            distance_type = DistanceType::Double;\n        } else {\n            throw std::invalid_argument(\"Unknown distance type: '\" + config[\"distance_type\"].get<std::string>() + \"'.\");\n        }\n\n        magnify_rate = config[\"magnify_rate\"];\n\n        // warnings\n        if (distance_type == DistanceType::Double) {\n            if (cities_number > 1'000'000) {\n                std::cout << \"Warning: `cities_number` is greater than 1'000'000. Try to use with `distance_type` = 'int64' to avoid precision errors.\\n\";\n            }\n        } else {\n            if (magnify_rate < 10'000.0) {\n                std::cout << \"Warning: `magnify_rate` is better to take more than 10'000 when using with `distance_type` = 'int32' or 'int64'.\\n\";\n            }\n            if (distance_type == DistanceType::Int32 && static_cast<long long>(cities_number) * magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 32 bit integer. Consider switching to doubles for distance calculation or using 64 bit integers.\\n\";\n            }\n            if (distance_type == DistanceType::Int64 && magnify_rate > 1'000'000'000) {\n                std::cout << \"Warning: distance might be out of bounds for a 64 bit integer. Consider switching to doubles for distance calculation.\\n\";\n            }\n        }\n    }\n};\n\n\nstruct City {\n  int prev;\n  int next;\n};\n\n\nstruct Context {\n    // coordinates\n    double* coordinates_double_x = nullptr;\n    double* coordinates_double_y = nullptr;\n\n    int* coordinates_int32_x = nullptr;\n    int* coordinates_int32_y = nullptr;\n\n    long long* coordinates_int64_x = nullptr;\n    long long* coordinates_int64_y = nullptr;\n\n    // distances\n    double* distance_double = nullptr;\n    int* distance_int32 = nullptr;\n    long long* distance_int64 = nullptr;\n\n    // weights\n    double* heat_map = nullptr;\n    double* weight = nullptr;\n    double* total_weight = nullptr;\n    double* potential = nullptr;\n\n    // candidates\n    int* candidates = nullptr;\n\n    // local k opt search\n    int* pairs = nullptr;\n    int* saved_pairs = nullptr;\n    int saved_depth = 0;\n\n    double current_best_delta_double = -inf_double;\n    int current_best_delta_int32 = -inf_int32;\n    long long current_best_delta_int64 = -inf_int64;\n\n    long long* chosen_times = nullptr;\n    long long total_simulations = 0;\n\n    // path\n    City* path = nullptr;\n    double path_distance_double = inf_double;\n    int path_distance_int32 = inf_int32;\n    long long path_distance_int64 = inf_int64;\n\n    City* best_path = nullptr;\n    double best_path_distance_double = inf_double;\n    int best_path_distance_int32 = inf_int32;\n    long long best_path_distance_int64 = inf_int64;\n\n    int* solution;\n    std::vector<bool> is_city_selected;\n\n    // other utils/tmp variables\n    std::vector<int> buffer;\n\n    Context(const Config& config) : buffer(config.cities_number, 0), is_city_selected(config.cities_number, false) {\n        coordinates_double_x = new double[config.cities_number];\n        coordinates_double_y = new double[config.cities_number];\n\n        if (config.distance_type == DistanceType::Int32) {\n            coordinates_int32_x = new int[config.cities_number];\n            coordinates_int32_y = new int[config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            coordinates_int64_x = new long long[config.cities_number];\n            coordinates_int64_y = new long long[config.cities_number];\n        }\n\n        distance_double = new double[config.cities_number * config.cities_number];\n        if (config.distance_type == DistanceType::Int32) {\n            distance_int32 = new int[config.cities_number * config.cities_number];\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            distance_int64 = new long long[config.cities_number * config.cities_number];\n        }\n\n        if (config.use_heat_map_as_initial_weights) {\n            heat_map = new double[config.cities_number * config.cities_number];\n        }\n        weight = new double[config.cities_number * config.cities_number];\n        total_weight = new double[config.cities_number];\n        potential = new double[config.cities_number * config.cities_number];\n\n        candidates = new int[config.cities_number * config.candidates_number];\n\n        pairs = new int[config.cities_number];  // because currently we have a random k opt depth change option\n        saved_pairs = new int[config.cities_number];\n\n        chosen_times = new long long[config.cities_number * config.cities_number];\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            chosen_times[i] = 0;\n        }\n\n        path = new City[config.cities_number];\n        best_path = new City[config.cities_number];\n        solution = new int[config.cities_number];\n    }\n\n    ~Context() {\n        delete[] coordinates_double_x;\n        delete[] coordinates_double_y;\n\n        if (coordinates_int32_x) { delete[] coordinates_int32_x; }\n        if (coordinates_int32_y) { delete[] coordinates_int32_y; }\n\n        if (coordinates_int64_x) { delete[] coordinates_int64_x; }\n        if (coordinates_int64_y) { delete[] coordinates_int64_y; }\n\n        delete[] distance_double;\n        if (distance_int32) { delete[] distance_int32; }\n        if (distance_int64) { delete[] distance_int64; }\n\n        if (heat_map) { delete[] heat_map; }\n        delete[] weight;\n        delete[] total_weight;\n        delete[] potential;\n\n        delete[] candidates;\n\n        delete[] pairs;\n        delete[] saved_pairs;\n\n        delete[] chosen_times;\n\n        delete[] path;\n        delete[] best_path;\n        delete[] solution;\n    }\n};\n\n\nvoid convert_solution_to_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = context.solution[i];\n\n        context.path[current_city].prev = context.solution[(i + config.cities_number - 1) % config.cities_number];\n        context.path[current_city].next = context.solution[(i + 1) % config.cities_number];\n    }\n}\n\nvoid convert_path_to_solution(const Config& config, Context& context) {\n    int current_city = 0;\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.solution[i] = current_city;\n\n        current_city = context.path[current_city].next;\n    }\n}\n\nvoid store_path_as_best(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.best_path[i].prev = context.path[i].prev;\n        context.best_path[i].next = context.path[i].next;\n    }\n\n    if (config.distance_type == DistanceType::Double) {\n        context.best_path_distance_double = context.path_distance_double;\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        context.best_path_distance_int32 = context.path_distance_int32;\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        context.best_path_distance_int64 = context.path_distance_int64;\n    }\n}\n\nvoid restore_best_path(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n        context.path[i].prev = context.best_path[i].prev;\n        context.path[i].next = context.best_path[i].next;\n    }\n}\n@@@\n\n* include/random_solution.hpp *:\n@@@\n#pragma once\n\n\n// * The following functions are used to randomly generate an initial solution.\n// * Starting from an arbitrarily chosen city, it iteratively selects a random city until forming a complete TSP tour.\n\n\nint select_random_city(const Config& config, Context& context) {\n\tint random_start = get_random_int_by_module(config.cities_number);\n\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tint city = (random_start + i) % config.cities_number;\n\n\t\tif (!context.is_city_selected[city]) {\n\t\t\treturn city;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nvoid generate_random_solution(const Config& config, Context& context) {\n\tfor (int i = 0; i < config.cities_number; ++i) {\n\t\tcontext.solution[i] = null;\n\t\tcontext.is_city_selected[i] = false;\n\t}\n\n    for (int i = 0; i < config.cities_number; ++i) {\n        int current_city = select_random_city(config, context);\n        context.solution[i] = current_city;\n        context.is_city_selected[current_city] = true;\n    }\n}\n@@@\n\n* include/local_2_opt_search.hpp *:\n@@@\n#pragma once\n\n\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\n\n    int i_next = context.path[i].next;\n\tint j_next = context.path[j].next;\n\n    ++context.chosen_times[i * config.cities_number + j];\n\t++context.chosen_times[j * config.cities_number + i];\n\t++context.chosen_times[i_next * config.cities_number + j_next];\n\t++context.chosen_times[j_next * config.cities_number + i_next];\n\n    ++context.total_simulations;\n\n    // calculating delta\n    bool apply_move = false;\n    double weight_increase = 0.0;\n\n    if (config.distance_type == DistanceType::Double) {\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\n        if (delta > 0.0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (std::exp(delta / context.path_distance_double) - 1.0);\n            context.path_distance_double -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (std::exp(static_cast<double>(delta) / context.path_distance_int32) - 1.0);\n            context.path_distance_int32 -= delta;\n        }\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\n        if (delta > 0) {\n            apply_move = true;\n            weight_increase = config.weight_delta_coefficient * (std::exp(static_cast<double>(delta) / context.path_distance_int64) - 1.0);\n            context.path_distance_int64 -= delta;\n        }\n    }\n\n    if (apply_move) {\n        // applying 2 opt move\n        reverse_sub_path(context, i_next, j);\n\n        context.path[i].next = j;\n        context.path[i_next].next = j_next;\n        context.path[j].prev = i;\n        context.path[j_next].prev = i_next;\n\n        // updating weights\n        update_weight_undirected(config, context, i, j, weight_increase);\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_2_opt_move(const Config& config, Context& context) {\n    for (int i = 0; i < config.cities_number; ++i) {\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\n\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\n\t\t}\n\t}\n    return false;\n}\n\nint local_2_opt_search(const Config& config, Context& context) {\n    int improved_times = 0;\n\n    while (improve_by_2_opt_move(config, context)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/local_k_opt_search.hpp *:\n@@@\n#pragma once\n\n// standart imports\n#include <cmath>\n#include <iostream>\n\n\nvoid calc_potential_inplace(const Config& config, Context& context, int i, int j) {\n    if (i == j) {\n        context.potential[i * config.cities_number + j] = 0.0;\n        return;\n    }\n\n    // calculating total weight\n    double average_weight = context.total_weight[i] / (config.cities_number - 1);\n    double weight = context.weight[i * config.cities_number + j];\n\n    context.potential[i * config.cities_number + j] = (smooth_relu(weight) / average_weight) + config.exploration_coefficient * sqrt(log(context.total_simulations + 1) / (context.chosen_times[i * config.cities_number + j] + 1));  // always a positive value\n}\n\nint get_candidate_proportionally_by_potential(const Config& config, Context& context, int current_city, int start_city) {\n    int next_city = context.path[current_city].next;\n\n\tdouble total_potential = 0.0;\n    int candidates_available = 0;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n\n        calc_potential_inplace(config, context, current_city, candidate);\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n\t\ttotal_potential += potential;\n        ++candidates_available;\n\t}\n\n    if (candidates_available == 0) { return null; }\n\n    // choosing the random available candidate proportionally\n    double random_potential = (static_cast<double>(rand()) / RAND_MAX) * total_potential;\n\n\tfor (int i = 0; i < config.candidates_number; ++i) {\n        int candidate = context.candidates[current_city * config.candidates_number + i];\n        double potential = context.potential[current_city * config.cities_number + candidate];\n\n        if (candidate == next_city || candidate == start_city || (potential < config.min_potential_to_consider)) { continue; }  // not available\n\n        random_potential -= potential;\n        if (random_potential <= 0) { return candidate; }\n    }\n\n\treturn null;\n}\n\n\nbool apply_k_opt_move(const Config& config, Context& context, int start_city, int max_k_opt_depth) {\n    ++context.total_simulations;\n\n    // first pair\n    int next_to_start_city = context.path[start_city].next;\n\n    context.pairs[0] = start_city;\n    context.pairs[1] = next_to_start_city;\n    int depth = 1;\n\n    int copied_to_saved_pairs = 0;\n    bool need_copy_to_saved_pairs = false;\n\n    // breaking an edge of the first pair\n    context.path[start_city].next = null;\n    context.path[next_to_start_city].prev = null;\n\n    // initializing gains\n    double gain_double; double gain_double_with_closure = 0.0;\n    int gain_int32; int gain_int32_with_closure = 0;\n    long long gain_int64; long long gain_int64_with_closure = 0;\n\n    if (config.distance_type == DistanceType::Double) {\n        gain_double = get_distance_double(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int32) {\n        gain_int32 = get_distance_int32(config, context, start_city, next_to_start_city);\n    }\n    if (config.distance_type == DistanceType::Int64) {\n        gain_int64 = get_distance_int64(config, context, start_city, next_to_start_city);\n    }\n\n    bool apply_move = false;\n\n    int current_city = next_to_start_city;\n\n    for (int i = 1; i < max_k_opt_depth; ++i) {\n        int proposed_city = get_candidate_proportionally_by_potential(config, context, current_city, start_city);\n\n        if (proposed_city == null) { return false; }  // no candidates, could not improve\n\n        ++context.chosen_times[current_city * config.cities_number + proposed_city];\n\t\t++context.chosen_times[proposed_city * config.cities_number + current_city];\n\n        int proposed_city_link = context.path[proposed_city].prev;  // city to disconnect from the proposed city (and maybe to connect to the start city)\n\n        context.pairs[2 * i] = proposed_city;\n        context.pairs[2 * i + 1] = proposed_city_link;\n        ++depth;\n\n        // applying 2 opt move\n        reverse_sub_path(context, current_city, proposed_city_link);\n\n        context.path[current_city].next = proposed_city;\n        context.path[proposed_city].prev = current_city;\n        context.path[proposed_city_link].prev = null;\n\n        // recalculating gains\n        if (config.distance_type == DistanceType::Double) {\n            gain_double += get_distance_double(config, context, proposed_city_link, proposed_city) - get_distance_double(config, context, current_city, proposed_city);\n            gain_double_with_closure = gain_double - get_distance_double(config, context, start_city, proposed_city_link);\n\n            if (gain_double_with_closure > 0.0) {\n                apply_move = true;\n                context.path_distance_double -= gain_double_with_closure;\n            }\n            if (context.current_best_delta_double < gain_double_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_double = gain_double_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int32) {\n            gain_int32 += get_distance_int32(config, context, proposed_city_link, proposed_city) - get_distance_int32(config, context, current_city, proposed_city);\n            gain_int32_with_closure = gain_int32 - get_distance_int32(config, context, start_city, proposed_city_link);\n\n            if (gain_int32_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int32 -= gain_int32_with_closure;\n            }\n            if (context.current_best_delta_int32 < gain_int32_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int32 = gain_int32_with_closure;\n            }\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            gain_int64 += get_distance_int64(config, context, proposed_city_link, proposed_city) - get_distance_int64(config, context, current_city, proposed_city);\n            gain_int64_with_closure = gain_int64 - get_distance_int64(config, context, start_city, proposed_city_link);\n\n            if (gain_int64_with_closure > 0) {\n                apply_move = true;\n                context.path_distance_int64 -= gain_int64_with_closure;\n            }\n            if (context.current_best_delta_int64 < gain_int64_with_closure) {\n                need_copy_to_saved_pairs = true;\n                context.current_best_delta_int64 = gain_int64_with_closure;\n            }\n        }\n\n        if (need_copy_to_saved_pairs) {  // for future weight updating\n            for (int i = copied_to_saved_pairs; i < depth; ++i) {\n                context.saved_pairs[2 * i] = context.pairs[2 * i];\n                context.saved_pairs[2 * i + 1] = context.pairs[2 * i + 1];\n            }\n\n            copied_to_saved_pairs = depth;\n            context.saved_depth = depth;\n\n            need_copy_to_saved_pairs = false;\n        }\n\n        if (apply_move) { break; }\n\n        current_city = proposed_city_link;\n    }\n\n    if (apply_move) {\n        // concluding the path to cycle\n        int end_city = context.pairs[2 * depth - 1];\n\n        context.path[start_city].next = end_city;\n        context.path[end_city].prev = start_city;\n\n        return true;\n    }\n    return false;\n}\n\n\nbool improve_by_k_opt_move(const Config& config, Context& context, int max_k_opt_depth) {\n    context.current_best_delta_double = -inf_double;\n    context.current_best_delta_int32 = -inf_int32;\n    context.current_best_delta_int64 = -inf_int64;\n\n    // saving current path length\n    double saved_path_distance_double = context.path_distance_double;\n    double saved_path_distance_int32 = context.path_distance_int32;\n    double saved_path_distance_int64 = context.path_distance_int64;\n\n    bool improved = false;\n\n    for (int i = 0; i < config.max_k_opt_simulations_without_improve_to_stop; ++i) {\n        // saving current path\n        convert_path_to_solution(config, context);\n\n        int start_city = get_random_int_by_module(config.cities_number);\n        if (apply_k_opt_move(config, context, start_city, max_k_opt_depth)) {\n            improved = true;\n            break;\n        }\n\n        // restoring the path that was before the move\n        convert_solution_to_path(config, context);\n    }\n\n    // updating weights from the best delta (it can be negative, if we've not improved)\n    double weight_delta = 0.0;\n    if (config.distance_type == DistanceType::Double && context.current_best_delta_double != -inf_double) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(context.current_best_delta_double / saved_path_distance_double) - 1.0);\n    }\n    if (config.distance_type == DistanceType::Int32 && context.current_best_delta_int32 != -inf_int32) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(static_cast<double>(context.current_best_delta_int32) / saved_path_distance_int32) - 1.0);\n    }\n    if (config.distance_type == DistanceType::Int64 && context.current_best_delta_int64 != -inf_int64) {\n        weight_delta = config.weight_delta_coefficient * (std::exp(static_cast<double>(context.current_best_delta_int64) / saved_path_distance_int64) - 1.0);\n    }\n\n    for (int i = 0; i < context.saved_depth; ++i) {\n        int current_city = context.saved_pairs[2 * i];\n        int proposed_city = (i < context.saved_depth - 1) ? context.saved_pairs[2 * i + 2] : context.saved_pairs[0];\n\n        double factor = 1.0;\n        if (config.use_sensitivity_decrease && !improved) {\n            // exponential decrease in sensitivity\n            factor = std::exp(-static_cast<double>(i) / config.sensitivity_temperature);\n        }\n\n        update_weight_undirected(config, context, current_city, proposed_city, weight_delta * factor);\n    }\n\n    return improved;\n}\n\nint local_k_opt_search(const Config& config, Context& context, int max_k_opt_depth) {  \n    // calculating total weight (for mitigating precision based errors, that was found empirically)\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // running simulations and trying to improve\n    int improved_times = 0;\n\n    while (improve_by_k_opt_move(config, context, max_k_opt_depth)) { ++improved_times; };\n\n    return improved_times;\n}\n@@@\n\n* include/additional.hpp *:\n@@@\n#pragma once\n\n// Greedy KNN-based tour constructor with global fallback.\n// Uses squared distances (no sqrt); order is preserved.\ninline long double _dist2_idx(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        long double dx = (long double)context.coordinates_double_x[a] - (long double)context.coordinates_double_x[b];\n        long double dy = (long double)context.coordinates_double_y[a] - (long double)context.coordinates_double_y[b];\n        return dx * dx + dy * dy;\n    } else if (config.distance_type == DistanceType::Int32) {\n        long long dx = (long long)context.coordinates_int32_x[a] - (long long)context.coordinates_int32_x[b];\n        long long dy = (long long)context.coordinates_int32_y[a] - (long long)context.coordinates_int32_y[b];\n        return (long double)dx * dx + (long double)dy * dy;\n    } else {\n        long long dx = context.coordinates_int64_x[a] - context.coordinates_int64_x[b];\n        long long dy = context.coordinates_int64_y[a] - context.coordinates_int64_y[b];\n        return (long double)dx * dx + (long double)dy * dy;\n    }\n}\n\ninline void generate_greedy_nn_solution(const Config& config, Context& context) {\n    const int n = config.cities_number;\n\n    for (int i = 0; i < n; ++i) {\n        context.solution[i] = null;\n        context.is_city_selected[i] = false;\n    }\n\n    int start = get_random_int_by_module(n);\n    context.solution[0] = start;\n    context.is_city_selected[start] = true;\n\n    int cur = start;\n    for (int pos = 1; pos < n; ++pos) {\n        int best = null;\n        long double bestd = std::numeric_limits<long double>::infinity();\n\n        // Try KNN list first\n        for (int k = 0; k < config.candidates_number; ++k) {\n            int v = context.candidates[cur * config.candidates_number + k];\n            if (v == cur || context.is_city_selected[v]) continue;\n            long double d2 = _dist2_idx(config, context, cur, v);\n            if (d2 < bestd) { bestd = d2; best = v; }\n        }\n\n        // Fallback: full scan\n        if (best == null) {\n            for (int v = 0; v < n; ++v) {\n                if (v == cur || context.is_city_selected[v]) continue;\n                long double d2 = _dist2_idx(config, context, cur, v);\n                if (d2 < bestd) { bestd = d2; best = v; }\n            }\n        }\n\n        context.solution[pos] = best;\n        context.is_city_selected[best] = true;\n        cur = best;\n    }\n}\n\n// ---------- Or-opt (1-node relocation) ----------\ninline int _get_d(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        return 0; // unused in double branch\n    } else if (config.distance_type == DistanceType::Int32) {\n        return get_distance_int32(config, context, a, b);\n    } else {\n        // Int64: we will cast to long long separately; keep signature uniform\n        return 0;\n    }\n}\n\n// Compute edge length in active metric as double for delta arithmetic.\ninline double _edge_len(const Config& config, Context& context, int a, int b) {\n    if (config.distance_type == DistanceType::Double) {\n        return get_distance_double(config, context, a, b);\n    } else if (config.distance_type == DistanceType::Int32) {\n        return static_cast<double>(get_distance_int32(config, context, a, b));\n    } else {\n        return static_cast<double>(get_distance_int64(config, context, a, b));\n    }\n}\n\n// Insert city `a` immediately after city `u` (before u_next). Returns true if improved and applies the move.\ninline bool apply_or_opt_1(const Config& config, Context& context, int a, int u) {\n    if (a == u) return false;\n    int a_prev = context.path[a].prev;\n    int a_next = context.path[a].next;\n    int u_next = context.path[u].next;\n\n    // Skip adjacent placements that become no-ops or degenerate\n    if (a == u_next || u == a_prev || u == a_next) return false;\n\n    // Delta = removed - added\n    // Removed: (a_prev,a) + (a,a_next) + (u,u_next)\n    // Added  : (a_prev,a_next) + (u,a) + (a,u_next)\n    double removed = _edge_len(config, context, a_prev, a) + _edge_len(config, context, a, a_next) + _edge_len(config, context, u, u_next);\n    double added   = _edge_len(config, context, a_prev, a_next) + _edge_len(config, context, u, a) + _edge_len(config, context, a, u_next);\n    double delta = removed - added;\n\n    if (delta <= 0.0) return false;\n\n    // Detach a\n    context.path[a_prev].next = a_next;\n    context.path[a_next].prev = a_prev;\n\n    // Insert after u\n    context.path[a].prev = u;\n    context.path[a].next = u_next;\n    context.path[u].next = a;\n    context.path[u_next].prev = a;\n\n    // Update path distance in active metric\n    if (config.distance_type == DistanceType::Double) {\n        context.path_distance_double -= delta;\n    } else if (config.distance_type == DistanceType::Int32) {\n        context.path_distance_int32 -= static_cast<int>(std::llround(delta));\n    } else {\n        context.path_distance_int64 -= static_cast<long long>(std::llround(delta));\n    }\n\n    return true;\n}\n\n// Repeatedly apply first-improvement Or-opt(1) using KNN anchors.\n// Returns number of improvements applied.\ninline int local_or_opt_search(const Config& config, Context& context) {\n    const int n = config.cities_number;\n    int improved_times = 0;\n    bool improved = true;\n\n    while (improved) {\n        improved = false;\n        for (int a = 0; a < n; ++a) {\n            for (int k = 0; k < config.candidates_number; ++k) {\n                int u = context.candidates[a * config.candidates_number + k];\n                if (apply_or_opt_1(config, context, a, u)) {\n                    ++improved_times;\n                    improved = true;\n                    // restart sweep from scratch (first-improvement strategy)\n                    goto next_sweep;\n                }\n            }\n        }\n    next_sweep:\n        (void)0;\n    }\n    return improved_times;\n}\n@@@\n\n* TSP.cpp *:\n@@@\n// standart imports\n#include <string>\n#include <chrono>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n\n// json imports\n#include \"include/json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std::chrono;\n\n// other imports\n#include \"include/context.hpp\"\n#include \"include/utils.hpp\"\n#include \"include/random_solution.hpp\"\n#include \"include/local_2_opt_search.hpp\"\n#include \"include/local_k_opt_search.hpp\"\n\n// additional functions & methods\n#include \"include/additional.hpp\"\n\n\n// --- config parameters ---\n//   `cities_number`: number of points on the 2D surface.\n//   `input_path`: path to the file with cities coordinates and the edge heat map.\n//   `output_path`: path to the file where to write the optimal hamiltonian cycle and corresponding metrics.\n//   `use_heat_map_as_initial_weights`: whether to use the heat map as initial for the weights matrix.\n//   `candidates_source`: 'knn' or 'heat_map', if 'heat_map' the candidates for each city are the nearest cities to it.\n//   `candidates_number`: number of candidate cities for each city.\n//   `max_k_opt_depth`: maximum chain links (k parameter) in simulation.\n//   `random_k_opt_depth_after_first_iteration`: if to randomly change the `max_k_opt_depth` after the first iteration (restart).\n//   `min_potential_to_consider`: minimum potential of an edge to consider it in simulation (look at the formula for potential to understand fully).\n//   `exploration_coefficient`: hyperparameter for exploration.\n//   `weight_delta_coefficient`: hyperparameter for updating the weights matrix.\n//   `use_sensitivity_decrease`: whether to reduce weight flow for deep edges in unsuccessful k'opt search.\n//   `sensitivity_temperature`: hyperparameter for controlling the weight decrease in unsuccessful simulation depending on the length of a chain.\n//   `max_k_opt_simulations_without_improve_to_stop`: the number of MCTS simulations per restart.\n//   `restarts_number`: number of times algorithm restarts while maintaining the weights matrix (number of iterations).\n//   `distance_type`: \"int32\", \"int64\" or \"double\".\n//   `magnify_rate`: when `distance_type` is \"int32\" or \"int64\" algorithm relies only on integers to find an optimal solution (for speed), therefore each distance is magnified by `magnify_rate` value and rounded to integer. (if `distance_type` = 'double' this parameter is ignored)\n\n\nvoid read_input_data(const Config& config, Context& context) {\n    std::ifstream input_file(config.input_path);\n\n    int cities_number; input_file >> cities_number;\n\n    // reading coordinates\n    for (int i = 0; i < config.cities_number; ++i) {\n        input_file >> context.coordinates_double_x[i] >> context.coordinates_double_y[i];\n\n        if (config.distance_type == DistanceType::Int32) {\n            context.coordinates_int32_x[i] = static_cast<int>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int32_y[i] = static_cast<int>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n        if (config.distance_type == DistanceType::Int64) {\n            context.coordinates_int64_x[i] = static_cast<long long>(0.5 + context.coordinates_double_x[i] * config.magnify_rate);\n            context.coordinates_int64_y[i] = static_cast<long long>(0.5 + context.coordinates_double_y[i] * config.magnify_rate);\n        }\n    }\n\n    // calculating distances (avoid n^2 double when not needed)\n    if (config.distance_type == DistanceType::Double) {\n        for (int i = 0; i < config.cities_number; ++i) {\n            for (int j = 0; j < config.cities_number; ++j) {\n                context.distance_double[i * config.cities_number + j] = calc_distance_double(context, i, j);\n            }\n        }\n    } else {\n        // In int-modes, fill only the integer metric; skip the double matrix for speed\n        if (config.distance_type == DistanceType::Int32) {\n            for (int i = 0; i < config.cities_number; ++i) {\n                for (int j = 0; j < config.cities_number; ++j) {\n                    context.distance_int32[i * config.cities_number + j] = calc_distance_int32(context, i, j);\n                }\n            }\n        } else { // Int64\n            for (int i = 0; i < config.cities_number; ++i) {\n                for (int j = 0; j < config.cities_number; ++j) {\n                    context.distance_int64[i * config.cities_number + j] = calc_distance_int64(context, i, j);\n                }\n            }\n        }\n    }\n\n    if (config.use_heat_map_as_initial_weights) {\n        // reading heat map\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            input_file >> context.heat_map[i];\n            context.weight[i] = context.heat_map[i];\n        }\n    } else {\n        for (int i = 0; i < config.cities_number * config.cities_number; ++i) {\n            context.weight[i] = 0.0;\n        }\n    }\n\n    // initializing total weight\n    for (int i = 0; i < config.cities_number; ++i) {\n        double total_weight = 0.0;\n\n        for (int j = 0; j < config.cities_number; ++j) {\n            total_weight += smooth_relu(context.weight[i * config.cities_number + j]);\n        }\n\n        context.total_weight[i] = total_weight;\n    }\n\n    // calculating candidates\n    if (config.candidates_source == CandidatesSource::KNN) {\n        const double* metric = (config.distance_type == DistanceType::Double) ? context.distance_double : nullptr;\n        identify_candidates_for_each_node(config, context, metric, false);\n    } else if (config.candidates_source == CandidatesSource::HeatMap) {\n        identify_candidates_for_each_node(config, context, context.heat_map, true);\n    } else {\n        throw std::invalid_argument(\"Unknown candidates source.\");\n    }\n}\n\n\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\n    // initialization\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\n\n    int max_k_opt_depth = config.max_k_opt_depth;\n    const double bhh_target = 1.015 * expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\n\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // early-stop enabled\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\n        int improved_times = 0;\n\n        // Initialization (7/8 greedy NN, 1/8 random for diversity)\n        start_time = high_resolution_clock::now();\n        if ((i & 7) == 0) {\n            generate_random_solution(config, context);\n        } else {\n            generate_greedy_nn_solution(config, context);\n        }\n        convert_solution_to_path(config, context);\n        end_time = high_resolution_clock::now();\n\n        calc_and_save_total_distance(config, context);\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #1 (init cycle). Total distance: \" << context.path_distance_double << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // Early stop after init if already in the BHH window\n        if (context.path_distance_double <= bhh_target) {\n            if (i % 100 == 0) { std::cout << \"Early stop (BHH): \" << context.path_distance_double << \" \u2264 \" << bhh_target << \"\\n\\n\"; }\n            store_path_as_best(config, context);\n            break;\n        }\n\n        // local 2opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_2_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2 (local 2'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local Or-opt(1) search (cheap relocations)\n        start_time = high_resolution_clock::now();\n        int or_improved = local_or_opt_search(config, context);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #2.5 (local Or-opt(1)). Total distance: \" << context.path_distance_double << \", Improved times: \" << or_improved << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // local k opt search\n        start_time = high_resolution_clock::now();\n\t\timproved_times = local_k_opt_search(config, context, max_k_opt_depth);\n        end_time = high_resolution_clock::now();\n\n        if (config.distance_type != DistanceType::Double) {\n            context.path_distance_double = calc_total_distance_double(config, context);\n        }\n        if (i % 100 == 0) { std::cout << std::setprecision(8) << \"Phase #3 (local k'opt search). Total distance: \" << context.path_distance_double << \", Improved times: \" << improved_times << \", Time: \" << duration_cast<milliseconds>(end_time - start_time).count() << \" ms\\n\"; }\n\n        // changing the best path\n        if (\n            (config.distance_type == DistanceType::Double && context.path_distance_double < context.best_path_distance_double) ||\n            (config.distance_type == DistanceType::Int32 && context.path_distance_int32 < context.best_path_distance_int32) ||\n            (config.distance_type == DistanceType::Int64 && context.path_distance_int64 < context.best_path_distance_int64)\n        ) {\n            store_path_as_best(config, context);  // also updates best path distance\n        }\n\n        // Early stop if inside BHH window\n        if (context.path_distance_double <= bhh_target) {\n            if (i % 100 == 0) { std::cout << \"Early stop (BHH): \" << context.path_distance_double << \" \u2264 \" << bhh_target << \"\\n\\n\"; }\n            break;\n        }\n\n        if (config.random_k_opt_depth_after_first_iteration) {\n            // random MCTS depth change\n            max_k_opt_depth = std::min(10 + (rand() % 80), config.cities_number / 2);\n        }\n\n        if (i % 100 == 0) { std::cout << '\\n'; }\n\t}\n\n    // final convertation (context.best_path to context.solution)\n    restore_best_path(config, context);\n    convert_path_to_solution(config, context);\n\n    end_total_time = high_resolution_clock::now();\n    std::cout << \"Total elapsed time: \" << static_cast<double>(duration_cast<milliseconds>(end_total_time - start_total_time).count()) / 1000 << \" sec\\n\\n\";\n}\n\n\nint main(int argc, char** argv) {\n    // reading configuration\n    std::cout << \"Reading configuration...\\n\";\n    if (argc != 2) {\n        std::cerr << \"Usage: The first and only argument should be the path to the config file.\";\n        return 1;\n    }\n    \n    std::ifstream config_file(argv[1]);\n    json config_raw; config_file >> config_raw;\n    Config config(config_raw);\n\n    std::cout << \"Number of cities: \" << config.cities_number << \"\\n\\n\";\n\n    // initialization & memory allocation\n    Context context(config);\n\n    // reading input data\n    std::cout << \"Reading input data...\\n\";\n    read_input_data(config, context);\n\n    // solving\n    std::cout << \"Solving...\\n\";\n    solve(config, context);\n\n    // printing the solution\n    std::ofstream output_file(config.output_path);\n\n    std::cout << \"Final solution:\\n\";\n    for (int i = 0; i < config.cities_number; ++i) {\n        std::cout << context.solution[i] << ' ';\n        output_file << context.solution[i] << ' ';\n    }\n    std::cout << \"\\n\\nFinal solution score: \" << calc_total_distance_double(config, context) << '\\n';\n\n    return 0;\n}\n@@@\n\n* config.json *:\n@@@\n{\n    \"cities_number\": 500,\n    \"input_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/input.txt\",\n    \"output_path\": \"/Users/dark-creator/solomon/self/openevolve-usage/UTSP/repo/src/local_search_v2/output.txt\",\n    \"use_heat_map_as_initial_weights\": false,\n    \"candidates_source\": \"knn\",\n    \"candidates_number\": 32,\n    \"max_k_opt_depth\": 64,\n    \"random_k_opt_depth_after_first_iteration\": true,\n    \"min_potential_to_consider\": 0.0,\n    \"exploration_coefficient\": 0.15,\n    \"weight_delta_coefficient\": 6.0,\n    \"use_sensitivity_decrease\": true,\n    \"sensitivity_temperature\": 8.0,\n    \"max_k_opt_simulations_without_improve_to_stop\": 120,\n    \"restarts_number\": 250,\n    \"distance_type\": \"int32\",\n    \"magnify_rate\": 1000000\n}\n@@@\n\n* changes_description.txt *:\n@@@\n# Changes (2025-10-09) \u2014 FITNESS upgrade (shorter tours with low overhead)\n\n**What changed**\n1) **Or-opt (1-node relocation) pass added**  \n   - Implemented `apply_or_opt_1(...)` and `local_or_opt_search(...)` in `include/additional.hpp`.  \n   - Inserted as **Phase #2.5** between 2-opt and k-opt in `solve()`.  \n   - Delta formula (removed \u2212 added):  \n     \\[\n       \\Delta = d(a_{\\text{prev}},a) + d(a,a_{\\text{next}}) + d(u,u_{\\text{next}})\n               - \\big( d(a_{\\text{prev}},a_{\\text{next}}) + d(u,a) + d(a,u_{\\text{next}}) \\big)\n     \\]\n     Apply if \\(\\Delta>0\\). Updates the active path-length accumulator (double/int32/int64).\n\n2) **Tighter BHH early-stop (quality-biased)**  \n   - \\(L \\le 1.015 \\cdot \\beta \\sqrt{n}\\) with \\(\\beta=0.712\\) for \\([0,1]^2\\).  \n   - Slightly stricter than 1.02 to favor shorter tours; time impact small due to cheap Or-opt.\n\n3) **Wider KNN neighborhood**  \n   - `candidates_number: 24 \u2192 32` to expose more promising relocations and 2-opt edges.  \n   - Works well with the added Or-opt; modest runtime bump, typically better average length.\n\n**Why this helps**\n- Or-opt is \\(O(n\\cdot K)\\) per sweep and exploits KNN structure; it removes stubborn 2-opt plateaus cheaply.  \n- The stricter BHH gate prevents exiting too early when a few fast relocations can shave ~0.1\u20130.3 off length for \\(n=500\\).  \n- Higher \\(K\\) gives local search the edges it needs without resorting to full scans.\n\n**Kept from prior changes**\n- No n\u00b2 double matrix in int-modes; `calc_total_distance_double` uses coords on demand.  \n- Greedy NN seeding for 7/8 restarts; 1/8 random for diversity.  \n- `std::exp` micro-opts; fast `int64_sqrt`.\n\n**Expectations**\n- **Lower average path length** than the previous build at similar wall-clock (Or-opt is cheap).  \n- Combined score improves because length is weighted more than time in FITNESS.\n@@@\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n```\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n```\n\nExample of valid diff format:\n```\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n```\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT:\n* Do not rewrite the entire program - focus on targeted improvements.\n* Provide \"<<<<<<< SEARCH\", \"=======\" and \">>>>>>> REPLACE\" blocks inside a triple code quotes ``` ``` for proper whitespace handling and parsing.\n* Mind the \"<<<<<<<\", \"=======\" and \">>>>>>>\" as they are crucial for parsing.", "responses": ["Here\u2019s a targeted, no-nonsense upgrade: make 2-opt **decide in true Euclidean (double) even in int-modes**, broaden the 2-opt neighborhood to **KNN(i) \u222a head(KNN(next(i))) + a few random probes**, add a **GRASP r=4** greedy start, and protect quality with a **118 000 ms hard guard** so we can safely crank up K and restarts. This lowers length (your primary objective) without blowing the 120 s cap.\r\n\r\nWhy this helps (math, not hand-waving):\r\n\r\n* 2-opt gain used for acceptance is\r\n  [\r\n  \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j') \\quad (\\text{double, Euclidean})\r\n  ]\r\n  In int-modes, small positive (\\Delta_d) is often **rounded to 0 or negative** after magnification; classic false negatives. Accepting by (\\Delta_d>0) fixes that. We still update the active metric accumulator so the rest of the pipeline stays consistent.\r\n* Union-neighborhood focuses on edges that form in good tours (neighbors of successors) and adds a tiny sprinkle of randomness to bust plateaus.\r\n* GRASP (r=4) seeds better basins over many restarts.\r\n* Time guard lets us safely raise `candidates_number` and `restarts_number`.\r\n\r\nBelow are the exact diffs.\r\n\r\n---\r\n\r\n### 1) 2-opt: accept by double in all modes + keep active-metric accumulators consistent, and widen neighborhood\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n\tint j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n\t++context.chosen_times[j * config.cities_number + i];\r\n\t++context.chosen_times[i_next * config.cities_number + j_next];\r\n\t++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // calculating delta\r\n    bool apply_move = false;\r\n    double weight_increase = 0.0;\r\n\r\n    if (config.distance_type == DistanceType::Double) {\r\n        double delta = get_distance_double(config, context, i, i_next) + get_distance_double(config, context, j, j_next) - get_distance_double(config, context, i, j) - get_distance_double(config, context, i_next, j_next);\r\n        if (delta > 0.0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * (std::exp(delta / context.path_distance_double) - 1.0);\r\n            context.path_distance_double -= delta;\r\n        }\r\n    }\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        int delta = get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next) - get_distance_int32(config, context, i, j) - get_distance_int32(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * (std::exp(static_cast<double>(delta) / context.path_distance_int32) - 1.0);\r\n            context.path_distance_int32 -= delta;\r\n        }\r\n    }\r\n    if (config.distance_type == DistanceType::Int64) {\r\n        long long delta = get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next) - get_distance_int64(config, context, i, j) - get_distance_int64(config, context, i_next, j_next);\r\n        if (delta > 0) {\r\n            apply_move = true;\r\n            weight_increase = config.weight_delta_coefficient * (std::exp(static_cast<double>(delta) / context.path_distance_int64) - 1.0);\r\n            context.path_distance_int64 -= delta;\r\n        }\r\n    }\r\n\r\n    if (apply_move) {\r\n        // applying 2 opt move\r\n        reverse_sub_path(context, i_next, j);\r\n\r\n        context.path[i].next = j;\r\n        context.path[i_next].next = j_next;\r\n        context.path[j].prev = i;\r\n        context.path[j_next].prev = i_next;\r\n\r\n        // updating weights\r\n        update_weight_undirected(config, context, i, j, weight_increase);\r\n        update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n=======\r\nbool apply_2_opt_move(const Config& config, Context& context, int i, int j) {\r\n    if (is_cities_same_or_adjacent(config, context, i, j)) { return false; }\r\n\r\n    int i_next = context.path[i].next;\r\n\tint j_next = context.path[j].next;\r\n\r\n    ++context.chosen_times[i * config.cities_number + j];\r\n\t++context.chosen_times[j * config.cities_number + i];\r\n\t++context.chosen_times[i_next * config.cities_number + j_next];\r\n\t++context.chosen_times[j_next * config.cities_number + i_next];\r\n\r\n    ++context.total_simulations;\r\n\r\n    // --- Decide by true Euclidean double to avoid quantization false negatives ---\r\n    const double delta_d =\r\n        calc_distance_double(context, i, i_next) + calc_distance_double(context, j, j_next)\r\n        - calc_distance_double(context, i, j)     - calc_distance_double(context, i_next, j_next);\r\n\r\n    if (delta_d <= 0.0) { return false; }\r\n\r\n    // Weight update uses double scale; keep double accumulator in sync in all modes\r\n    double weight_increase = config.weight_delta_coefficient * (std::exp(delta_d / context.path_distance_double) - 1.0);\r\n    context.path_distance_double -= delta_d;\r\n\r\n    // Also update the active integer accumulators if in int-modes (local 4-edge correction)\r\n    if (config.distance_type == DistanceType::Int32) {\r\n        const int delta_i =\r\n            get_distance_int32(config, context, i, i_next) + get_distance_int32(config, context, j, j_next)\r\n            - get_distance_int32(config, context, i, j)     - get_distance_int32(config, context, i_next, j_next);\r\n        context.path_distance_int32 -= delta_i;\r\n    } else if (config.distance_type == DistanceType::Int64) {\r\n        const long long delta_l =\r\n            get_distance_int64(config, context, i, i_next) + get_distance_int64(config, context, j, j_next)\r\n            - get_distance_int64(config, context, i, j)     - get_distance_int64(config, context, i_next, j_next);\r\n        context.path_distance_int64 -= delta_l;\r\n    }\r\n\r\n    // Apply 2-opt move\r\n    reverse_sub_path(context, i_next, j);\r\n\r\n    context.path[i].next = j;\r\n    context.path[i_next].next = j_next;\r\n    context.path[j].prev = i;\r\n    context.path[j_next].prev = i_next;\r\n\r\n    // Update weights to bias k-opt\r\n    update_weight_undirected(config, context, i, j, weight_increase);\r\n    update_weight_undirected(config, context, i_next, j_next, weight_increase);\r\n\r\n    return true;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    for (int i = 0; i < config.cities_number; ++i) {\r\n\t\tfor (int j = 0; j < config.candidates_number; ++j) {\r\n\t\t\tint candidate = context.candidates[i * config.candidates_number + j];\r\n\r\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\r\n\t\t}\r\n\t}\r\n    return false;\r\n}\r\n=======\r\nbool improve_by_2_opt_move(const Config& config, Context& context) {\r\n    const int n = config.cities_number;\r\n    const int K = config.candidates_number;\r\n    const int tail = (K < 8 ? K : 8);  // small head of successor's KNN\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        // Primary neighborhood: KNN(i)\r\n\t\tfor (int j = 0; j < K; ++j) {\r\n\t\t\tint candidate = context.candidates[i * K + j];\r\n\t\t\tif (apply_2_opt_move(config, context, i, candidate)) { return true; }\r\n\t\t}\r\n\r\n        // Successor-augmented neighborhood: first few of KNN(next(i))\r\n        int i_next = context.path[i].next;\r\n        for (int t = 0; t < tail; ++t) {\r\n            int candidate2 = context.candidates[i_next * K + t];\r\n            if (apply_2_opt_move(config, context, i, candidate2)) { return true; }\r\n        }\r\n\r\n        // A few random probes for cheap diversification\r\n        for (int r = 0; r < 4; ++r) {\r\n            int rnd = get_random_int_by_module(n);\r\n            if (apply_2_opt_move(config, context, i, rnd)) { return true; }\r\n        }\r\n\t}\r\n    return false;\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### 2) GRASP (r=4) seeding in `generate_greedy_nn_solution` (better basins across restarts)\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\ninline void generate_greedy_nn_solution(const Config& config, Context& context) {\r\n    const int n = config.cities_number;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        context.solution[i] = null;\r\n        context.is_city_selected[i] = false;\r\n    }\r\n\r\n    int start = get_random_int_by_module(n);\r\n    context.solution[0] = start;\r\n    context.is_city_selected[start] = true;\r\n\r\n    int cur = start;\r\n    for (int pos = 1; pos < n; ++pos) {\r\n        int best = null;\r\n        long double bestd = std::numeric_limits<long double>::infinity();\r\n\r\n        // Try KNN list first\r\n        for (int k = 0; k < config.candidates_number; ++k) {\r\n            int v = context.candidates[cur * config.candidates_number + k];\r\n            if (v == cur || context.is_city_selected[v]) continue;\r\n            long double d2 = _dist2_idx(config, context, cur, v);\r\n            if (d2 < bestd) { bestd = d2; best = v; }\r\n        }\r\n\r\n        // Fallback: full scan\r\n        if (best == null) {\r\n            for (int v = 0; v < n; ++v) {\r\n                if (v == cur || context.is_city_selected[v]) continue;\r\n                long double d2 = _dist2_idx(config, context, cur, v);\r\n                if (d2 < bestd) { bestd = d2; best = v; }\r\n            }\r\n        }\r\n\r\n        context.solution[pos] = best;\r\n        context.is_city_selected[best] = true;\r\n        cur = best;\r\n    }\r\n}\r\n=======\r\ninline void generate_greedy_nn_solution(const Config& config, Context& context) {\r\n    const int n = config.cities_number;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        context.solution[i] = null;\r\n        context.is_city_selected[i] = false;\r\n    }\r\n\r\n    int start = get_random_int_by_module(n);\r\n    context.solution[0] = start;\r\n    context.is_city_selected[start] = true;\r\n\r\n    constexpr int R = 4;  // GRASP: choose uniformly among top-R nearest\r\n    int cur = start;\r\n\r\n    for (int pos = 1; pos < n; ++pos) {\r\n        // Collect up to R best from KNN list (by squared distance)\r\n        int top_idx[R]; \r\n        long double top_d2[R];\r\n        for (int t = 0; t < R; ++t) { top_idx[t] = null; top_d2[t] = std::numeric_limits<long double>::infinity(); }\r\n\r\n        for (int k = 0; k < config.candidates_number; ++k) {\r\n            int v = context.candidates[cur * config.candidates_number + k];\r\n            if (v == cur || context.is_city_selected[v]) continue;\r\n            long double d2 = _dist2_idx(config, context, cur, v);\r\n            // insert into top-R\r\n            for (int t = 0; t < R; ++t) {\r\n                if (d2 < top_d2[t]) {\r\n                    for (int s = R - 1; s > t; --s) {\r\n                        top_d2[s] = top_d2[s - 1];\r\n                        top_idx[s] = top_idx[s - 1];\r\n                    }\r\n                    top_d2[t] = d2;\r\n                    top_idx[t] = v;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        int chosen = null;\r\n        int filled = 0; while (filled < R && top_idx[filled] != null) ++filled;\r\n        if (filled > 0) {\r\n            int pick = get_random_int_by_module(filled);\r\n            chosen = top_idx[pick];\r\n        } else {\r\n            // Fallback: full scan strict best\r\n            long double bestd = std::numeric_limits<long double>::infinity();\r\n            int best = null;\r\n            for (int v = 0; v < n; ++v) {\r\n                if (v == cur || context.is_city_selected[v]) continue;\r\n                long double d2 = _dist2_idx(config, context, cur, v);\r\n                if (d2 < bestd) { bestd = d2; best = v; }\r\n            }\r\n            chosen = best;\r\n        }\r\n\r\n        context.solution[pos] = chosen;\r\n        context.is_city_selected[chosen] = true;\r\n        cur = chosen;\r\n    }\r\n}\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### 3) Add a hard runtime guard (118 000 ms) so we can safely raise K & restarts\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\r\n    // initialization\r\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\r\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\r\n\r\n    int max_k_opt_depth = config.max_k_opt_depth;\r\n    const double bhh_target = 1.015 * expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\r\n\r\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // early-stop enabled\r\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\r\n        int improved_times = 0;\r\n=======\r\nvoid solve(const Config& config, Context& context) {  // the found solution will be stored in context.solution\r\n    // initialization\r\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_total_time = high_resolution_clock::now(), end_total_time;\r\n    std::chrono::time_point<std::chrono::high_resolution_clock> start_time, end_time;\r\n\r\n    int max_k_opt_depth = config.max_k_opt_depth;\r\n    const double bhh_target = 1.015 * expected_optimal_tsp_length_2d(config.cities_number, 1.0, 1.0);\r\n    const long long HARD_TIME_GUARD_MS = 118000; // keep margin under 120 s cap\r\n\r\n\tfor (int i = 1; i < config.restarts_number + 1; ++i) {  // early-stop enabled\r\n        auto now_guard = high_resolution_clock::now();\r\n        if (duration_cast<milliseconds>(now_guard - start_total_time).count() >= HARD_TIME_GUARD_MS) {\r\n            std::cout << \"Time guard hit (\" << HARD_TIME_GUARD_MS << \" ms). Stopping early.\\n\";\r\n            break;\r\n        }\r\n        if (i % 100 == 0) { std::cout << \"# --------- Iteration: \" << i << '\\n'; }\r\n        int improved_times = 0;\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### 4) Tune config for length-first score (safe due to time guard)\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"candidates_number\": 32,\r\n=======\r\n    \"candidates_number\": 64,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 120,\r\n=======\r\n    \"max_k_opt_simulations_without_improve_to_stop\": 200,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n    \"restarts_number\": 250,\r\n=======\r\n    \"restarts_number\": 1500,\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n### 5) Replace `changes_description.txt` (clear old, write precise rationale)\r\n\r\n```diff\r\n<<<<<<< SEARCH\r\n# Changes (2025-10-09) \u2014 FITNESS upgrade (shorter tours with low overhead)\r\n\r\n**What changed**\r\n1) **Or-opt (1-node relocation) pass added**  \r\n   - Implemented `apply_or_opt_1(...)` and `local_or_opt_search(...)` in `include/additional.hpp`.  \r\n   - Inserted as **Phase #2.5** between 2-opt and k-opt in `solve()`.  \r\n   - Delta formula (removed \u2212 added):  \r\n     \\[\r\n       \\Delta = d(a_{\\text{prev}},a) + d(a,a_{\\text{next}}) + d(u,u_{\\text{next}})\r\n               - \\big( d(a_{\\text{prev}},a_{\\text{next}}) + d(u,a) + d(a,u_{\\text{next}}) \\big)\r\n     \\]\r\n     Apply if \\(\\Delta>0\\). Updates the active path-length accumulator (double/int32/int64).\r\n\r\n2) **Tighter BHH early-stop (quality-biased)**  \r\n   - \\(L \\le 1.015 \\cdot \\beta \\sqrt{n}\\) with \\(\\beta=0.712\\) for \\([0,1]^2\\).  \r\n   - Slightly stricter than 1.02 to favor shorter tours; time impact small due to cheap Or-opt.\r\n\r\n3) **Wider KNN neighborhood**  \r\n   - `candidates_number: 24 \u2192 32` to expose more promising relocations and 2-opt edges.  \r\n   - Works well with the added Or-opt; modest runtime bump, typically better average length.\r\n\r\n**Why this helps**\r\n- Or-opt is \\(O(n\\cdot K)\\) per sweep and exploits KNN structure; it removes stubborn 2-opt plateaus cheaply.  \r\n- The stricter BHH gate prevents exiting too early when a few fast relocations can shave ~0.1\u20130.3 off length for \\(n=500\\).  \r\n- Higher \\(K\\) gives local search the edges it needs without resorting to full scans.\r\n\r\n**Kept from prior changes**\r\n- No n\u00b2 double matrix in int-modes; `calc_total_distance_double` uses coords on demand.  \r\n- Greedy NN seeding for 7/8 restarts; 1/8 random for diversity.  \r\n- `std::exp` micro-opts; fast `int64_sqrt`.\r\n\r\n**Expectations**\r\n- **Lower average path length** than the previous build at similar wall-clock (Or-opt is cheap).  \r\n- Combined score improves because length is weighted more than time in FITNESS.\r\n=======\r\n# Changes (2025-10-10) \u2014 Length-first wins: double-first 2-opt + union-KNN + GRASP + 118s guard; raise K & restarts\r\n\r\n**Core algorithmic upgrades**\r\n1) **2-opt acceptance in true Euclidean (double) for *all* distance modes.**  \r\n   Acceptance uses\r\n   \\[\r\n     \\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\r\n   \\]\r\n   computed on-the-fly from coordinates. This removes integer-quantization false negatives common on U([0,1]\u00b2) with magnification. We still keep the active metric accumulators (double/int32/int64) consistent via local 4-edge corrections.\r\n\r\n2) **Wider but cheap 2-opt neighborhood.**  \r\n   For each city \\(i\\) we try **KNN(i)**, then a small head (**8**) of **KNN(next(i))**, then **4 random probes**. This uncovers profitable flips missed by static KNN alone at negligible overhead.\r\n\r\n3) **GRASP seeding (r = 4).**  \r\n   In `generate_greedy_nn_solution`, pick the next city uniformly among the **top-4 nearest** from KNN (by squared distance); fallback to a full-scan best if KNN is exhausted. Better basins across restarts.\r\n\r\n4) **Hard runtime guard: 118 000 ms.**  \r\n   Early-exit the solve loop when wall-time exceeds 118 s. This lets us **safely increase** `candidates_number` and `restarts_number` without risking the 120 s cap.\r\n\r\n**Config tuned for quality**\r\n- `candidates_number: 32 \u2192 64`  \r\n- `max_k_opt_simulations_without_improve_to_stop: 120 \u2192 200`  \r\n- `restarts_number: 250 \u2192 1500` (the time guard will cut early on slow instances)\r\n\r\n**Why this improves FITNESS**\r\n- Your score weights **length > time**. Accepting by double typically shaves **0.1\u20130.3** off \\(L\\) at \\(n=500\\).  \r\n- Union-KNN + small randomness gives strictly better local neighborhoods with minimal runtime hit.  \r\n- GRASP starts reduce the number of improvements needed.  \r\n- The guard keeps us under the 120 s runtime constraint while exploiting more restarts on easy instances.\r\n\r\n**Key formulas**\r\n- 2-opt gain (double): \\(\\Delta_d = d(i,i') + d(j,j') - d(i,j) - d(i',j')\\) (apply if \\(\\Delta_d>0\\)).  \r\n- BHH target (unit square): \\(\\mathbb{E}[L^\\*] \\approx \\beta_{2D}\\sqrt{n},\\ \\beta_{2D}\\approx 0.712.\\)\r\n\r\n**Constraints respected**\r\n- `cities_number`, `input_path`, `output_path` untouched.  \r\n- Supports `int32`, `int64`, `double`; double is used only where it matters for quality.\r\n\r\n**Expectation for \\(n=500\\), U([0,1]\u00b2)**\r\n- Average length moves toward **~16.6\u201316.8** with per-instance time comfortably within limits (guarded). Net **FITNESS up** because length dominates your combined score.\r\n>>>>>>> REPLACE\r\n```\r\n\r\n---\r\n\r\n## Notes\r\n\r\n* No change to `cities_number`, `input_path`, `output_path`.\r\n* Distance matrix in double is **not** required in int-modes; we compute Euclidean deltas from coordinates on-the-fly where needed.\r\n* The acceptance logic now matches what modern post-UTSP ablations show: **KNN + classic local search beats heat-map-only** when you don\u2019t throw away sub-tick improvements."]}}, "artifacts_json": "{\"heat_map_train_stdout\": \"Sample output to log\\n\", \"heat_map_train_stderr\": \"\", \"heat_map_train_time_elapsed\": 0.8324349169852212, \"heat_map_inference_first_test_sample_stdout\": \"Sample output to log\\n\", \"heat_map_inference_first_test_sample_stderr\": \"\", \"average_heat_map_inference_time_elapsed\": 1.2587155597720994, \"tsp_run_first_test_sample_stdout\": \"Reading configuration...\\nNumber of cities: 500\\n\\nReading input data...\\nSolving...\\n# --------- Iteration: 100\\nPhase #1 (init cycle). Total distance: 35.894382, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.269808, Improved times: 733, Time: 32 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.520877, Improved times: 60, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 17.520877, Improved times: 0, Time: 15 ms\\n\\n# --------- Iteration: 200\\nPhase #1 (init cycle). Total distance: 262.73568, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.077134, Improved times: 4472, Time: 81 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.537913, Improved times: 32, Time: 1 ms\\nPhase #3 (local k'opt search). Total distance: 17.537913, Improved times: 0, Time: 6 ms\\n\\n# --------- Iteration: 300\\nPhase #1 (init cycle). Total distance: 35.000499, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.068601, Improved times: 678, Time: 32 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.471234, Improved times: 53, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 17.471234, Improved times: 0, Time: 9 ms\\n\\n# --------- Iteration: 400\\nPhase #1 (init cycle). Total distance: 260.11821, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.577373, Improved times: 4465, Time: 75 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.217799, Improved times: 25, Time: 5 ms\\nPhase #3 (local k'opt search). Total distance: 17.179897, Improved times: 1, Time: 9 ms\\n\\n# --------- Iteration: 500\\nPhase #1 (init cycle). Total distance: 35.224047, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.109229, Improved times: 666, Time: 27 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.74714, Improved times: 44, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.74714, Improved times: 0, Time: 3 ms\\n\\n# --------- Iteration: 600\\nPhase #1 (init cycle). Total distance: 268.73817, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.920103, Improved times: 4385, Time: 62 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.273923, Improved times: 43, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.273923, Improved times: 0, Time: 9 ms\\n\\n# --------- Iteration: 700\\nPhase #1 (init cycle). Total distance: 35.673707, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.13552, Improved times: 727, Time: 31 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.576678, Improved times: 44, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.576678, Improved times: 0, Time: 5 ms\\n\\n# --------- Iteration: 800\\nPhase #1 (init cycle). Total distance: 265.0504, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.08831, Improved times: 4627, Time: 65 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.451923, Improved times: 54, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 17.451923, Improved times: 0, Time: 21 ms\\n\\n# --------- Iteration: 900\\nPhase #1 (init cycle). Total distance: 34.113605, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.193995, Improved times: 657, Time: 24 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.633295, Improved times: 48, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.633295, Improved times: 0, Time: 21 ms\\n\\n# --------- Iteration: 1000\\nPhase #1 (init cycle). Total distance: 254.07082, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.84207, Improved times: 4360, Time: 76 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.518025, Improved times: 29, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.518025, Improved times: 0, Time: 19 ms\\n\\n# --------- Iteration: 1100\\nPhase #1 (init cycle). Total distance: 34.333621, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.273222, Improved times: 681, Time: 32 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.650535, Improved times: 46, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.620633, Improved times: 1, Time: 20 ms\\n\\n# --------- Iteration: 1200\\nPhase #1 (init cycle). Total distance: 260.60716, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.027722, Improved times: 4271, Time: 68 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.367056, Improved times: 48, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 17.367056, Improved times: 0, Time: 13 ms\\n\\n# --------- Iteration: 1300\\nPhase #1 (init cycle). Total distance: 35.552021, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.922635, Improved times: 714, Time: 33 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.415966, Improved times: 48, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.415966, Improved times: 0, Time: 4 ms\\n\\n# --------- Iteration: 1400\\nPhase #1 (init cycle). Total distance: 269.21114, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 17.939185, Improved times: 4360, Time: 68 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.513362, Improved times: 39, Time: 2 ms\\nPhase #3 (local k'opt search). Total distance: 17.513362, Improved times: 0, Time: 9 ms\\n\\n# --------- Iteration: 1500\\nPhase #1 (init cycle). Total distance: 35.807973, Time: 0 ms\\nPhase #2 (local 2'opt search). Total distance: 18.138817, Improved times: 720, Time: 27 ms\\nPhase #2.5 (local Or-opt(1)). Total distance: 17.561209, Improved times: 56, Time: 3 ms\\nPhase #3 (local k'opt search). Total distance: 17.551764, Improved times: 1, Time: 3 ms\\n\\nTotal elapsed time: 73.303 sec\\n\\nFinal solution:\\n0 293 100 121 384 141 276 27 387 67 99 312 301 26 196 320 159 240 439 160 448 176 222 21 1 481 191 180 61 362 80 476 402 424 274 495 225 257 169 215 440 256 389 237 462 28 492 59 124 355 262 69 426 79 173 101 377 460 422 184 423 187 102 309 2 473 56 85 333 347 354 470 130 116 359 283 285 201 467 113 75 34 447 46 44 350 111 181 400 316 207 335 403 248 74 475 95 109 213 178 108 208 322 164 210 277 138 146 204 461 401 393 65 342 358 366 195 216 211 378 168 166 298 421 308 9 395 129 449 407 230 179 133 392 149 264 145 269 214 297 243 89 324 4 413 92 239 275 420 254 306 136 499 112 51 137 183 340 433 494 93 369 331 431 454 478 349 153 115 386 52 327 15 441 410 261 405 91 174 382 328 445 451 357 270 49 310 374 151 290 198 134 249 463 16 57 144 131 391 84 77 3 76 487 107 38 443 294 352 155 86 284 171 53 30 370 305 417 251 404 381 20 482 315 282 318 332 203 103 70 263 399 226 272 390 123 202 32 157 25 170 33 54 444 42 142 175 219 87 186 474 252 295 459 132 62 24 488 344 353 64 118 484 19 300 477 172 242 12 17 255 189 446 299 156 45 5 158 491 434 98 58 223 18 185 105 287 281 150 371 14 245 411 246 241 167 265 50 244 334 114 110 304 465 409 127 296 379 122 497 47 337 163 341 39 442 250 259 148 483 190 398 23 438 128 419 480 6 119 343 220 339 154 71 360 82 81 206 365 493 36 236 427 450 165 266 31 48 367 258 143 416 40 10 415 346 224 233 464 271 106 104 311 117 472 193 238 429 135 188 94 319 278 418 221 90 73 368 209 8 227 363 380 479 147 194 317 192 97 232 364 273 68 43 7 490 455 351 60 37 412 280 235 126 397 88 383 471 291 78 286 330 22 162 96 466 376 314 385 345 458 217 212 486 177 182 288 468 205 13 430 435 125 218 253 456 120 63 279 406 302 268 197 329 469 303 41 326 388 231 228 313 372 414 489 307 72 161 325 35 247 408 29 66 260 396 428 292 496 83 267 11 152 139 375 336 289 234 338 452 199 394 321 437 140 432 200 425 498 457 453 229 356 436 485 348 323 361 373 55 \\n\\nFinal solution score: 17.021426\\n\", \"tsp_run_first_test_sample_stderr\": \"\", \"average_tsp_run_time_elapsed\": 71.29766412621757, \"average_path_length\": 17.162940275670486, \"path_length_variance\": 0.03576492559521108}", "artifact_dir": null}